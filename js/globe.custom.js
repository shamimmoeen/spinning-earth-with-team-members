/*! globe 2020-09-07 */
/*HTML5 Globe interactive realtime 3d globe*/
var Detector = {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
        try {
            var a = document.createElement("canvas");
            return !(!window.WebGLRenderingContext || !a.getContext("webgl") && !a.getContext("experimental-webgl"))
        } catch (b) {
            return !1
        }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function() {
        var a = document.createElement("div");
        return a.id = "webgl-error-message",
        a.style.fontFamily = "monospace",
        a.style.fontSize = "13px",
        a.style.fontWeight = "normal",
        a.style.textAlign = "center",
        a.style.background = "#fff",
        a.style.color = "#000",
        a.style.padding = "1.5em",
        a.style.width = "400px",
        a.style.margin = "5em auto 0",
        this.webgl || (a.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")),
        a
    },
    addGetWebGLMessage: function(a) {
        var b, c, d;
        a = a || {},
        b = void 0 !== a.parent ? a.parent : document.body,
        c = void 0 !== a.id ? a.id : "oldie",
        d = Detector.getWebGLErrorMessage(),
        d.id = c,
        b.appendChild(d)
    }
};
"object" == typeof module && (module.exports = Detector);
var Stats = function() {
    var a, b, c, d, e, f, g, h, i = 0, j = 0, k = Date.now(), l = k, m = k, n = 0, o = 1e3, p = 0, q = [[16, 16, 48], [0, 255, 255]], r = 0, s = 1e3, t = 0, u = [[16, 48, 16], [0, 255, 0]];
    for (a = document.createElement("div"),
    a.style.cursor = "pointer",
    a.style.width = "80px",
    a.style.opacity = "0.9",
    a.style.zIndex = "10001",
    a.addEventListener("mousedown", function(a) {
        a.preventDefault(),
        i = (i + 1) % 2,
        0 == i ? (c.style.display = "block",
        f.style.display = "none") : (c.style.display = "none",
        f.style.display = "block")
    }, !1),
    c = document.createElement("div"),
    c.style.textAlign = "left",
    c.style.lineHeight = "1.2em",
    c.style.backgroundColor = "rgb(" + Math.floor(q[0][0] / 2) + "," + Math.floor(q[0][1] / 2) + "," + Math.floor(q[0][2] / 2) + ")",
    c.style.padding = "0 0 3px 3px",
    a.appendChild(c),
    d = document.createElement("div"),
    d.style.fontFamily = "Helvetica, Arial, sans-serif",
    d.style.fontSize = "9px",
    d.style.color = "rgb(" + q[1][0] + "," + q[1][1] + "," + q[1][2] + ")",
    d.style.fontWeight = "bold",
    d.innerHTML = "FPS",
    c.appendChild(d),
    e = document.createElement("div"),
    e.style.position = "relative",
    e.style.width = "74px",
    e.style.height = "30px",
    e.style.backgroundColor = "rgb(" + q[1][0] + "," + q[1][1] + "," + q[1][2] + ")",
    c.appendChild(e); e.children.length < 74; )
        b = document.createElement("span"),
        b.style.width = "1px",
        b.style.height = "30px",
        b.style.cssFloat = "left",
        b.style.backgroundColor = "rgb(" + q[0][0] + "," + q[0][1] + "," + q[0][2] + ")",
        e.appendChild(b);
    for (f = document.createElement("div"),
    f.style.textAlign = "left",
    f.style.lineHeight = "1.2em",
    f.style.backgroundColor = "rgb(" + Math.floor(u[0][0] / 2) + "," + Math.floor(u[0][1] / 2) + "," + Math.floor(u[0][2] / 2) + ")",
    f.style.padding = "0 0 3px 3px",
    f.style.display = "none",
    a.appendChild(f),
    g = document.createElement("div"),
    g.style.fontFamily = "Helvetica, Arial, sans-serif",
    g.style.fontSize = "9px",
    g.style.color = "rgb(" + u[1][0] + "," + u[1][1] + "," + u[1][2] + ")",
    g.style.fontWeight = "bold",
    g.innerHTML = "MS",
    f.appendChild(g),
    h = document.createElement("div"),
    h.style.position = "relative",
    h.style.width = "74px",
    h.style.height = "30px",
    h.style.backgroundColor = "rgb(" + u[1][0] + "," + u[1][1] + "," + u[1][2] + ")",
    f.appendChild(h); h.children.length < 74; )
        b = document.createElement("span"),
        b.style.width = "1px",
        b.style.height = 30 * Math.random() + "px",
        b.style.cssFloat = "left",
        b.style.backgroundColor = "rgb(" + u[0][0] + "," + u[0][1] + "," + u[0][2] + ")",
        h.appendChild(b);
    return {
        domElement: a,
        update: function() {
            k = Date.now(),
            r = k - l,
            s = Math.min(s, r),
            t = Math.max(t, r),
            g.textContent = r + " MS (" + s + "-" + t + ")";
            var a = Math.min(30, 30 - r / 200 * 30);
            h.appendChild(h.firstChild).style.height = a + "px",
            l = k,
            j++,
            k > m + 1e3 && (n = Math.round(1e3 * j / (k - m)),
            o = Math.min(o, n),
            p = Math.max(p, n),
            d.textContent = n + " FPS (" + o + "-" + p + ")",
            a = Math.min(30, 30 - n / 100 * 30),
            e.appendChild(e.firstChild).style.height = a + "px",
            m = k,
            j = 0)
        }
    }
}
  , TWEEN = TWEEN || function() {
    var a, b, c, d = 60, e = !1, f = [];
    return {
        setFPS: function(a) {
            d = a || 60
        },
        start: function(a) {
            0 != arguments.length && this.setFPS(a),
            b = setInterval(this.update, 1e3 / d)
        },
        stop: function() {
            clearInterval(b)
        },
        setAutostart: function(a) {
            e = a,
            e && !b && this.start()
        },
        add: function(a) {
            f.push(a),
            e && !b && this.start()
        },
        getAll: function() {
            return f
        },
        removeAll: function() {
            f = []
        },
        remove: function(b) {
            a = f.indexOf(b),
            -1 !== a && f.splice(a, 1)
        },
        update: function(b) {
            a = 0,
            c = f.length;
            for (var d = b || Date.now(); c > a; )
                f[a].update(d) ? a++ : (f.splice(a, 1),
                c--);
            0 == c && 1 == e && this.stop()
        }
    }
}();
TWEEN.Tween = function(a) {
    var b = a
      , c = {}
      , d = {}
      , e = {}
      , f = 1e3
      , g = 0
      , h = null
      , i = TWEEN.Easing.Linear.EaseNone
      , j = null
      , k = null
      , l = null;
    this.to = function(a, c) {
        null !== c && (f = c);
        for (var d in a)
            null !== b[d] && (e[d] = a[d]);
        return this
    }
    ,
    this.start = function(a) {
        TWEEN.add(this),
        h = a ? a + g : Date.now() + g;
        for (var f in e)
            null !== b[f] && (c[f] = b[f],
            d[f] = e[f] - b[f]);
        return this
    }
    ,
    this.stop = function() {
        return TWEEN.remove(this),
        this
    }
    ,
    this.delay = function(a) {
        return g = a,
        this
    }
    ,
    this.easing = function(a) {
        return i = a,
        this
    }
    ,
    this.chain = function(a) {
        return j = a,
        this
    }
    ,
    this.onUpdate = function(a) {
        return k = a,
        this
    }
    ,
    this.onComplete = function(a) {
        return l = a,
        this
    }
    ,
    this.update = function(a) {
        var e, g, m;
        if (h > a)
            return !0;
        g = (a - h) / f,
        g = g > 1 ? 1 : g,
        m = i(g);
        for (e in d)
            b[e] = c[e] + d[e] * m;
        return null !== k && k.call(b, m),
        1 == g ? (null !== l && l.call(b),
        null !== j && j.start(),
        !1) : !0
    }
}
,
TWEEN.Easing = {
    Linear: {},
    Quadratic: {},
    Cubic: {},
    Quartic: {},
    Quintic: {},
    Sinusoidal: {},
    Exponential: {},
    Circular: {},
    Elastic: {},
    Back: {},
    Bounce: {}
},
TWEEN.Easing.Linear.EaseNone = function(a) {
    return a
}
,
TWEEN.Easing.Quadratic.EaseIn = function(a) {
    return a * a
}
,
TWEEN.Easing.Quadratic.EaseOut = function(a) {
    return -a * (a - 2)
}
,
TWEEN.Easing.Quadratic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
}
,
TWEEN.Easing.Cubic.EaseIn = function(a) {
    return a * a * a
}
,
TWEEN.Easing.Cubic.EaseOut = function(a) {
    return --a * a * a + 1
}
,
TWEEN.Easing.Cubic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
}
,
TWEEN.Easing.Quartic.EaseIn = function(a) {
    return a * a * a * a
}
,
TWEEN.Easing.Quartic.EaseOut = function(a) {
    return -(--a * a * a * a - 1)
}
,
TWEEN.Easing.Quartic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
}
,
TWEEN.Easing.Quintic.EaseIn = function(a) {
    return a * a * a * a * a
}
,
TWEEN.Easing.Quintic.EaseOut = function(a) {
    return (a -= 1) * a * a * a * a + 1
}
,
TWEEN.Easing.Quintic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
}
,
TWEEN.Easing.Sinusoidal.EaseIn = function(a) {
    return -Math.cos(a * Math.PI / 2) + 1
}
,
TWEEN.Easing.Sinusoidal.EaseOut = function(a) {
    return Math.sin(a * Math.PI / 2)
}
,
TWEEN.Easing.Sinusoidal.EaseInOut = function(a) {
    return -.5 * (Math.cos(Math.PI * a) - 1)
}
,
TWEEN.Easing.Exponential.EaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1))
}
,
TWEEN.Easing.Exponential.EaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
}
,
TWEEN.Easing.Exponential.EaseInOut = function(a) {
    return 0 == a ? 0 : 1 == a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
}
,
TWEEN.Easing.Circular.EaseIn = function(a) {
    return -(Math.sqrt(1 - a * a) - 1)
}
,
TWEEN.Easing.Circular.EaseOut = function(a) {
    return Math.sqrt(1 - --a * a)
}
,
TWEEN.Easing.Circular.EaseInOut = function(a) {
    return (a /= .5) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
}
,
TWEEN.Easing.Elastic.EaseIn = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3),
    !c || 1 > c ? (c = 1,
    b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c),
    -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d)))
}
,
TWEEN.Easing.Elastic.EaseOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3),
    !c || 1 > c ? (c = 1,
    b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c),
    c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / d) + 1)
}
,
TWEEN.Easing.Elastic.EaseInOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3),
    !c || 1 > c ? (c = 1,
    b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c),
    (a *= 2) < 1 ? -.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) * .5 + 1)
}
,
TWEEN.Easing.Back.EaseIn = function(a) {
    var b = 1.70158;
    return a * a * ((b + 1) * a - b)
}
,
TWEEN.Easing.Back.EaseOut = function(a) {
    var b = 1.70158;
    return (a -= 1) * a * ((b + 1) * a + b) + 1
}
,
TWEEN.Easing.Back.EaseInOut = function(a) {
    var b = 2.5949095;
    return (a *= 2) < 1 ? .5 * a * a * ((b + 1) * a - b) : .5 * ((a -= 2) * a * ((b + 1) * a + b) + 2)
}
,
TWEEN.Easing.Bounce.EaseIn = function(a) {
    return 1 - TWEEN.Easing.Bounce.EaseOut(1 - a)
}
,
TWEEN.Easing.Bounce.EaseOut = function(a) {
    return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
}
,
TWEEN.Easing.Bounce.EaseInOut = function(a) {
    return .5 > a ? .5 * TWEEN.Easing.Bounce.EaseIn(2 * a) : .5 * TWEEN.Easing.Bounce.EaseOut(2 * a - 1) + .5
}
,
function(a) {
    function b(b, d) {
        function e() {
            if (console.warn = function() {}
            ,
            !Detector.webgl) {
                var b = U.$elem;
                a.get("noWebGl.html", function(a) {
                    return b.html(a),
                    !1
                })
            }
            U.$elem.empty(),
            U.hotspotTemplate = a("<div/>", {
                "class": "hotspot_marker"
            }).appendTo(U.$elem),
            U.overlay = a("<div/>", {
                "class": "h5g_overlay"
            }).appendTo(U.$elem),
            // U.overlayTemplate = a("<div/>", {
            //     "class": "mh_overlay"
            // }).appendTo(U.$elem),
            U.hotspotDetails = a("<div/>", {
                id: "hotspot_details"
            }).hide().appendTo(U.overlay),
            U.hotspotDetails_content = a("<div/>", {
                id: "details_content"
            }).appendTo(U.hotspotDetails),
            U.targetRotation_x = 0,
            U.targetRotation_y = 0,
            U.hotspotsArr = [],
            hotspotDivsArr = [],
            windowDimensionX = U.$elem.innerWidth(),
            windowDimensionY = U.$elem.innerHeight(),
            "unset" == d.assetPath.val && (d.assetPath.val = ""),
            a.colorbox.settings.width = d.popWidth.val,
            a.colorbox.settings.height = d.popHeight.val,
            a.colorbox.settings.scalePhotos = !0,
            a.colorbox.settings.maxWidth = "95%",
            U.isScaling = !1,
            U.initialPinchDist = 0,
            U.handlersPaused = !1,
            doingOrbit = !1,
            j(),
            f(),
            C()
        }
        function f() {
            k(),
            l(),
            m(),
            d.debugMode.val === !0 && A()
        }
        function g(a) {
            var b = -1;
            "downIn" == d.zoomWheelDirection.val && (b = -1),
            "downOut" == d.zoomWheelDirection.val && (b = 1),
            a *= b;
            var c = U.camera.zoom + U.camera.zoom * a / 3;
            zoomObj = {
                zoomValue: c,
                zoomTime: 500,
                restricted: !0
            },
            i(zoomObj)
        }
        function h(a) {
            if (!(Math.abs(U.initialPinchDist - a) < 15)) {
                var b = a - U.initialPinchDist
                  , c = U.camera.zoom;
                b = b > 0 ? 1.2 : .8;
                var d = b * c;
                U.initialPinchDist = a,
                zoomObj = {
                    zoomValue: d,
                    zoomTime: 500,
                    restricted: !0
                },
                i(zoomObj)
            }
        }
        function i(a) {
            var b = {
                value: U.camera.zoom
            }
              , c = {
                value: a.zoomValue
            };
            a.restricted && (c.value <= d.globeMinScale.val && (c.value = d.globeMinScale.val),
            c.value >= d.globeMaxScale.val && (c.value = d.globeMaxScale.val)),
            new TWEEN.Tween(b).to(c, a.zoomTime).easing(TWEEN.Easing.Quartic.EaseOut).onUpdate(function() {
                U.camera.zoom = b.value,
                U.camera.updateProjectionMatrix()
            }).start()
        }
        function j() {
            try {
                cancelAnimationFrame(U.animationHandler)
            } catch (a) {}
        }
        function k() {
            U.globeContainer = new THREE.Object3D,
            U.globeContainer.name = "globeContainer",
            U.globeContainerParent = new THREE.Object3D,
            U.globeContainerParent.name = "globeContainerParent",
            backPlateContainer = new THREE.Object3D,
            backPlateContainer.name = "backPlateContainer",
            U.scaleContainer = new THREE.Object3D,
            U.scaleContainer.name = "mee.scaleContainer",
            U.globeArr = [],
            U.scene = new THREE.Scene,
            window.s = U.scene,
            U.camera = new THREE.OrthographicCamera(0,0,0,0,.1,2e3),
            U.camera.position.x = U.camDolly,
            U.camera.position.y = 0,
            U.camera.position.z = 0,
            U.camera.lookAt(new THREE.Vector3(d.cameraTargetX.val,d.cameraTargetY.val,d.cameraTargetZ.val)),
            U.camera.left = -200,
            U.camera.right = 200,
            U.camera.top = 200,
            U.camera.bottom = -200,
            U.camera.updateProjectionMatrix(),
            U.scene.add(U.camera),
            ambient = new THREE.PointLight(d.ambientColor.val,d.ambientIntensity.val),
            ambient.position.set(d.ambientPosX.val, d.ambientPosY.val, d.ambientPosZ.val),
            ambient.castShadow = !1,
            U.scaleContainer.add(ambient),
            headLamp = new THREE.PointLight(d.headLampColor.val,d.headLampIntensity.val,3e3),
            headLamp.position.set(d.headLampPosX.val, d.headLampPosY.val, d.headLampPosZ.val),
            headLamp.lookAt(U.globeContainer.position),
            headLamp.castShadow = !1,
            U.scaleContainer.add(headLamp);
            var b = new THREE.AmbientLight(10066329);
            U.scaleContainer.add(b),
            U.renderer || (U.renderer = new THREE.WebGLRenderer({
                antialias: !0,
                alpha: !0
            })),
            U.renderer.clear(),
            U.renderer.autoClear = !0,
            a(U.renderer.domElement).css({
                height: "100%",
                width: "100%",
                top: 0,
                bottom: 0,
                position: "absolute"
            }),
            backPlateTexture = THREE.ImageUtils.loadTexture(d.assetPath.val + d.backPlateTexture.val),
            globeTexture = THREE.ImageUtils.loadTexture(d.assetPath.val + d.globeTexture.val);
            var c = U.renderer.getMaxAnisotropy();
            backPlateTexture.anisotropy = c,
            globeTexture.anisotropy = c;
            var e;
            "" != d.globeBump.val ? (globeBump = THREE.ImageUtils.loadTexture(d.assetPath.val + d.globeBump.val),
            globeBump.minFilter = THREE.LinearFilter,
            globeBump.magFilter = THREE.LinearFilter,
            e = new THREE.MeshPhongMaterial({
                bumpScale: 25,
                bumpMap: globeBump,
                map: globeTexture,
                ambient: 5592405,
                color: 16777215,
                specular: 5592405,
                shininess: d.globeShine.val
            })) : e = new THREE.MeshPhongMaterial({
                map: globeTexture,
                ambient: 5592405,
                color: 16777215,
                specular: 5592405,
                shininess: d.globeShine.val
            }),
            backPlateMaterial = new THREE.MeshBasicMaterial({
                map: backPlateTexture,
                color: 16777215,
                alphaTest: 0,
                transparent: !0,
                side: THREE.FrontSide
            }),
            U.globeGeo = new THREE.Mesh(new THREE.SphereGeometry(d.globeRadius.val,d.globeSegments.val,d.globeSegments.val),e),
            U.globeGeo.position.x = 0,
            U.globeGeo.position.y = 0,
            U.globeGeo.position.z = 0,
            U.globeGeo.name = "theGlobe",
            U.globeContainer.add(U.globeGeo),
            U.globeArr.push(U.globeGeo);
            var f = 2 * d.globeRadius.val + 1 * d.backPlateMargin.val;
            backPlate = new THREE.Mesh(new THREE.PlaneBufferGeometry(f,f),backPlateMaterial),
            backPlate.rotation.y = .5 * Math.PI,
            backPlateContainer.add(backPlate),
            U.$elem.append(U.renderer.domElement),
            U.scene.add(U.scaleContainer),
            U.scaleContainer.add(backPlateContainer),
            U.scaleContainer.add(U.globeContainerParent),
            U.globeContainerParent.add(U.globeContainer)
        }
        function l() {
            hotspotDivsArr = a(d.contentClass.val).clone();
            for (var b = 0; b < hotspotDivsArr.length; b++) {
                var c = a(hotspotDivsArr[b]).data("long")
                  , e = a(hotspotDivsArr[b]).data("lat")
                  , f = a(hotspotDivsArr[b]).data();
                f.pos = H(e, c, d.globeRadius.val),
                f.html = a(hotspotDivsArr[b]).html();
                var g = G(f);
                g.onmouseover = g.onMouseOver,
                g.onmouseout = g.onMouseOut,
                U.hotspotsArr.push(g)
            }
        }
        function m() {
            // U.handlersPaused = !1,
            // U.$elem.on("mousedown", this, q),
            // U.$elem.on("touchstart", this, p),
            // U.$elem.mousewheel({
            //     "this": this
            // }, o)
        }
        function n() {
            U.handlersPaused = !0,
            U.$elem.off("mousedown"),
            U.$elem.off("touchstart"),
            U.$elem.unmousewheel()
        }
        function o(a, b) {
            0 != d.allowUserZoom.val && (a.preventDefault(),
            y(),
            g(b))
        }
        function p(b) {
            b.preventDefault ? b.preventDefault() : b.returnValue = !1;
            var c = b.originalEvent;
            mouseDown = !0,
            mouseY = c.touches[0].pageY - U.$elem.offset().top,
            mouseX = c.touches[0].pageX - U.$elem.offset().left;
            var e = w(mouseX, mouseY);
            1 == e && (U.$elem.off("touchmove", r),
            U.$elem.on("touchmove", this, r),
            a(document).on("touchend", this, t),
            mouseXOnMouseDown = c.touches[0].clientX - windowDimensionX,
            targetRotationOnMouseDown_x = U.targetRotation_x,
            mouseYOnMouseDown = c.touches[0].clientY - windowDimensionY,
            targetRotationOnMouseDown_y = U.targetRotation_y,
            d.autoRotate.val = !1,
            1 == d.allowUserZoom.val && 2 == c.touches.length && (doingOrbit = !0,
            U.isScaling = !0,
            U.initialPinchDist = x(c)))
        }
        function q(b) {
            mouseDown = !0,
            mouseY = b.pageY - U.$elem.offset().top,
            mouseX = b.pageX - U.$elem.offset().left;
            var c = w(mouseX, mouseY);
            1 == c && (b.preventDefault(),
            U.$elem.on("mousemove", this, s),
            a(document).on("mouseup", this, u),
            mouseXOnMouseDown = b.clientX - windowDimensionX,
            targetRotationOnMouseDown_x = U.targetRotation_x,
            mouseYOnMouseDown = b.clientY - windowDimensionY,
            targetRotationOnMouseDown_y = U.targetRotation_y,
            d.autoRotate.val = !1)
        }
        function r(a) {
            a.preventDefault(),
            y();
            var b = a.originalEvent;
            if (U.isScaling)
                h(x(b)),
                doingOrbit = !0;
            else {
                mouseX = b.touches[0].clientX - windowDimensionX,
                U.targetRotation_x = targetRotationOnMouseDown_x + .01 * (mouseX - mouseXOnMouseDown),
                mouseY = b.touches[0].clientY - windowDimensionY,
                U.targetRotation_y = targetRotationOnMouseDown_y + .01 * (mouseY - mouseYOnMouseDown);
                var c = Math.abs(mouseX - mouseXOnMouseDown) + Math.abs(mouseY - mouseYOnMouseDown);
                c > 5 && (doingOrbit = !0)
            }
        }
        function s(a) {
            y(),
            mouseX = a.clientX - windowDimensionX,
            U.targetRotation_x = targetRotationOnMouseDown_x + .01 * (mouseX - mouseXOnMouseDown),
            mouseY = a.clientY - windowDimensionY,
            U.targetRotation_y = targetRotationOnMouseDown_y + .01 * (mouseY - mouseYOnMouseDown)
        }
        function t() {
            mouseDown = !1,
            U.$elem.off("touchmove", r),
            a(document).off("touchend", t),
            U.isScaling = !1,
            E()
        }
        function u() {
            mouseDown = !1,
            U.$elem.off("mousemove", s),
            a(document).off("mouseup", u),
            E()
        }
        function v(a, b, c) {
            var d = a / windowDimensionX * 2 - 1
              , e = 2 * -(b / windowDimensionY) + 1
              , f = new THREE.Raycaster
              , g = new THREE.Vector2(d,e);
            f.setFromCamera(g, U.camera);
            var h = f.intersectObjects(c, !0);
            return h
        }
        function w(a, b) {
            var c = !1;
            if (1 == d.onlyOrbitOnGlobe.val) {
                var e = v(a, b, U.globeArr);
                e.length > 0 && (c = !0)
            } else
                c = !0;
            return c
        }
        function x(a) {
            var b = Math.sqrt((a.touches[0].pageX - a.touches[1].pageX) * (a.touches[0].pageX - a.touches[1].pageX) + (a.touches[0].pageY - a.touches[1].pageY) * (a.touches[0].pageY - a.touches[1].pageY));
            return b
        }
        function y() {
            U.hotspotDetails.css({
                display: "none",
                transform: "perspective(400px) rotateX(90deg)",
                "-webkit-transform": "perspective(400px) rotateX(90deg)"
            })
        }
        function z(a, b, c) {
            U.hotspotDetails.css({
                display: "inline",
                top: a,
                left: b,
                transform: "perspective(400px) rotateX(0deg)",
                "-webkit-transform": "perspective(400px) rotateX(0deg)"
            }),
            U.hotspotDetails_content.html(c)
        }
        function A() {
            B()
        }
        function B() {
            stats = new Stats,
            stats.domElement.style.position = "absolute",
            stats.domElement.style.top = "0px",
            U.$elem.append(stats.domElement)
        }
        function C() {
            U.animationHandler = requestAnimationFrame(C.bind(U)),
            U.targetRotation_y < -1.4 && (U.targetRotation_y = -1.4),
            U.targetRotation_y > 1.4 && (U.targetRotation_y = 1.4),
            0 != d.autoRotate.val && 0 != d.autoRotate.val && (U.targetRotation_x = U.targetRotation_x + 1 * d.autoRotateSpeed.val),
            U.globeContainer.rotation.y += (U.targetRotation_x - U.globeContainer.rotation.y) * d.momentum.val,
            U.globeContainerParent.rotation.z += (-1 * U.targetRotation_y - U.globeContainerParent.rotation.z) * d.momentum.val,
            TWEEN.update(),
            E()
        }
        function D(a) {
            var b = a.domElement
              , c = b.clientWidth
              , d = b.clientHeight
              , e = b.width !== c || b.height !== d;
            return e
        }
        function E() {
            if (D(U.renderer)) {
                var a = U.renderer.domElement;
                windowDimensionX = a.clientWidth,
                windowDimensionY = a.clientHeight,
                U.renderer.setSize(windowDimensionX, windowDimensionY, !1)
            }
            U.renderer.render(U.scene, U.camera),
            d.debugMode.val === !0 && stats.update();
            for (var b = 0; b < U.hotspotsArr.length; b++) {
                var c = U.hotspotsArr[b].getPosition();
                c = new THREE.Vector3(c.x,c.y,c.z);
                var e = U.globeContainer.localToWorld(c)
                  , f = F(e)
                  , g = U.hotspotsArr[b].data.hotspotalign
                  , h = U.hotspotsArr[b].data.dim;
                switch (g) {
                case "LT":
                    break;
                case "MT":
                    f.x = f.x - h.width / 2;
                    break;
                case "RT":
                    f.x = f.x - h.width;
                    break;
                case "LM":
                    f.y = f.y - h.height / 2;
                    break;
                case "MM":
                    f.x = f.x - h.width / 2,
                    f.y = f.y - h.height / 2;
                    break;
                case "RM":
                    f.x = f.x - h.width,
                    f.y = f.y - h.height / 2;
                    break;
                case "LB":
                    f.y = f.y - h.height;
                    break;
                case "MB":
                    f.x = f.x - h.width / 2,
                    f.y = f.y - h.height;
                    break;
                case "RB":
                    f.x = f.x - h.width,
                    f.y = f.y - h.height
                }
                U.hotspotsArr[b].setPosition(f.x, f.y, c.z),
                U.hotspotsArr[b].setVisible(c.z < .5),
                U.hotspotsArr[b].setOpacity(c.z)
            }
        }
        function F(a) {
            var b = new Object;
            return a.project(U.camera),
            b.x = a.x * (windowDimensionX / 2) + windowDimensionX / 2,
            b.y = (0 - a.y) * (windowDimensionY / 2) + windowDimensionY / 2,
            b
        }
        function G(b) {
            var c = U.hotspotTemplate.clone().appendTo(U.overlay)
              , e = c.get(0);
            for (var f in b)
                a(e).attr("data-" + f, b[f]);
            return c.addClass(d.hotspotCssOverride.val),
            e.data = b,
            c.addClass(e.data.hotspotclass),
            e.data.zMod = 0,
            (void 0 == e.data.hotspoticon || "" == e.data.hotspoticon) && (e.data.hotspoticon = d.hotSpotIcon.val),
            c.html("<img src='" + d.assetPath.val + e.data.hotspoticon + "' alt='icon' draggable='false'>"),
            e.selected = !1,
            e.hover = !1,
            // e.onMouseOver = function() {
            //     if (!U.handlersPaused) {
            //         var b = void 0 != this.data.headtxt && "" != this.data.headtxt ? this.data.headtxt : this.data.html;
            //         z(a(this).position().top + this.data.dim.height, a(this).position().left, b),
            //         this.data.zMod = 9999
            //     }
            // }
            // ,
            // e.onMouseOut = function() {
            //     U.handlersPaused || (this.data.zMod = 0,
            //     y())
            // }
            // ,
            // e.ontouchend = function(a) {
            //     0 == doingOrbit && hotspotClick(a, this),
            //     doingOrbit = !1
            // }
            // ,
            // e.onmousedown = function(a) {
            //     hotspotClick(a, this)
            // }
            // ,
            hotspotClick = function(b, c) {
                d.autoRotate.val = !1,
                clickedHotspot = c;
                var e = void 0 != clickedHotspot.data.popwidth ? clickedHotspot.data.popwidth : d.popWidth.val
                  , f = void 0 != clickedHotspot.data.popheight ? clickedHotspot.data.popHeight : d.popHeight.val;
                return void 0 != clickedHotspot.data.clickexternal && "" != clickedHotspot.data.clickexternal ? (window[clickedHotspot.data.clickexternal](clickedHotspot.data, clickedHotspot),
                void 0) : d.clickExternal.val && 0 != d.clickExternal.val ? (window[d.clickExternal.val](clickedHotspot.data, clickedHotspot),
                void 0) : (void 0 != clickedHotspot.data.url && "" != clickedHotspot.data.url ? "_blank" == clickedHotspot.data.urltarget || "_parent" == clickedHotspot.data.urltarget ? window.open(clickedHotspot.data.url, clickedHotspot.data.urltarget) : a.colorbox({
                    href: clickedHotspot.data.url,
                    iframe: !0,
                    width: e,
                    height: f
                }) : a.colorbox({
                    html: clickedHotspot.data.html,
                    width: e,
                    height: f
                }),
                void 0)
            }
            ,
            e.setPosition = function(a, b, c) {
                this.style.transform = "translate(" + a + "px," + b + "px)",
                this.style.zIndex = Math.round(500 + c + this.data.zMod)
            }
            ,
            e.setVisible = function(a) {
                this.style.display = a ? "inline" : "none"
            }
            ,
            e.setOpacity = function(a) {
                var b = 20 * (1 - a - .5);
                this.style.opacity = b
            }
            ,
            e.getPosition = function() {
                return this.data.pos
            }
            ,
            e.getDim = function() {
                var a = {}
                  , b = new Image;
                return b.onload = function() {
                    a.width = this.width,
                    a.height = this.height,
                    document.body.removeChild(b)
                }
                ,
                b.src = d.assetPath.val + e.data.hotspoticon,
                b.style.position = "absolute",
                b.style.left = -9999,
                b.style.visibility = "hidden",
                document.body.appendChild(b),
                a
            }
            ,
            e.data.dim = e.getDim(),
            e
        }
        function H(a, b, c) {
            b = -1 * b;
            var d = c * Math.cos(a * Math.PI / 180) * Math.cos(b * Math.PI / 180)
              , e = c * Math.sin(a * Math.PI / 180)
              , f = c * Math.cos(a * Math.PI / 180) * Math.sin(b * Math.PI / 180);
            return {
                x: d,
                y: e,
                z: f
            }
        }
        function I() {
            var a = U.globeContainerParent.rotation.z
              , b = U.globeContainer.rotation.y % (2 * Math.PI);
            b *= -1,
            b > Math.PI && (b -= 2 * Math.PI);
            var c = {};
            return c._z = 180 * a / Math.PI * -1,
            c._y = 180 * b / Math.PI,
            c.lat = c._z,
            c.lng = c._y,
            c
        }
        function J() {
            return U.camera.zoom
        }
        function K() {
            var a = new THREE.Vector3
              , b = new THREE.Raycaster
              , c = new THREE.Vector3
              , e = mouseX / windowDimensionX * 2 - 1
              , f = 2 * -(mouseY / windowDimensionY) + 1;
            a.set(e, f, -1),
            a.unproject(U.camera),
            c.set(0, 0, -1).transformDirection(U.camera.matrixWorld),
            b.set(a, c);
            var g = b.intersectObjects(U.globeArr, !0);
            if (g.length > 0) {
                var h = g[0].point
                  , i = (U.globeContainer.worldToLocal(h),
                90 - 180 * Math.acos(h.y / d.globeRadius.val) / Math.PI);
                i = i.toFixed(3);
                var j = (-270 + 180 * Math.atan2(h.x, h.z) / Math.PI) % 360 + 180;
                j = j.toFixed(3);
                var k = {};
                return k.lat = i,
                k.lon = j,
                k
            }
        }
        function L() {
            U.hotspotsArr = [],
            U.overlay.empty(),
            a("._hotspot").addClass("hotspot"),
            l()
        }
        function M(a, b) {
            i({
                zoomValue: a,
                zoomTime: b,
                restricted: !1
            })
        }
        function N() {
            n()
        }
        function O() {
            m()
        }
        function P(a, b) {
            if (void 0 != b) {
                b %= 360;
                {
                    var c = U.globeContainer.rotation.y;
                    U.globeContainer.rotation.y * (180 / Math.PI)
                }
                U.globeContainer.rotation.y = c % (2 * Math.PI);
                var d = -b * (Math.PI / 180);
                U.targetRotation_x = d
            }
            void 0 != a && (U.targetRotation_y = a * (Math.PI / 180) % Math.PI)
        }
        function Q(a, b) {
            return b ? (d[a] = b,
            void 0) : d[a]
        }
        function R() {
            return d
        }
        function S() {
            d.autoRotate.val = !0
        }
        function T(a) {
            e(),
            P(a._z, a._y),
            a.zoomLevel && M(a.zoomLevel, 500)
        }
        {
            var U = this;
            a(b)
        }
        return U.elem = b,
        U.$elem = a(b),
        U.camDolly = 1500,
        d = a.extend(!0, {}, a.fn[c].options, d),
        e(),
        {
            option: Q,
            rotate: P,
            refresh: L,
            getOptions: R,
            reInit: T,
            getCoords: K,
            getRotation: I,
            zoom: M,
            getZoom: J,
            startNav: O,
            pauseNav: N,
            startAutoRotate: S
        }
    }
    var c = "globe";
    a.fn[c] = function(d) {
        if ("string" == typeof arguments[0]) {
            var e, f = arguments[0], g = Array.prototype.slice.call(arguments, 1);
            return this.each(function() {
                if (!a.data(this, "plugin_" + c) || "function" != typeof a.data(this, "plugin_" + c)[f])
                    throw new Error("Method " + f + " does not exist on jQuery." + c);
                e = a.data(this, "plugin_" + c)[f].apply(this, g)
            }),
            void 0 !== e ? e : this
        }
        return "object" != typeof d && d ? void 0 : this.each(function() {
            a.data(this, "plugin_" + c) || (_me = a.data(this, "plugin_" + c, new b(this,d)))
        })
    }
    ,
    a.fn[c].options = {
        globeRadius: {
            val: 200,
            desc: "defines the size of the globe"
        },
        globeShine: {
            val: 10,
            desc: "defines the shininess of the globes material"
        },
        globeTexture: {
            val: "textures/earthmap10k_comp.jpg",
            desc: "defines wich texture to use for the globe"
        },
        globeBump: {
            val: "textures/earthbump1k.jpg",
            desc: "defines wich texture to use for the globe"
        },
        globeMinScale: {
            val: .3,
            desc: "sets minimum zoomlevel"
        },
        globeMaxScale: {
            val: 2.5,
            desc: "sets maximum zoomlevel"
        },
        globeSegments: {
            val: 50,
            desc: "defines the globes coarsness - high value (50) gives smooth and round globe, lower values might increase performance on slow systems"
        },
        momentum: {
            val: .07,
            desc: "defines the globes rotation-momentum, low values produce more momentum (the globe appears heavier)"
        },
        ambientIntensity: {
            val: "2.5",
            desc: "defines the intensity for the ambient light"
        },
        ambientColor: {
            val: "#555584",
            desc: "defines the color for the ambient light"
        },
        ambientPosX: {
            val: "-5000",
            desc: "defines the x-position for the ambient light"
        },
        ambientPosY: {
            val: "-15000",
            desc: "defines the y-position for the ambient light"
        },
        ambientPosZ: {
            val: "-15000",
            desc: "defines the z-position for the ambient light"
        },
        headLampIntensity: {
            val: 1.2,
            desc: "defines intensity for the main light"
        },
        headLampColor: {
            val: "#ffffff",
            desc: "defines color for the main light"
        },
        headLampPosX: {
            val: 500,
            desc: "defines x position for the main light"
        },
        headLampPosY: {
            val: 1e3,
            desc: "defines y position for the main light"
        },
        headLampPosZ: {
            val: 0,
            desc: "defines z position for the main light"
        },
        hotSpotIcon: {
            val: "textures/hotspotIconsOrange/nano_LT.png",
            desc: "default texture for the hotspots - hotspots are alignet left-top by default"
        },
        backPlateTexture: {
            val: "textures/backPlate_glow.png",
            desc: "texture for the globes halo"
        },
        backPlateMargin: {
            val: 50,
            desc: "defines how far the halo extends from the globe"
        },
        debugMode: {
            val: !1,
            desc: "used for testing"
        },
        popWidth: {
            val: "80%",
            desc: "default maxwidth for colorbox popup"
        },
        popHeight: {
            val: "80%",
            desc: "default maxheight for colorbox popup"
        },
        contentClass: {
            val: ".hotspot",
            desc: "wich class to use for hotspotgeneration"
        },
        hotspotCssOverride: {
            val: "hotspot_override",
            desc: "Use this to override graphic properties on hotspots"
        },
        cameraTargetX: {
            val: 0,
            desc: "cameras target x position"
        },
        cameraTargetY: {
            val: 0,
            desc: "cameras target y position"
        },
        cameraTargetZ: {
            val: 0,
            desc: "cameras target z position"
        },
        autoRotateSpeed: {
            val: .02,
            desc: "sets the speed on autorotate"
        },
        autoRotate: {
            val: !0,
            desc: "makes the globe autorotate on startup"
        },
        clickExternal: {
            val: !1,
            desc: "name of custom function to call on hotspotclick - overrides the default lightbox popup"
        },
        assetPath: {
            val: "",
            desc: "Use this to prepend all assets with a path"
        },
        zoomWheelDirection: {
            val: "downIn",
            desc: "Use this to control the direction of zoomwheel zooms - options are 'downIn' or 'downOut'"
        },
        onlyOrbitOnGlobe: {
            val: !0,
            desc: "If true the globe only reacts if mouse is hitting it directly - if false the globe reacts on all inputs on its containing div"
        },
        allowUserZoom: {
            val: !0,
            desc: "If false zooming is disabled"
        }
    }
}(jQuery),
function(a, b, c) {
    function d(c, d, e) {
        var f = b.createElement(c);
        return d && (f.id = X + d),
        e && (f.style.cssText = e),
        a(f)
    }
    function e(a) {
        var b = v.length
          , c = (N + a) % b;
        return 0 > c ? b + c : c
    }
    function f(a, b) {
        return Math.round((/%/.test(a) ? ("x" === b ? w.width() : w.height()) / 100 : 1) * parseInt(a, 10))
    }
    function g(a) {
        return H.photo || /\.(gif|png|jpe?g|bmp|ico)((#|\?).*)?$/i.test(a)
    }
    function h() {
        var b;
        H = a.extend({}, a.data(M, W));
        for (b in H)
            a.isFunction(H[b]) && "on" !== b.slice(0, 2) && (H[b] = H[b].call(M));
        H.rel = H.rel || M.rel || "nofollow",
        H.href = H.href || a(M).attr("href"),
        H.title = H.title || M.title,
        "string" == typeof H.href && (H.href = a.trim(H.href))
    }
    function i(b, c) {
        a.event.trigger(b),
        c && c.call(M)
    }
    function j() {
        var a, b, c, d = X + "Slideshow_", e = "click." + X;
        H.slideshow && v[1] ? (b = function() {
            C.text(H.slideshowStop).unbind(e).bind(_, function() {
                (H.loop || v[N + 1]) && (a = setTimeout(T.next, H.slideshowSpeed))
            }).bind($, function() {
                clearTimeout(a)
            }).one(e + " " + ab, c),
            o.removeClass(d + "off").addClass(d + "on"),
            a = setTimeout(T.next, H.slideshowSpeed)
        }
        ,
        c = function() {
            clearTimeout(a),
            C.text(H.slideshowStart).unbind([_, $, ab, e].join(" ")).one(e, function() {
                T.next(),
                b()
            }),
            o.removeClass(d + "on").addClass(d + "off")
        }
        ,
        H.slideshowAuto ? b() : c()) : o.removeClass(d + "off " + d + "on")
    }
    function k(b) {
        R || (M = b,
        h(),
        v = a(M),
        N = 0,
        "nofollow" !== H.rel && (v = a("." + Y).filter(function() {
            var b = a.data(this, W).rel || this.rel;
            return b === H.rel
        }),
        N = v.index(M),
        -1 === N && (v = v.add(M),
        N = v.length - 1)),
        P || (P = Q = !0,
        o.show(),
        H.returnFocus && a(M).blur().one(bb, function() {
            a(this).focus()
        }),
        n.css({
            opacity: +H.opacity,
            cursor: H.overlayClose ? "pointer" : "auto"
        }).show(),
        H.w = f(H.initialWidth, "x"),
        H.h = f(H.initialHeight, "y"),
        T.position(),
        eb && w.bind("resize." + fb + " scroll." + fb, function() {
            n.css({
                width: w.width(),
                height: w.height(),
                top: w.scrollTop(),
                left: w.scrollLeft()
            })
        }).trigger("resize." + fb),
        i(Z, H.onOpen),
        G.add(A).hide(),
        F.html(H.close).show()),
        T.load(!0))
    }
    function l() {
        !o && b.body && (U = !1,
        w = a(c),
        o = d(gb).attr({
            id: W,
            "class": db ? X + (eb ? "IE6" : "IE") : ""
        }).hide(),
        n = d(gb, "Overlay", eb ? "position:absolute" : "").hide(),
        p = d(gb, "Wrapper"),
        q = d(gb, "Content").append(x = d(gb, "LoadedContent", "width:0; height:0; overflow:hidden"), z = d(gb, "LoadingOverlay").add(d(gb, "LoadingGraphic")), A = d(gb, "Title"), B = d(gb, "Current"), D = d(gb, "Next"), E = d(gb, "Previous"), C = d(gb, "Slideshow").bind(Z, j), F = d(gb, "Close")),
        p.append(d(gb).append(d(gb, "TopLeft"), r = d(gb, "TopCenter"), d(gb, "TopRight")), d(gb, !1, "clear:left").append(s = d(gb, "MiddleLeft"), q, t = d(gb, "MiddleRight")), d(gb, !1, "clear:left").append(d(gb, "BottomLeft"), u = d(gb, "BottomCenter"), d(gb, "BottomRight"))).find("div div").css({
            "float": "left"
        }),
        y = d(gb, !1, "position:absolute; width:9999px; visibility:hidden; display:none"),
        G = D.add(E).add(B).add(C),
        a(b.body).append(n, o.append(p, y)))
    }
    function m() {
        return o ? (U || (U = !0,
        I = r.height() + u.height() + q.outerHeight(!0) - q.height(),
        J = s.width() + t.width() + q.outerWidth(!0) - q.width(),
        K = x.outerHeight(!0),
        L = x.outerWidth(!0),
        o.css({
            "padding-bottom": I,
            "padding-right": J
        }),
        D.click(function() {
            T.next()
        }),
        E.click(function() {
            T.prev()
        }),
        F.click(function() {
            T.close()
        }),
        n.click(function() {
            H.overlayClose && T.close()
        }),
        a(b).bind("keydown." + X, function(a) {
            var b = a.keyCode;
            P && H.escKey && 27 === b && (a.preventDefault(),
            T.close()),
            P && H.arrowKey && v[1] && (37 === b ? (a.preventDefault(),
            E.click()) : 39 === b && (a.preventDefault(),
            D.click()))
        }),
        a("." + Y, b).live("click", function(a) {
            a.which > 1 || a.shiftKey || a.altKey || a.metaKey || (a.preventDefault(),
            k(this))
        })),
        !0) : !1
    }
    var n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V = {
        transition: "elastic",
        speed: 300,
        width: !1,
        initialWidth: "600",
        innerWidth: !1,
        maxWidth: !1,
        height: !1,
        initialHeight: "450",
        innerHeight: !1,
        maxHeight: !1,
        scalePhotos: !0,
        scrolling: !0,
        inline: !1,
        html: !1,
        iframe: !1,
        fastIframe: !0,
        photo: !1,
        href: !1,
        title: !1,
        rel: !1,
        opacity: .9,
        preloading: !0,
        current: "image {current} of {total}",
        previous: "previous",
        next: "next",
        close: "close",
        open: !1,
        returnFocus: !0,
        reposition: !0,
        loop: !0,
        slideshow: !1,
        slideshowAuto: !0,
        slideshowSpeed: 2500,
        slideshowStart: "start slideshow",
        slideshowStop: "stop slideshow",
        onOpen: !1,
        onLoad: !1,
        onComplete: !1,
        onCleanup: !1,
        onClosed: !1,
        overlayClose: !0,
        escKey: !0,
        arrowKey: !0,
        top: !1,
        bottom: !1,
        left: !1,
        right: !1,
        fixed: !1,
        data: void 0
    }, W = "colorbox", X = "cbox", Y = X + "Element", Z = X + "_open", $ = X + "_load", _ = X + "_complete", ab = X + "_cleanup", bb = X + "_closed", cb = X + "_purge", db = !a.support.opacity && !a.support.style, eb = db && !c.XMLHttpRequest, fb = X + "_IE6", gb = "div";
    a.colorbox || (a(l),
    T = a.fn[W] = a[W] = function(b, c) {
        var d = this;
        if (b = b || {},
        l(),
        m()) {
            if (!d[0]) {
                if (d.selector)
                    return d;
                d = a("<a/>"),
                b.open = !0
            }
            c && (b.onComplete = c),
            d.each(function() {
                a.data(this, W, a.extend({}, a.data(this, W) || V, b))
            }).addClass(Y),
            (a.isFunction(b.open) && b.open.call(d) || b.open) && k(d[0])
        }
        return d
    }
    ,
    T.position = function(a, b) {
        function c(a) {
            r[0].style.width = u[0].style.width = q[0].style.width = a.style.width,
            q[0].style.height = s[0].style.height = t[0].style.height = a.style.height
        }
        var d = 0
          , e = 0
          , g = o.offset()
          , h = w.scrollTop()
          , i = w.scrollLeft();
        w.unbind("resize." + X),
        o.css({
            top: -9e4,
            left: -9e4
        }),
        H.fixed && !eb ? (g.top -= h,
        g.left -= i,
        o.css({
            position: "fixed"
        })) : (d = h,
        e = i,
        o.css({
            position: "absolute"
        })),
        e += H.right !== !1 ? Math.max(w.width() - H.w - L - J - f(H.right, "x"), 0) : H.left !== !1 ? f(H.left, "x") : Math.round(Math.max(w.width() - H.w - L - J, 0) / 2),
        d += H.bottom !== !1 ? Math.max(w.height() - H.h - K - I - f(H.bottom, "y"), 0) : H.top !== !1 ? f(H.top, "y") : Math.round(Math.max(w.height() - H.h - K - I, 0) / 2),
        o.css({
            top: g.top,
            left: g.left
        }),
        a = o.width() === H.w + L && o.height() === H.h + K ? 0 : a || 0,
        p[0].style.width = p[0].style.height = "9999px",
        o.dequeue().animate({
            width: H.w + L,
            height: H.h + K,
            top: d,
            left: e
        }, {
            duration: a,
            complete: function() {
                c(this),
                Q = !1,
                p[0].style.width = H.w + L + J + "px",
                p[0].style.height = H.h + K + I + "px",
                H.reposition && setTimeout(function() {
                    w.bind("resize." + X, T.position)
                }, 1),
                b && b()
            },
            step: function() {
                c(this)
            }
        })
    }
    ,
    T.resize = function(a) {
        P && (a = a || {},
        a.width && (H.w = f(a.width, "x") - L - J),
        a.innerWidth && (H.w = f(a.innerWidth, "x")),
        x.css({
            width: H.w
        }),
        a.height && (H.h = f(a.height, "y") - K - I),
        a.innerHeight && (H.h = f(a.innerHeight, "y")),
        !a.innerHeight && !a.height && (x.css({
            height: "auto"
        }),
        H.h = x.height()),
        x.css({
            height: H.h
        }),
        T.position("none" === H.transition ? 0 : H.speed))
    }
    ,
    T.prep = function(b) {
        function c() {
            return H.w = H.w || x.width(),
            H.w = H.mw && H.mw < H.w ? H.mw : H.w,
            H.w
        }
        function f() {
            return H.h = H.h || x.height(),
            H.h = H.mh && H.mh < H.h ? H.mh : H.h,
            H.h
        }
        if (P) {
            var h, j = "none" === H.transition ? 0 : H.speed;
            x.remove(),
            x = d(gb, "LoadedContent").append(b),
            x.hide().appendTo(y.show()).css({
                width: c(),
                overflow: H.scrolling ? "auto" : "hidden"
            }).css({
                height: f()
            }).prependTo(q),
            y.hide(),
            a(O).css({
                "float": "none"
            }),
            eb && a("select").not(o.find("select")).filter(function() {
                return "hidden" !== this.style.visibility
            }).css({
                visibility: "hidden"
            }).one(ab, function() {
                this.style.visibility = "inherit"
            }),
            h = function() {
                function b() {
                    db && o[0].style.removeAttribute("filter")
                }
                var c, f, h, k, l, m, n = v.length, p = "frameBorder", q = "allowTransparency";
                if (P) {
                    if (k = function() {
                        clearTimeout(S),
                        z.hide(),
                        i(_, H.onComplete)
                    }
                    ,
                    db && O && x.fadeIn(100),
                    A.html(H.title).add(x).show(),
                    n > 1) {
                        if ("string" == typeof H.current && B.html(H.current.replace("{current}", N + 1).replace("{total}", n)).show(),
                        D[H.loop || n - 1 > N ? "show" : "hide"]().html(H.next),
                        E[H.loop || N ? "show" : "hide"]().html(H.previous),
                        H.slideshow && C.show(),
                        H.preloading)
                            for (c = [e(-1), e(1)]; f = v[c.pop()]; )
                                l = a.data(f, W).href || f.href,
                                a.isFunction(l) && (l = l.call(f)),
                                g(l) && (m = new Image,
                                m.src = l)
                    } else
                        G.hide();
                    H.iframe ? (h = d("iframe")[0],
                    p in h && (h[p] = 0),
                    q in h && (h[q] = "true"),
                    h.name = X + +new Date,
                    H.fastIframe ? k() : a(h).one("load", k),
                    h.src = H.href,
                    H.scrolling || (h.scrolling = "no"),
                    a(h).addClass(X + "Iframe").appendTo(x).one(cb, function() {
                        h.src = "//about:blank"
                    })) : k(),
                    "fade" === H.transition ? o.fadeTo(j, 1, b) : b()
                }
            }
            ,
            "fade" === H.transition ? o.fadeTo(j, 0, function() {
                T.position(0, h)
            }) : T.position(j, h)
        }
    }
    ,
    T.load = function(b) {
        var c, e, j = T.prep;
        Q = !0,
        O = !1,
        M = v[N],
        b || h(),
        i(cb),
        i($, H.onLoad),
        H.h = H.height ? f(H.height, "y") - K - I : H.innerHeight && f(H.innerHeight, "y"),
        H.w = H.width ? f(H.width, "x") - L - J : H.innerWidth && f(H.innerWidth, "x"),
        H.mw = H.w,
        H.mh = H.h,
        H.maxWidth && (H.mw = f(H.maxWidth, "x") - L - J,
        H.mw = H.w && H.w < H.mw ? H.w : H.mw),
        H.maxHeight && (H.mh = f(H.maxHeight, "y") - K - I,
        H.mh = H.h && H.h < H.mh ? H.h : H.mh),
        c = H.href,
        S = setTimeout(function() {
            z.show()
        }, 100),
        H.inline ? (d(gb).hide().insertBefore(a(c)[0]).one(cb, function() {
            a(this).replaceWith(x.children())
        }),
        j(a(c))) : H.iframe ? j(" ") : H.html ? j(H.html) : g(c) ? (a(O = new Image).addClass(X + "Photo").error(function() {
            H.title = !1,
            j(d(gb, "Error").text("This image could not be loaded"))
        }).load(function() {
            var a;
            O.onload = null,
            H.scalePhotos && (e = function() {
                O.height -= O.height * a,
                O.width -= O.width * a
            }
            ,
            H.mw && O.width > H.mw && (a = (O.width - H.mw) / O.width,
            e()),
            H.mh && O.height > H.mh && (a = (O.height - H.mh) / O.height,
            e())),
            H.h && (O.style.marginTop = Math.max(H.h - O.height, 0) / 2 + "px"),
            v[1] && (H.loop || v[N + 1]) && (O.style.cursor = "pointer",
            O.onclick = function() {
                T.next()
            }
            ),
            db && (O.style.msInterpolationMode = "bicubic"),
            setTimeout(function() {
                j(O)
            }, 1)
        }),
        setTimeout(function() {
            O.src = c
        }, 1)) : c && y.load(c, H.data, function(b, c, e) {
            j("error" === c ? d(gb, "Error").text("Request unsuccessful: " + e.statusText) : a(this).contents())
        })
    }
    ,
    T.next = function() {
        !Q && v[1] && (H.loop || v[N + 1]) && (N = e(1),
        T.load())
    }
    ,
    T.prev = function() {
        !Q && v[1] && (H.loop || N) && (N = e(-1),
        T.load())
    }
    ,
    T.close = function() {
        P && !R && (R = !0,
        P = !1,
        i(ab, H.onCleanup),
        w.unbind("." + X + " ." + fb),
        n.fadeTo(200, 0),
        o.stop().fadeTo(300, 0, function() {
            o.add(n).css({
                opacity: 1,
                cursor: "auto"
            }).hide(),
            i(cb),
            x.remove(),
            setTimeout(function() {
                R = !1,
                i(bb, H.onClosed)
            }, 1)
        }))
    }
    ,
    T.remove = function() {
        a([]).add(o).add(n).remove(),
        o = null,
        a("." + Y).removeData(W).removeClass(Y).die()
    }
    ,
    T.element = function() {
        return a(M)
    }
    ,
    T.settings = V)
}(jQuery, document, this),
function(a) {
    function b(b) {
        var c = b || window.event
          , d = [].slice.call(arguments, 1)
          , e = 0
          , f = 0
          , g = 0;
        return b = a.event.fix(c),
        b.type = "mousewheel",
        c.wheelDelta && (e = c.wheelDelta / 120),
        c.detail && (e = -c.detail / 3),
        g = e,
        void 0 !== c.axis && c.axis === c.HORIZONTAL_AXIS && (g = 0,
        f = -1 * e),
        void 0 !== c.wheelDeltaY && (g = c.wheelDeltaY / 120),
        void 0 !== c.wheelDeltaX && (f = -1 * c.wheelDeltaX / 120),
        d.unshift(b, e, f, g),
        (a.event.dispatch || a.event.handle).apply(this, d)
    }
    var c = ["DOMMouseScroll", "mousewheel"];
    if (a.event.fixHooks)
        for (var d = c.length; d; )
            a.event.fixHooks[c[--d]] = a.event.mouseHooks;
    a.event.special.mousewheel = {
        setup: function() {
            if (this.addEventListener)
                for (var a = c.length; a; )
                    this.addEventListener(c[--a], b, !1);
            else
                this.onmousewheel = b
        },
        teardown: function() {
            if (this.removeEventListener)
                for (var a = c.length; a; )
                    this.removeEventListener(c[--a], b, !1);
            else
                this.onmousewheel = null
        }
    },
    a.fn.extend({
        mousewheel: function(a, b) {
            return null == b && (b = a,
            a = null),
            b ? this.bind("mousewheel", a, b) : this.trigger("mousewheel")
        },
        unmousewheel: function(a) {
            return this.unbind("mousewheel", a)
        }
    })
}(jQuery),
function(a, b) {
    "object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : (a = a || self,
    b(a.THREE = {}))
}(this, function(a) {
    function b() {}
    function c(a, b) {
        this.x = a || 0,
        this.y = b || 0
    }
    function d(a, b, c, d) {
        this._x = a || 0,
        this._y = b || 0,
        this._z = c || 0,
        this._w = void 0 !== d ? d : 1
    }
    function e(a, b, c) {
        this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0
    }
    function f() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    function g(a, b, d, e, h, i, j, k, l, m) {
        Object.defineProperty(this, "id", {
            value: Yg++
        }),
        this.uuid = Sg.generateUUID(),
        this.name = "",
        this.image = void 0 !== a ? a : g.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== b ? b : g.DEFAULT_MAPPING,
        this.wrapS = void 0 !== d ? d : 1001,
        this.wrapT = void 0 !== e ? e : 1001,
        this.magFilter = void 0 !== h ? h : 1006,
        this.minFilter = void 0 !== i ? i : 1008,
        this.anisotropy = void 0 !== l ? l : 1,
        this.format = void 0 !== j ? j : 1023,
        this.internalFormat = null,
        this.type = void 0 !== k ? k : 1009,
        this.offset = new c(0,0),
        this.repeat = new c(1,1),
        this.center = new c(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new f,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== m ? m : 3e3,
        this.version = 0,
        this.onUpdate = null
    }
    function h(a, b, c, d) {
        this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0,
        this.w = void 0 !== d ? d : 1
    }
    function i(a, b, c) {
        this.width = a,
        this.height = b,
        this.scissor = new h(0,0,a,b),
        this.scissorTest = !1,
        this.viewport = new h(0,0,a,b),
        c = c || {},
        this.texture = new g(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding),
        this.texture.image = {},
        this.texture.image.width = a,
        this.texture.image.height = b,
        this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : !1,
        this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006,
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0,
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0,
        this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
    }
    function j(a, b, c) {
        i.call(this, a, b, c),
        this.samples = 4
    }
    function k() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    function l(a, b, c, d) {
        this._x = a || 0,
        this._y = b || 0,
        this._z = c || 0,
        this._order = d || l.DefaultOrder
    }
    function m() {
        this.mask = 1
    }
    function n() {
        Object.defineProperty(this, "id", {
            value: gh++
        }),
        this.uuid = Sg.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = n.DefaultUp.clone();
        var a = new e
          , b = new l
          , c = new d
          , g = new e(1,1,1);
        b._onChange(function() {
            c.setFromEuler(b, !1)
        }),
        c._onChange(function() {
            b.setFromQuaternion(c, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: a
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: b
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: c
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: g
            },
            modelViewMatrix: {
                value: new k
            },
            normalMatrix: {
                value: new f
            }
        }),
        this.matrix = new k,
        this.matrixWorld = new k,
        this.matrixAutoUpdate = n.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new m,
        this.visible = !0,
        this.receiveShadow = this.castShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function o() {
        n.call(this),
        this.type = "Scene",
        this.overrideMaterial = this.fog = this.environment = this.background = null,
        this.autoUpdate = !0,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    function p(a, b) {
        this.min = void 0 !== a ? a : new e(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== b ? b : new e(-1 / 0,-1 / 0,-1 / 0)
    }
    function q(a, b, c, d, e) {
        var f, g = 0;
        for (f = a.length - 3; f >= g; g += 3) {
            Fh.fromArray(a, g);
            var h = e.x * Math.abs(Fh.x) + e.y * Math.abs(Fh.y) + e.z * Math.abs(Fh.z)
              , i = b.dot(Fh)
              , j = c.dot(Fh)
              , k = d.dot(Fh);
            if (Math.max(-Math.max(i, j, k), Math.min(i, j, k)) > h)
                return !1
        }
        return !0
    }
    function r(a, b) {
        this.center = void 0 !== a ? a : new e,
        this.radius = void 0 !== b ? b : 0
    }
    function s(a, b) {
        this.origin = void 0 !== a ? a : new e,
        this.direction = void 0 !== b ? b : new e(0,0,-1)
    }
    function t(a, b) {
        this.normal = void 0 !== a ? a : new e(1,0,0),
        this.constant = void 0 !== b ? b : 0
    }
    function u(a, b, c) {
        this.a = void 0 !== a ? a : new e,
        this.b = void 0 !== b ? b : new e,
        this.c = void 0 !== c ? c : new e
    }
    function v(a, b, c) {
        return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
    }
    function w(a, b, c) {
        return 0 > c && (c += 1),
        c > 1 && --c,
        1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a
    }
    function x(a) {
        return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4)
    }
    function y(a) {
        return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055
    }
    function z(a, b, c, d, f, g) {
        this.a = a,
        this.b = b,
        this.c = c,
        this.normal = d && d.isVector3 ? d : new e,
        this.vertexNormals = Array.isArray(d) ? d : [],
        this.color = f && f.isColor ? f : new v,
        this.vertexColors = Array.isArray(f) ? f : [],
        this.materialIndex = void 0 !== g ? g : 0
    }
    function A() {
        Object.defineProperty(this, "id", {
            value: ci++
        }),
        this.uuid = Sg.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.vertexTangents = this.flatShading = !1,
        this.vertexColors = 0,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = 100,
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null,
        this.depthFunc = 3,
        this.depthWrite = this.depthTest = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilZPass = this.stencilZFail = this.stencilFail = 7680,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipShadows = this.clipIntersection = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.toneMapped = this.visible = !0,
        this.userData = {},
        this.version = 0
    }
    function B(a) {
        A.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new v(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function C(a, b, c) {
        if (Array.isArray(a))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = a,
        this.itemSize = b,
        this.count = void 0 !== a ? a.length / b : 0,
        this.normalized = !0 === c,
        this.usage = 35044,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function D(a, b, c) {
        C.call(this, new Int8Array(a), b, c)
    }
    function E(a, b, c) {
        C.call(this, new Uint8Array(a), b, c)
    }
    function F(a, b, c) {
        C.call(this, new Uint8ClampedArray(a), b, c)
    }
    function G(a, b, c) {
        C.call(this, new Int16Array(a), b, c)
    }
    function H(a, b, c) {
        C.call(this, new Uint16Array(a), b, c)
    }
    function I(a, b, c) {
        C.call(this, new Int32Array(a), b, c)
    }
    function J(a, b, c) {
        C.call(this, new Uint32Array(a), b, c)
    }
    function K(a, b, c) {
        C.call(this, new Float32Array(a), b, c)
    }
    function L(a, b, c) {
        C.call(this, new Float64Array(a), b, c)
    }
    function M() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }
    function N(a) {
        if (0 === a.length)
            return -1 / 0;
        for (var b = a[0], c = 1, d = a.length; d > c; ++c)
            a[c] > b && (b = a[c]);
        return b
    }
    function O() {
        Object.defineProperty(this, "id", {
            value: ei += 2
        }),
        this.uuid = Sg.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingSphere = this.boundingBox = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function P(a, b) {
        n.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== a ? a : new O,
        this.material = void 0 !== b ? b : new B({
            color: 16777215 * Math.random()
        }),
        this.updateMorphTargets()
    }
    function Q(a, b, c, d, e, f, g, h) {
        return null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h)) ? null : (Bi.copy(h),
        Bi.applyMatrix4(a.matrixWorld),
        b = c.ray.origin.distanceTo(Bi),
        b < c.near || b > c.far ? null : {
            distance: b,
            point: Bi.clone(),
            object: a
        })
    }
    function R(a, b, d, e, f, g, h, i, j, k, l, m) {
        if (oi.fromBufferAttribute(f, k),
        pi.fromBufferAttribute(f, l),
        qi.fromBufferAttribute(f, m),
        f = a.morphTargetInfluences,
        b.morphTargets && g && f) {
            ui.set(0, 0, 0),
            vi.set(0, 0, 0),
            wi.set(0, 0, 0);
            for (var n = 0, o = g.length; o > n; n++) {
                var p = f[n]
                  , q = g[n];
                0 !== p && (ri.fromBufferAttribute(q, k),
                si.fromBufferAttribute(q, l),
                ti.fromBufferAttribute(q, m),
                h ? (ui.addScaledVector(ri, p),
                vi.addScaledVector(si, p),
                wi.addScaledVector(ti, p)) : (ui.addScaledVector(ri.sub(oi), p),
                vi.addScaledVector(si.sub(pi), p),
                wi.addScaledVector(ti.sub(qi), p)))
            }
            oi.add(ui),
            pi.add(vi),
            qi.add(wi)
        }
        return (a = Q(a, b, d, e, oi, pi, qi, Ai)) && (i && (xi.fromBufferAttribute(i, k),
        yi.fromBufferAttribute(i, l),
        zi.fromBufferAttribute(i, m),
        a.uv = u.getUV(Ai, oi, pi, qi, xi, yi, zi, new c)),
        j && (xi.fromBufferAttribute(j, k),
        yi.fromBufferAttribute(j, l),
        zi.fromBufferAttribute(j, m),
        a.uv2 = u.getUV(Ai, oi, pi, qi, xi, yi, zi, new c)),
        i = new z(k,l,m),
        u.getNormal(oi, pi, qi, i.normal),
        a.face = i),
        a
    }
    function S() {
        Object.defineProperty(this, "id", {
            value: Ci += 2
        }),
        this.uuid = Sg.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }
    function T(a) {
        var b, c = {};
        for (b in a) {
            c[b] = {};
            for (var d in a[b]) {
                var e = a[b][d];
                c[b][d] = e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? e.clone() : Array.isArray(e) ? e.slice() : e
            }
        }
        return c
    }
    function U(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d, e = T(a[c]);
            for (d in e)
                b[d] = e[d]
        }
        return b
    }
    function V(a) {
        A.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(a))
    }
    function W() {
        n.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new k,
        this.projectionMatrix = new k,
        this.projectionMatrixInverse = new k
    }
    function X(a, b, c, d) {
        W.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== a ? a : 50,
        this.zoom = 1,
        this.near = void 0 !== c ? c : .1,
        this.far = void 0 !== d ? d : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== b ? b : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function Y(a, b, c, d) {
        n.call(this),
        this.type = "CubeCamera";
        var f = new X(90,1,a,b);
        f.up.set(0, -1, 0),
        f.lookAt(new e(1,0,0)),
        this.add(f);
        var g = new X(90,1,a,b);
        g.up.set(0, -1, 0),
        g.lookAt(new e(-1,0,0)),
        this.add(g);
        var h = new X(90,1,a,b);
        h.up.set(0, 0, 1),
        h.lookAt(new e(0,1,0)),
        this.add(h);
        var i = new X(90,1,a,b);
        i.up.set(0, 0, -1),
        i.lookAt(new e(0,-1,0)),
        this.add(i);
        var j = new X(90,1,a,b);
        j.up.set(0, -1, 0),
        j.lookAt(new e(0,0,1)),
        this.add(j);
        var k = new X(90,1,a,b);
        k.up.set(0, -1, 0),
        k.lookAt(new e(0,0,-1)),
        this.add(k),
        d = d || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        },
        this.renderTarget = new Z(c,c,d),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = a.getRenderTarget()
              , d = this.renderTarget
              , e = d.texture.generateMipmaps;
            d.texture.generateMipmaps = !1,
            a.setRenderTarget(d, 0),
            a.render(b, f),
            a.setRenderTarget(d, 1),
            a.render(b, g),
            a.setRenderTarget(d, 2),
            a.render(b, h),
            a.setRenderTarget(d, 3),
            a.render(b, i),
            a.setRenderTarget(d, 4),
            a.render(b, j),
            d.texture.generateMipmaps = e,
            a.setRenderTarget(d, 5),
            a.render(b, k),
            a.setRenderTarget(c)
        }
        ,
        this.clear = function(a, b, c, d) {
            for (var e = a.getRenderTarget(), f = this.renderTarget, g = 0; 6 > g; g++)
                a.setRenderTarget(f, g),
                a.clear(b, c, d);
            a.setRenderTarget(e)
        }
    }
    function Z(a, b, c) {
        i.call(this, a, b, c)
    }
    function $(a, b, c, d, e, f, h, i, j, k, l, m) {
        g.call(this, null, f, h, i, j, k, d, e, l, m),
        this.image = {
            data: a || null,
            width: b || 1,
            height: c || 1
        },
        this.magFilter = void 0 !== j ? j : 1003,
        this.minFilter = void 0 !== k ? k : 1003,
        this.flipY = this.generateMipmaps = !1,
        this.unpackAlignment = 1,
        this.needsUpdate = !0
    }
    function _(a, b, c, d, e, f) {
        this.planes = [void 0 !== a ? a : new t, void 0 !== b ? b : new t, void 0 !== c ? c : new t, void 0 !== d ? d : new t, void 0 !== e ? e : new t, void 0 !== f ? f : new t]
    }
    function ab() {
        function a(e, f) {
            !1 !== c && (d(e, f),
            b.requestAnimationFrame(a))
        }
        var b = null
          , c = !1
          , d = null;
        return {
            start: function() {
                !0 !== c && null !== d && (b.requestAnimationFrame(a),
                c = !0)
            },
            stop: function() {
                c = !1
            },
            setAnimationLoop: function(a) {
                d = a
            },
            setContext: function(a) {
                b = a
            }
        }
    }
    function bb(a) {
        function b(b, c) {
            var d = b.array
              , e = b.usage
              , f = a.createBuffer();
            return a.bindBuffer(c, f),
            a.bufferData(c, d, e),
            b.onUploadCallback(),
            c = 5126,
            d instanceof Float32Array ? c = 5126 : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = 5123 : d instanceof Int16Array ? c = 5122 : d instanceof Uint32Array ? c = 5125 : d instanceof Int32Array ? c = 5124 : d instanceof Int8Array ? c = 5120 : d instanceof Uint8Array && (c = 5121),
            {
                buffer: f,
                type: c,
                bytesPerElement: d.BYTES_PER_ELEMENT,
                version: b.version
            }
        }
        var c = new WeakMap;
        return {
            get: function(a) {
                return a.isInterleavedBufferAttribute && (a = a.data),
                c.get(a)
            },
            remove: function(b) {
                b.isInterleavedBufferAttribute && (b = b.data);
                var d = c.get(b);
                d && (a.deleteBuffer(d.buffer),
                c.delete(b))
            },
            update: function(d, e) {
                d.isInterleavedBufferAttribute && (d = d.data);
                var f = c.get(d);
                if (void 0 === f)
                    c.set(d, b(d, e));
                else if (f.version < d.version) {
                    var g = d.array
                      , h = d.updateRange;
                    a.bindBuffer(e, f.buffer),
                    -1 === h.count ? a.bufferSubData(e, 0, g) : (a.bufferSubData(e, h.offset * g.BYTES_PER_ELEMENT, g.subarray(h.offset, h.offset + h.count)),
                    h.count = -1),
                    f.version = d.version
                }
            }
        }
    }
    function cb(a, b, c, d) {
        S.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        },
        this.fromBufferGeometry(new db(a,b,c,d)),
        this.mergeVertices()
    }
    function db(a, b, c, d) {
        O.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        },
        a = a || 1,
        b = b || 1;
        var e = a / 2
          , f = b / 2;
        c = Math.floor(c) || 1,
        d = Math.floor(d) || 1;
        var g = c + 1
          , h = d + 1
          , i = a / c
          , j = b / d
          , k = []
          , l = []
          , m = []
          , n = [];
        for (a = 0; h > a; a++) {
            var o = a * j - f;
            for (b = 0; g > b; b++)
                l.push(b * i - e, -o, 0),
                m.push(0, 0, 1),
                n.push(b / c),
                n.push(1 - a / d)
        }
        for (a = 0; d > a; a++)
            for (b = 0; c > b; b++)
                e = b + g * (a + 1),
                f = b + 1 + g * (a + 1),
                h = b + 1 + g * a,
                k.push(b + g * a, e, h),
                k.push(e, f, h);
        this.setIndex(k),
        this.setAttribute("position", new K(l,3)),
        this.setAttribute("normal", new K(m,3)),
        this.setAttribute("uv", new K(n,2))
    }
    function eb(a, b, c, d) {
        function e(a, c) {
            b.buffers.color.setClear(a.r, a.g, a.b, c, d)
        }
        var f, g, h = new v(0), i = 0, j = null, k = 0;
        return {
            getClearColor: function() {
                return h
            },
            setClearColor: function(a, b) {
                h.set(a),
                i = void 0 !== b ? b : 1,
                e(h, i)
            },
            getClearAlpha: function() {
                return i
            },
            setClearAlpha: function(a) {
                i = a,
                e(h, i)
            },
            render: function(b, d, l, m) {
                d = d.background,
                l = a.xr,
                (l = l.getSession && l.getSession()) && "additive" === l.environmentBlendMode && (d = null),
                null === d ? (e(h, i),
                j = null,
                k = 0) : d && d.isColor && (e(d, 1),
                m = !0,
                j = null,
                k = 0),
                (a.autoClear || m) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil),
                d && (d.isCubeTexture || d.isWebGLRenderTargetCube || 306 === d.mapping) ? (void 0 === g && (g = new P(new Hi(1,1,1),new V({
                    type: "BackgroundCubeMaterial",
                    uniforms: T(Ni.cube.uniforms),
                    vertexShader: Ni.cube.vertexShader,
                    fragmentShader: Ni.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                g.geometry.deleteAttribute("normal"),
                g.geometry.deleteAttribute("uv"),
                g.onBeforeRender = function(a, b, c) {
                    this.matrixWorld.copyPosition(c.matrixWorld)
                }
                ,
                Object.defineProperty(g.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                c.update(g)),
                m = d.isWebGLRenderTargetCube ? d.texture : d,
                g.material.uniforms.envMap.value = m,
                g.material.uniforms.flipEnvMap.value = m.isCubeTexture ? -1 : 1,
                (j !== d || k !== m.version) && (g.material.needsUpdate = !0,
                j = d,
                k = m.version),
                b.unshift(g, g.geometry, g.material, 0, 0, null)) : d && d.isTexture && (void 0 === f && (f = new P(new db(2,2),new V({
                    type: "BackgroundMaterial",
                    uniforms: T(Ni.background.uniforms),
                    vertexShader: Ni.background.vertexShader,
                    fragmentShader: Ni.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                f.geometry.deleteAttribute("normal"),
                Object.defineProperty(f.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                c.update(f)),
                f.material.uniforms.t2D.value = d,
                !0 === d.matrixAutoUpdate && d.updateMatrix(),
                f.material.uniforms.uvTransform.value.copy(d.matrix),
                (j !== d || k !== d.version) && (f.material.needsUpdate = !0,
                j = d,
                k = d.version),
                b.unshift(f, f.geometry, f.material, 0, 0, null))
            }
        }
    }
    function fb(a, b, c, d) {
        var e, f = d.isWebGL2;
        this.setMode = function(a) {
            e = a
        }
        ,
        this.render = function(b, d) {
            a.drawArrays(e, b, d),
            c.update(d, e)
        }
        ,
        this.renderInstances = function(d, g, h, i) {
            if (0 !== i) {
                if (f) {
                    d = a;
                    var j = "drawArraysInstanced"
                } else if (d = b.get("ANGLE_instanced_arrays"),
                j = "drawArraysInstancedANGLE",
                null === d)
                    return console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."),
                    void 0;
                d[j](e, g, h, i),
                c.update(h, e, i)
            }
        }
    }
    function gb(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision)
                    return "highp";
                b = "mediump"
            }
            return "mediump" === b && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var e, f = "undefined" != typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && a instanceof WebGL2ComputeRenderingContext, g = void 0 !== c.precision ? c.precision : "highp", h = d(g);
        h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."),
        g = h),
        c = !0 === c.logarithmicDepthBuffer,
        h = a.getParameter(34930);
        var i = a.getParameter(35660)
          , j = a.getParameter(3379)
          , k = a.getParameter(34076)
          , l = a.getParameter(34921)
          , m = a.getParameter(36347)
          , n = a.getParameter(36348)
          , o = a.getParameter(36349)
          , p = i > 0
          , q = f || !!b.get("OES_texture_float")
          , r = p && q
          , s = f ? a.getParameter(36183) : 0;
        return {
            isWebGL2: f,
            getMaxAnisotropy: function() {
                if (void 0 !== e)
                    return e;
                var c = b.get("EXT_texture_filter_anisotropic");
                return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: d,
            precision: g,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: i,
            maxTextureSize: j,
            maxCubemapSize: k,
            maxAttributes: l,
            maxVertexUniforms: m,
            maxVaryings: n,
            maxFragmentUniforms: o,
            vertexTextures: p,
            floatFragmentTextures: q,
            floatVertexTextures: r,
            maxSamples: s
        }
    }
    function hb() {
        function a() {
            k.value !== d && (k.value = d,
            k.needsUpdate = e > 0),
            c.numPlanes = e,
            c.numIntersection = 0
        }
        function b(a, b, d, e) {
            var f = null !== a ? a.length : 0
              , g = null;
            if (0 !== f) {
                if (g = k.value,
                !0 !== e || null === g)
                    for (e = d + 4 * f,
                    b = b.matrixWorldInverse,
                    j.getNormalMatrix(b),
                    (null === g || g.length < e) && (g = new Float32Array(e)),
                    e = 0; e !== f; ++e,
                    d += 4)
                        i.copy(a[e]).applyMatrix4(b, j),
                        i.normal.toArray(g, d),
                        g[d + 3] = i.constant;
                k.value = g,
                k.needsUpdate = !0
            }
            return c.numPlanes = f,
            g
        }
        var c = this
          , d = null
          , e = 0
          , g = !1
          , h = !1
          , i = new t
          , j = new f
          , k = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = k,
        this.numIntersection = this.numPlanes = 0,
        this.init = function(a, c, f) {
            var h = 0 !== a.length || c || 0 !== e || g;
            return g = c,
            d = b(a, f, 0),
            e = a.length,
            h
        }
        ,
        this.beginShadows = function() {
            h = !0,
            b(null)
        }
        ,
        this.endShadows = function() {
            h = !1,
            a()
        }
        ,
        this.setState = function(c, f, i, j, l, m) {
            if (!g || null === c || 0 === c.length || h && !i)
                h ? b(null) : a();
            else {
                i = h ? 0 : e;
                var n = 4 * i
                  , o = l.clippingState || null;
                for (k.value = o,
                o = b(c, j, n, m),
                c = 0; c !== n; ++c)
                    o[c] = d[c];
                l.clippingState = o,
                this.numIntersection = f ? this.numPlanes : 0,
                this.numPlanes += i
            }
        }
    }
    function ib(a) {
        var b = {};
        return {
            get: function(c) {
                if (void 0 !== b[c])
                    return b[c];
                switch (c) {
                case "WEBGL_depth_texture":
                    var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    d = a.getExtension(c)
                }
                return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."),
                b[c] = d
            }
        }
    }
    function jb(a, b, c) {
        function d(a) {
            var e = a.target;
            a = f.get(e),
            null !== a.index && b.remove(a.index);
            for (var h in a.attributes)
                b.remove(a.attributes[h]);
            e.removeEventListener("dispose", d),
            f.delete(e),
            (h = g.get(a)) && (b.remove(h),
            g.delete(a)),
            c.memory.geometries--
        }
        function e(a) {
            var c = []
              , d = a.index
              , e = a.attributes.position;
            if (null !== d) {
                var f = d.array;
                d = d.version,
                e = 0;
                for (var h = f.length; h > e; e += 3) {
                    var i = f[e + 0]
                      , j = f[e + 1]
                      , k = f[e + 2];
                    c.push(i, j, j, k, k, i)
                }
            } else
                for (f = e.array,
                d = e.version,
                e = 0,
                h = f.length / 3 - 1; h > e; e += 3)
                    i = e + 0,
                    j = e + 1,
                    k = e + 2,
                    c.push(i, j, j, k, k, i);
            c = new (65535 < N(c) ? J : H)(c,1),
            c.version = d,
            b.update(c, 34963),
            (f = g.get(a)) && b.remove(f),
            g.set(a, c)
        }
        var f = new WeakMap
          , g = new WeakMap;
        return {
            get: function(a, b) {
                var e = f.get(b);
                return e ? e : (b.addEventListener("dispose", d),
                b.isBufferGeometry ? e = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new O).setFromObject(a)),
                e = b._bufferGeometry),
                f.set(b, e),
                c.memory.geometries++,
                e)
            },
            update: function(a) {
                var c = a.index
                  , d = a.attributes;
                null !== c && b.update(c, 34963);
                for (var e in d)
                    b.update(d[e], 34962);
                a = a.morphAttributes;
                for (e in a) {
                    c = a[e],
                    d = 0;
                    for (var f = c.length; f > d; d++)
                        b.update(c[d], 34962)
                }
            },
            getWireframeAttribute: function(a) {
                var b = g.get(a);
                if (b) {
                    var c = a.index;
                    null !== c && b.version < c.version && e(a)
                } else
                    e(a);
                return g.get(a)
            }
        }
    }
    function kb(a, b, c, d) {
        var e, f, g, h = d.isWebGL2;
        this.setMode = function(a) {
            e = a
        }
        ,
        this.setIndex = function(a) {
            f = a.type,
            g = a.bytesPerElement
        }
        ,
        this.render = function(b, d) {
            a.drawElements(e, d, f, b * g),
            c.update(d, e)
        }
        ,
        this.renderInstances = function(d, i, j, k) {
            if (0 !== k) {
                if (h) {
                    d = a;
                    var l = "drawElementsInstanced"
                } else if (d = b.get("ANGLE_instanced_arrays"),
                l = "drawElementsInstancedANGLE",
                null === d)
                    return console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."),
                    void 0;
                d[l](e, j, f, i * g, k),
                c.update(j, e, k)
            }
        }
    }
    function lb() {
        var a = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: a,
            programs: null,
            autoReset: !0,
            reset: function() {
                a.frame++,
                a.calls = 0,
                a.triangles = 0,
                a.points = 0,
                a.lines = 0
            },
            update: function(b, c, d) {
                switch (d = d || 1,
                a.calls++,
                c) {
                case 4:
                    a.triangles += b / 3 * d;
                    break;
                case 1:
                    a.lines += b / 2 * d;
                    break;
                case 3:
                    a.lines += d * (b - 1);
                    break;
                case 2:
                    a.lines += d * b;
                    break;
                case 0:
                    a.points += d * b;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", c)
                }
            }
        }
    }
    function mb(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1])
    }
    function nb(a) {
        var b = {}
          , c = new Float32Array(8);
        return {
            update: function(d, e, f, g) {
                var h = d.morphTargetInfluences
                  , i = void 0 === h ? 0 : h.length;
                if (d = b[e.id],
                void 0 === d) {
                    d = [];
                    for (var j = 0; i > j; j++)
                        d[j] = [j, 0];
                    b[e.id] = d
                }
                var k = f.morphTargets && e.morphAttributes.position;
                for (f = f.morphNormals && e.morphAttributes.normal,
                j = 0; i > j; j++) {
                    var l = d[j];
                    0 !== l[1] && (k && e.deleteAttribute("morphTarget" + j),
                    f && e.deleteAttribute("morphNormal" + j))
                }
                for (j = 0; i > j; j++)
                    l = d[j],
                    l[0] = j,
                    l[1] = h[j];
                for (d.sort(mb),
                j = h = 0; 8 > j; j++)
                    (l = d[j]) && (i = l[0],
                    l = l[1]) ? (k && e.setAttribute("morphTarget" + j, k[i]),
                    f && e.setAttribute("morphNormal" + j, f[i]),
                    c[j] = l,
                    h += l) : c[j] = 0;
                e = e.morphTargetsRelative ? 1 : 1 - h,
                g.getUniforms().setValue(a, "morphTargetBaseInfluence", e),
                g.getUniforms().setValue(a, "morphTargetInfluences", c)
            }
        }
    }
    function ob(a, b, c, d) {
        var e = {};
        return {
            update: function(a) {
                var f = d.render.frame
                  , g = a.geometry
                  , h = b.get(a, g);
                return e[h.id] !== f && (g.isGeometry && h.updateFromObject(a),
                b.update(h),
                e[h.id] = f),
                a.isInstancedMesh && c.update(a.instanceMatrix, 34962),
                h
            },
            dispose: function() {
                e = {}
            }
        }
    }
    function pb(a, b, c, d, e, f, h, i, j, k) {
        a = void 0 !== a ? a : [],
        g.call(this, a, void 0 !== b ? b : 301, c, d, e, f, void 0 !== h ? h : 1022, i, j, k),
        this.flipY = !1
    }
    function qb(a, b, c, d) {
        g.call(this, null),
        this.image = {
            data: a || null,
            width: b || 1,
            height: c || 1,
            depth: d || 1
        },
        this.minFilter = this.magFilter = 1003,
        this.wrapR = 1001,
        this.flipY = this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
    function rb(a, b, c, d) {
        g.call(this, null),
        this.image = {
            data: a || null,
            width: b || 1,
            height: c || 1,
            depth: d || 1
        },
        this.minFilter = this.magFilter = 1003,
        this.wrapR = 1001,
        this.flipY = this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
    function sb(a, b, c) {
        var d = a[0];
        if (0 >= d || d > 0)
            return a;
        var e = b * c
          , f = Si[e];
        if (void 0 === f && (f = new Float32Array(e),
        Si[e] = f),
        0 !== b)
            for (d.toArray(f, 0),
            d = 1,
            e = 0; d !== b; ++d)
                e += c,
                a[d].toArray(f, e);
        return f
    }
    function tb(a, b) {
        if (a.length !== b.length)
            return !1;
        for (var c = 0, d = a.length; d > c; c++)
            if (a[c] !== b[c])
                return !1;
        return !0
    }
    function ub(a, b) {
        for (var c = 0, d = b.length; d > c; c++)
            a[c] = b[c]
    }
    function vb(a, b) {
        var c = Ti[b];
        void 0 === c && (c = new Int32Array(b),
        Ti[b] = c);
        for (var d = 0; d !== b; ++d)
            c[d] = a.allocateTextureUnit();
        return c
    }
    function wb(a, b) {
        var c = this.cache;
        c[0] !== b && (a.uniform1f(this.addr, b),
        c[0] = b)
    }
    function xb(a, b) {
        var c = this.cache;
        void 0 !== b.x ? (c[0] !== b.x || c[1] !== b.y) && (a.uniform2f(this.addr, b.x, b.y),
        c[0] = b.x,
        c[1] = b.y) : tb(c, b) || (a.uniform2fv(this.addr, b),
        ub(c, b))
    }
    function yb(a, b) {
        var c = this.cache;
        void 0 !== b.x ? (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z) && (a.uniform3f(this.addr, b.x, b.y, b.z),
        c[0] = b.x,
        c[1] = b.y,
        c[2] = b.z) : void 0 !== b.r ? (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b) && (a.uniform3f(this.addr, b.r, b.g, b.b),
        c[0] = b.r,
        c[1] = b.g,
        c[2] = b.b) : tb(c, b) || (a.uniform3fv(this.addr, b),
        ub(c, b))
    }
    function zb(a, b) {
        var c = this.cache;
        void 0 !== b.x ? (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w) && (a.uniform4f(this.addr, b.x, b.y, b.z, b.w),
        c[0] = b.x,
        c[1] = b.y,
        c[2] = b.z,
        c[3] = b.w) : tb(c, b) || (a.uniform4fv(this.addr, b),
        ub(c, b))
    }
    function Ab(a, b) {
        var c = this.cache
          , d = b.elements;
        void 0 === d ? tb(c, b) || (a.uniformMatrix2fv(this.addr, !1, b),
        ub(c, b)) : tb(c, d) || (Wi.set(d),
        a.uniformMatrix2fv(this.addr, !1, Wi),
        ub(c, d))
    }
    function Bb(a, b) {
        var c = this.cache
          , d = b.elements;
        void 0 === d ? tb(c, b) || (a.uniformMatrix3fv(this.addr, !1, b),
        ub(c, b)) : tb(c, d) || (Vi.set(d),
        a.uniformMatrix3fv(this.addr, !1, Vi),
        ub(c, d))
    }
    function Cb(a, b) {
        var c = this.cache
          , d = b.elements;
        void 0 === d ? tb(c, b) || (a.uniformMatrix4fv(this.addr, !1, b),
        ub(c, b)) : tb(c, d) || (Ui.set(d),
        a.uniformMatrix4fv(this.addr, !1, Ui),
        ub(c, d))
    }
    function Db(a, b, c) {
        var d = this.cache
          , e = c.allocateTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e),
        d[0] = e),
        c.safeSetTexture2D(b || Oi, e)
    }
    function Eb(a, b, c) {
        var d = this.cache
          , e = c.allocateTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e),
        d[0] = e),
        c.setTexture2DArray(b || Pi, e)
    }
    function Fb(a, b, c) {
        var d = this.cache
          , e = c.allocateTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e),
        d[0] = e),
        c.setTexture3D(b || Qi, e)
    }
    function Gb(a, b, c) {
        var d = this.cache
          , e = c.allocateTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e),
        d[0] = e),
        c.safeSetTextureCube(b || Ri, e)
    }
    function Hb(a, b) {
        var c = this.cache;
        c[0] !== b && (a.uniform1i(this.addr, b),
        c[0] = b)
    }
    function Ib(a, b) {
        var c = this.cache;
        tb(c, b) || (a.uniform2iv(this.addr, b),
        ub(c, b))
    }
    function Jb(a, b) {
        var c = this.cache;
        tb(c, b) || (a.uniform3iv(this.addr, b),
        ub(c, b))
    }
    function Kb(a, b) {
        var c = this.cache;
        tb(c, b) || (a.uniform4iv(this.addr, b),
        ub(c, b))
    }
    function Lb(a) {
        switch (a) {
        case 5126:
            return wb;
        case 35664:
            return xb;
        case 35665:
            return yb;
        case 35666:
            return zb;
        case 35674:
            return Ab;
        case 35675:
            return Bb;
        case 35676:
            return Cb;
        case 35678:
        case 36198:
            return Db;
        case 35679:
            return Fb;
        case 35680:
            return Gb;
        case 36289:
            return Eb;
        case 5124:
        case 35670:
            return Hb;
        case 35667:
        case 35671:
            return Ib;
        case 35668:
        case 35672:
            return Jb;
        case 35669:
        case 35673:
            return Kb
        }
    }
    function Mb(a, b) {
        a.uniform1fv(this.addr, b)
    }
    function Nb(a, b) {
        a.uniform1iv(this.addr, b)
    }
    function Ob(a, b) {
        a.uniform2iv(this.addr, b)
    }
    function Pb(a, b) {
        a.uniform3iv(this.addr, b)
    }
    function Qb(a, b) {
        a.uniform4iv(this.addr, b)
    }
    function Rb(a, b) {
        b = sb(b, this.size, 2),
        a.uniform2fv(this.addr, b)
    }
    function Sb(a, b) {
        b = sb(b, this.size, 3),
        a.uniform3fv(this.addr, b)
    }
    function Tb(a, b) {
        b = sb(b, this.size, 4),
        a.uniform4fv(this.addr, b)
    }
    function Ub(a, b) {
        b = sb(b, this.size, 4),
        a.uniformMatrix2fv(this.addr, !1, b)
    }
    function Vb(a, b) {
        b = sb(b, this.size, 9),
        a.uniformMatrix3fv(this.addr, !1, b)
    }
    function Wb(a, b) {
        b = sb(b, this.size, 16),
        a.uniformMatrix4fv(this.addr, !1, b)
    }
    function Xb(a, b, c) {
        var d = b.length
          , e = vb(c, d);
        for (a.uniform1iv(this.addr, e),
        a = 0; a !== d; ++a)
            c.safeSetTexture2D(b[a] || Oi, e[a])
    }
    function Yb(a, b, c) {
        var d = b.length
          , e = vb(c, d);
        for (a.uniform1iv(this.addr, e),
        a = 0; a !== d; ++a)
            c.safeSetTextureCube(b[a] || Ri, e[a])
    }
    function Zb(a) {
        switch (a) {
        case 5126:
            return Mb;
        case 35664:
            return Rb;
        case 35665:
            return Sb;
        case 35666:
            return Tb;
        case 35674:
            return Ub;
        case 35675:
            return Vb;
        case 35676:
            return Wb;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
            return Xb;
        case 35680:
        case 36300:
        case 36308:
            return Yb;
        case 5124:
        case 35670:
            return Nb;
        case 35667:
        case 35671:
            return Ob;
        case 35668:
        case 35672:
            return Pb;
        case 35669:
        case 35673:
            return Qb
        }
    }
    function $b(a, b, c) {
        this.id = a,
        this.addr = c,
        this.cache = [],
        this.setValue = Lb(b.type)
    }
    function _b(a, b, c) {
        this.id = a,
        this.addr = c,
        this.cache = [],
        this.size = b.size,
        this.setValue = Zb(b.type)
    }
    function ac(a) {
        this.id = a,
        this.seq = [],
        this.map = {}
    }
    function bc(a, b) {
        this.seq = [],
        this.map = {};
        for (var c = a.getProgramParameter(b, 35718), d = 0; c > d; ++d) {
            var e = a.getActiveUniform(b, d)
              , f = a.getUniformLocation(b, e.name)
              , g = this
              , h = e.name
              , i = h.length;
            for (Xi.lastIndex = 0; ; ) {
                var j = Xi.exec(h)
                  , k = Xi.lastIndex
                  , l = j[1]
                  , m = j[3];
                if ("]" === j[2] && (l |= 0),
                void 0 === m || "[" === m && k + 2 === i) {
                    h = g,
                    e = void 0 === m ? new $b(l,e,f) : new _b(l,e,f),
                    h.seq.push(e),
                    h.map[e.id] = e;
                    break
                }
                m = g.map[l],
                void 0 === m && (m = new ac(l),
                l = g,
                g = m,
                l.seq.push(g),
                l.map[g.id] = g),
                g = m
            }
        }
    }
    function cc(a, b, c) {
        return b = a.createShader(b),
        a.shaderSource(b, c),
        a.compileShader(b),
        b
    }
    function dc(a) {
        switch (a) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            throw Error("unsupported encoding: " + a)
        }
    }
    function ec(a, b, c) {
        var d = a.getShaderParameter(b, 35713)
          , e = a.getShaderInfoLog(b).trim();
        if (d && "" === e)
            return "";
        for (a = a.getShaderSource(b).split("\n"),
        b = 0; b < a.length; b++)
            a[b] = b + 1 + ": " + a[b];
        return a = a.join("\n"),
        "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + e + a
    }
    function fc(a, b) {
        return b = dc(b),
        "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"
    }
    function gc(a, b) {
        return b = dc(b),
        "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"
    }
    function hc(a, b) {
        switch (b) {
        case 1:
            b = "Linear";
            break;
        case 2:
            b = "Reinhard";
            break;
        case 3:
            b = "Uncharted2";
            break;
        case 4:
            b = "OptimizedCineon";
            break;
        case 5:
            b = "ACESFilmic";
            break;
        default:
            throw Error("unsupported toneMapping: " + b)
        }
        return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
    }
    function ic(a, b, c) {
        return a = a || {},
        [a.derivatives || b.envMapCubeUV || b.bumpMap || b.tangentSpaceNormalMap || b.clearcoatNormalMap || b.flatShading || "physical" === b.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(kc).join("\n")
    }
    function jc(a) {
        var b, c = [];
        for (b in a) {
            var d = a[b];
            !1 !== d && c.push("#define " + b + " " + d)
        }
        return c.join("\n")
    }
    function kc(a) {
        return "" !== a
    }
    function lc(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows)
    }
    function mc(a, b) {
        return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection)
    }
    function nc(a, b) {
        if (a = Li[b],
        void 0 === a)
            throw Error("Can not resolve #include <" + b + ">");
        return a.replace(Zi, nc)
    }
    function oc(a, b, c, d) {
        for (a = "",
        b = parseInt(b); b < parseInt(c); b++)
            a += d.replace(/\[ i \]/g, "[ " + b + " ]").replace(/UNROLLED_LOOP_INDEX/g, b);
        return a
    }
    function pc(a) {
        var b = "precision " + a.precision + " float;\nprecision " + a.precision + " int;";
        return "highp" === a.precision ? b += "\n#define HIGH_PRECISION" : "mediump" === a.precision ? b += "\n#define MEDIUM_PRECISION" : "lowp" === a.precision && (b += "\n#define LOW_PRECISION"),
        b
    }
    function qc(a) {
        var b = "SHADOWMAP_TYPE_BASIC";
        return 1 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === a.shadowMapType && (b = "SHADOWMAP_TYPE_VSM"),
        b
    }
    function rc(a) {
        var b = "ENVMAP_TYPE_CUBE";
        if (a.envMap)
            switch (a.envMapMode) {
            case 301:
            case 302:
                b = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                b = "ENVMAP_TYPE_CUBE_UV";
                break;
            case 303:
            case 304:
                b = "ENVMAP_TYPE_EQUIREC";
                break;
            case 305:
                b = "ENVMAP_TYPE_SPHERE"
            }
        return b
    }
    function sc(a) {
        var b = "ENVMAP_MODE_REFLECTION";
        if (a.envMap)
            switch (a.envMapMode) {
            case 302:
            case 304:
                b = "ENVMAP_MODE_REFRACTION"
            }
        return b
    }
    function tc(a) {
        var b = "ENVMAP_BLENDING_NONE";
        if (a.envMap)
            switch (a.combine) {
            case 0:
                b = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                b = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                b = "ENVMAP_BLENDING_ADD"
            }
        return b
    }
    function uc(a, b, c, d, e, f) {
        var g = a.getContext()
          , h = d.defines
          , i = e.vertexShader
          , j = e.fragmentShader
          , k = qc(f)
          , l = rc(f)
          , m = sc(f)
          , n = tc(f)
          , o = 0 < a.gammaFactor ? a.gammaFactor : 1
          , p = f.isWebGL2 ? "" : ic(d.extensions, f, b)
          , q = jc(h)
          , r = g.createProgram()
          , s = f.numMultiviewViews;
        d.isRawShaderMaterial ? (h = [q].filter(kc).join("\n"),
        0 < h.length && (h += "\n"),
        b = [p, q].filter(kc).join("\n"),
        0 < b.length && (b += "\n")) : (h = [pc(f), "#define SHADER_NAME " + e.name, q, f.instancing ? "#define USE_INSTANCING" : "", f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + o, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + m : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.normalMap && f.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexTangents ? "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.vertexUvs ? "#define USE_UV" : "", f.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + k : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(kc).join("\n"),
        b = [p, pc(f), "#define SHADER_NAME " + e.name, q, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + o, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.matcap ? "#define USE_MATCAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + l : "", f.envMap ? "#define " + m : "", f.envMap ? "#define " + n : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.normalMap && f.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.sheen ? "#define USE_SHEEN" : "", f.vertexTangents ? "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.vertexUvs ? "#define USE_UV" : "", f.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + k : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (d.extensions && d.extensions.shaderTextureLOD || f.envMap) && (f.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? Li.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? hc("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.matcapEncoding || f.envMapEncoding || f.emissiveMapEncoding || f.lightMapEncoding ? Li.encodings_pars_fragment : "", f.mapEncoding ? fc("mapTexelToLinear", f.mapEncoding) : "", f.matcapEncoding ? fc("matcapTexelToLinear", f.matcapEncoding) : "", f.envMapEncoding ? fc("envMapTexelToLinear", f.envMapEncoding) : "", f.emissiveMapEncoding ? fc("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.lightMapEncoding ? fc("lightMapTexelToLinear", f.lightMapEncoding) : "", f.outputEncoding ? gc("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(kc).join("\n")),
        i = i.replace(Zi, nc),
        i = lc(i, f),
        i = mc(i, f),
        j = j.replace(Zi, nc),
        j = lc(j, f),
        j = mc(j, f),
        i = i.replace($i, oc),
        j = j.replace($i, oc),
        f.isWebGL2 && !d.isRawShaderMaterial && (k = !1,
        l = /^\s*#version\s+300\s+es\s*\n/,
        d.isShaderMaterial && null !== i.match(l) && null !== j.match(l) && (k = !0,
        i = i.replace(l, ""),
        j = j.replace(l, "")),
        h = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + h,
        b = ["#version 300 es\n\n#define varying in", k ? "" : "out highp vec4 pc_fragColor;", k ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b,
        s > 0 && (h = h.replace("#version 300 es\n", ["#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + s + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n")),
        h = h.replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + s + "];", "uniform mat4 projectionMatrices[" + s + "];", "uniform mat4 viewMatrices[" + s + "];", "uniform mat3 normalMatrices[" + s + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")),
        b = b.replace("#version 300 es\n", "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"),
        b = b.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + s + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))),
        j = b + j,
        i = cc(g, 35633, h + i),
        j = cc(g, 35632, j),
        g.attachShader(r, i),
        g.attachShader(r, j),
        void 0 !== d.index0AttributeName ? g.bindAttribLocation(r, 0, d.index0AttributeName) : !0 === f.morphTargets && g.bindAttribLocation(r, 0, "position"),
        g.linkProgram(r),
        a.debug.checkShaderErrors && (a = g.getProgramInfoLog(r).trim(),
        f = g.getShaderInfoLog(i).trim(),
        k = g.getShaderInfoLog(j).trim(),
        m = l = !0,
        !1 === g.getProgramParameter(r, 35714) ? (l = !1,
        n = ec(g, i, "vertex"),
        o = ec(g, j, "fragment"),
        console.error("THREE.WebGLProgram: shader error: ", g.getError(), "35715", g.getProgramParameter(r, 35715), "gl.getProgramInfoLog", a, n, o)) : "" !== a ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a) : ("" === f || "" === k) && (m = !1),
        m && (this.diagnostics = {
            runnable: l,
            material: d,
            programLog: a,
            vertexShader: {
                log: f,
                prefix: h
            },
            fragmentShader: {
                log: k,
                prefix: b
            }
        })),
        g.deleteShader(i),
        g.deleteShader(j);
        var t;
        this.getUniforms = function() {
            return void 0 === t && (t = new bc(g,r)),
            t
        }
        ;
        var u;
        return this.getAttributes = function() {
            if (void 0 === u) {
                for (var a = {}, b = g.getProgramParameter(r, 35721), c = 0; b > c; c++) {
                    var d = g.getActiveAttrib(r, c).name;
                    a[d] = g.getAttribLocation(r, d)
                }
                u = a
            }
            return u
        }
        ,
        this.destroy = function() {
            g.deleteProgram(r),
            this.program = void 0
        }
        ,
        this.name = e.name,
        this.id = Yi++,
        this.cacheKey = c,
        this.usedTimes = 1,
        this.program = r,
        this.vertexShader = i,
        this.fragmentShader = j,
        this.numMultiviewViews = s,
        this
    }
    function vc(a, b, c) {
        function d(a) {
            if (a)
                a.isTexture ? b = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                b = a.texture.encoding);
            else
                var b = 3e3;
            return b
        }
        var e = []
          , f = c.isWebGL2
          , g = c.logarithmicDepthBuffer
          , h = c.floatVertexTextures
          , i = c.precision
          , j = c.maxVertexUniforms
          , k = c.vertexTextures
          , l = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , m = "precision isWebGL2 supportsVertexTextures outputEncoding instancing numMultiviewViews map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
        this.getParameters = function(b, e, m, n, o, p, q) {
            var r = n.fog;
            n = b.isMeshStandardMaterial ? n.environment : null,
            n = b.envMap || n;
            var s = l[b.type];
            if (q.isSkinnedMesh) {
                var t = q.skeleton.bones;
                if (h)
                    t = 1024;
                else {
                    var u = Math.min(Math.floor((j - 20) / 4), t.length);
                    u < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + u + "."),
                    t = 0) : t = u
                }
            } else
                t = 0;
            return null !== b.precision && (i = c.getMaxPrecision(b.precision),
            i !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", i, "instead.")),
            u = a.getRenderTarget(),
            {
                isWebGL2: f,
                shaderID: s,
                precision: i,
                instancing: !0 === q.isInstancedMesh,
                supportsVertexTextures: k,
                numMultiviewViews: u && u.isWebGLMultiviewRenderTarget ? u.numViews : 0,
                outputEncoding: null !== u ? d(u.texture) : a.outputEncoding,
                map: !!b.map,
                mapEncoding: d(b.map),
                matcap: !!b.matcap,
                matcapEncoding: d(b.matcap),
                envMap: !!n,
                envMapMode: n && n.mapping,
                envMapEncoding: d(n),
                envMapCubeUV: !!n && (306 === n.mapping || 307 === n.mapping),
                lightMap: !!b.lightMap,
                lightMapEncoding: d(b.lightMap),
                aoMap: !!b.aoMap,
                emissiveMap: !!b.emissiveMap,
                emissiveMapEncoding: d(b.emissiveMap),
                bumpMap: !!b.bumpMap,
                normalMap: !!b.normalMap,
                objectSpaceNormalMap: 1 === b.normalMapType,
                tangentSpaceNormalMap: 0 === b.normalMapType,
                clearcoatNormalMap: !!b.clearcoatNormalMap,
                displacementMap: !!b.displacementMap,
                roughnessMap: !!b.roughnessMap,
                metalnessMap: !!b.metalnessMap,
                specularMap: !!b.specularMap,
                alphaMap: !!b.alphaMap,
                gradientMap: !!b.gradientMap,
                sheen: !!b.sheen,
                combine: b.combine,
                vertexTangents: b.normalMap && b.vertexTangents,
                vertexColors: b.vertexColors,
                vertexUvs: !!(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || b.displacementMap),
                uvsVertexOnly: !(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || !b.displacementMap),
                fog: !!r,
                useFog: b.fog,
                fogExp2: r && r.isFogExp2,
                flatShading: b.flatShading,
                sizeAttenuation: b.sizeAttenuation,
                logarithmicDepthBuffer: g,
                skinning: b.skinning && t > 0,
                maxBones: t,
                useVertexTexture: h,
                morphTargets: b.morphTargets,
                morphNormals: b.morphNormals,
                maxMorphTargets: a.maxMorphTargets,
                maxMorphNormals: a.maxMorphNormals,
                numDirLights: e.directional.length,
                numPointLights: e.point.length,
                numSpotLights: e.spot.length,
                numRectAreaLights: e.rectArea.length,
                numHemiLights: e.hemi.length,
                numDirLightShadows: e.directionalShadowMap.length,
                numPointLightShadows: e.pointShadowMap.length,
                numSpotLightShadows: e.spotShadowMap.length,
                numClippingPlanes: o,
                numClipIntersection: p,
                dithering: b.dithering,
                shadowMapEnabled: a.shadowMap.enabled && 0 < m.length,
                shadowMapType: a.shadowMap.type,
                toneMapping: b.toneMapped ? a.toneMapping : 0,
                physicallyCorrectLights: a.physicallyCorrectLights,
                premultipliedAlpha: b.premultipliedAlpha,
                alphaTest: b.alphaTest,
                doubleSided: 2 === b.side,
                flipSided: 1 === b.side,
                depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
            }
        }
        ,
        this.getProgramCacheKey = function(b, c) {
            var d = [];
            if (c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader),
            d.push(b.vertexShader)),
            void 0 !== b.defines)
                for (var e in b.defines)
                    d.push(e),
                    d.push(b.defines[e]);
            if (void 0 === b.isRawShaderMaterial) {
                for (e = 0; e < m.length; e++)
                    d.push(c[m[e]]);
                d.push(a.outputEncoding),
                d.push(a.gammaFactor)
            }
            return d.push(b.onBeforeCompile.toString()),
            d.join()
        }
        ,
        this.acquireProgram = function(c, d, f, g) {
            for (var h, i = 0, j = e.length; j > i; i++) {
                var k = e[i];
                if (k.cacheKey === g) {
                    h = k,
                    ++h.usedTimes;
                    break
                }
            }
            return void 0 === h && (h = new uc(a,b,g,c,d,f),
            e.push(h)),
            h
        }
        ,
        this.releaseProgram = function(a) {
            if (0 === --a.usedTimes) {
                var b = e.indexOf(a);
                e[b] = e[e.length - 1],
                e.pop(),
                a.destroy()
            }
        }
        ,
        this.programs = e
    }
    function wc() {
        var a = new WeakMap;
        return {
            get: function(b) {
                var c = a.get(b);
                return void 0 === c && (c = {},
                a.set(b, c)),
                c
            },
            remove: function(b) {
                a.delete(b)
            },
            update: function(b, c, d) {
                a.get(b)[c] = d
            },
            dispose: function() {
                a = new WeakMap
            }
        }
    }
    function xc(a, b) {
        return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
    }
    function yc(a, b) {
        return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
    }
    function zc() {
        function a(a, d, e, g, h, i) {
            var j = b[c];
            return void 0 === j ? (j = {
                id: a.id,
                object: a,
                geometry: d,
                material: e,
                program: e.program || f,
                groupOrder: g,
                renderOrder: a.renderOrder,
                z: h,
                group: i
            },
            b[c] = j) : (j.id = a.id,
            j.object = a,
            j.geometry = d,
            j.material = e,
            j.program = e.program || f,
            j.groupOrder = g,
            j.renderOrder = a.renderOrder,
            j.z = h,
            j.group = i),
            c++,
            j
        }
        var b = []
          , c = 0
          , d = []
          , e = []
          , f = {
            id: -1
        };
        return {
            opaque: d,
            transparent: e,
            init: function() {
                c = 0,
                d.length = 0,
                e.length = 0
            },
            push: function(b, c, f, g, h, i) {
                b = a(b, c, f, g, h, i),
                (!0 === f.transparent ? e : d).push(b)
            },
            unshift: function(b, c, f, g, h, i) {
                b = a(b, c, f, g, h, i),
                (!0 === f.transparent ? e : d).unshift(b)
            },
            sort: function(a, b) {
                1 < d.length && d.sort(a || xc),
                1 < e.length && e.sort(b || yc)
            }
        }
    }
    function Ac() {
        function a(c) {
            c = c.target,
            c.removeEventListener("dispose", a),
            b.delete(c)
        }
        var b = new WeakMap;
        return {
            get: function(c, d) {
                var e = b.get(c);
                if (void 0 === e) {
                    var f = new zc;
                    b.set(c, new WeakMap),
                    b.get(c).set(d, f),
                    c.addEventListener("dispose", a)
                } else
                    f = e.get(d),
                    void 0 === f && (f = new zc,
                    e.set(d, f));
                return f
            },
            dispose: function() {
                b = new WeakMap
            }
        }
    }
    function Bc() {
        var a = {};
        return {
            get: function(b) {
                if (void 0 !== a[b.id])
                    return a[b.id];
                switch (b.type) {
                case "DirectionalLight":
                    var d = {
                        direction: new e,
                        color: new v,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c
                    };
                    break;
                case "SpotLight":
                    d = {
                        position: new e,
                        direction: new e,
                        color: new v,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c
                    };
                    break;
                case "PointLight":
                    d = {
                        position: new e,
                        color: new v,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case "HemisphereLight":
                    d = {
                        direction: new e,
                        skyColor: new v,
                        groundColor: new v
                    };
                    break;
                case "RectAreaLight":
                    d = {
                        color: new v,
                        position: new e,
                        halfWidth: new e,
                        halfHeight: new e
                    }
                }
                return a[b.id] = d
            }
        }
    }
    function Cc(a, b) {
        return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0)
    }
    function Dc() {
        for (var a = new Bc, b = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        }, c = 0; 9 > c; c++)
            b.probe.push(new e);
        var d = new e
          , f = new k
          , g = new k;
        return {
            setup: function(c, e, h) {
                for (var i = 0, j = 0, k = 0, l = 0; 9 > l; l++)
                    b.probe[l].set(0, 0, 0);
                var m = e = 0
                  , n = 0
                  , o = 0
                  , p = 0
                  , q = 0
                  , r = 0
                  , s = 0;
                h = h.matrixWorldInverse,
                c.sort(Cc),
                l = 0;
                for (var t = c.length; t > l; l++) {
                    var u = c[l]
                      , v = u.color
                      , w = u.intensity
                      , x = u.distance
                      , y = u.shadow && u.shadow.map ? u.shadow.map.texture : null;
                    if (u.isAmbientLight)
                        i += v.r * w,
                        j += v.g * w,
                        k += v.b * w;
                    else if (u.isLightProbe)
                        for (y = 0; 9 > y; y++)
                            b.probe[y].addScaledVector(u.sh.coefficients[y], w);
                    else if (u.isDirectionalLight) {
                        var z = a.get(u);
                        z.color.copy(u.color).multiplyScalar(u.intensity),
                        z.direction.setFromMatrixPosition(u.matrixWorld),
                        d.setFromMatrixPosition(u.target.matrixWorld),
                        z.direction.sub(d),
                        z.direction.transformDirection(h),
                        (z.shadow = u.castShadow) && (w = u.shadow,
                        z.shadowBias = w.bias,
                        z.shadowRadius = w.radius,
                        z.shadowMapSize = w.mapSize,
                        b.directionalShadowMap[e] = y,
                        b.directionalShadowMatrix[e] = u.shadow.matrix,
                        q++),
                        b.directional[e] = z,
                        e++
                    } else
                        u.isSpotLight ? (z = a.get(u),
                        z.position.setFromMatrixPosition(u.matrixWorld),
                        z.position.applyMatrix4(h),
                        z.color.copy(v).multiplyScalar(w),
                        z.distance = x,
                        z.direction.setFromMatrixPosition(u.matrixWorld),
                        d.setFromMatrixPosition(u.target.matrixWorld),
                        z.direction.sub(d),
                        z.direction.transformDirection(h),
                        z.coneCos = Math.cos(u.angle),
                        z.penumbraCos = Math.cos(u.angle * (1 - u.penumbra)),
                        z.decay = u.decay,
                        (z.shadow = u.castShadow) && (w = u.shadow,
                        z.shadowBias = w.bias,
                        z.shadowRadius = w.radius,
                        z.shadowMapSize = w.mapSize,
                        b.spotShadowMap[n] = y,
                        b.spotShadowMatrix[n] = u.shadow.matrix,
                        s++),
                        b.spot[n] = z,
                        n++) : u.isRectAreaLight ? (z = a.get(u),
                        z.color.copy(v).multiplyScalar(w),
                        z.position.setFromMatrixPosition(u.matrixWorld),
                        z.position.applyMatrix4(h),
                        g.identity(),
                        f.copy(u.matrixWorld),
                        f.premultiply(h),
                        g.extractRotation(f),
                        z.halfWidth.set(.5 * u.width, 0, 0),
                        z.halfHeight.set(0, .5 * u.height, 0),
                        z.halfWidth.applyMatrix4(g),
                        z.halfHeight.applyMatrix4(g),
                        b.rectArea[o] = z,
                        o++) : u.isPointLight ? (z = a.get(u),
                        z.position.setFromMatrixPosition(u.matrixWorld),
                        z.position.applyMatrix4(h),
                        z.color.copy(u.color).multiplyScalar(u.intensity),
                        z.distance = u.distance,
                        z.decay = u.decay,
                        (z.shadow = u.castShadow) && (w = u.shadow,
                        z.shadowBias = w.bias,
                        z.shadowRadius = w.radius,
                        z.shadowMapSize = w.mapSize,
                        z.shadowCameraNear = w.camera.near,
                        z.shadowCameraFar = w.camera.far,
                        b.pointShadowMap[m] = y,
                        b.pointShadowMatrix[m] = u.shadow.matrix,
                        r++),
                        b.point[m] = z,
                        m++) : u.isHemisphereLight && (z = a.get(u),
                        z.direction.setFromMatrixPosition(u.matrixWorld),
                        z.direction.transformDirection(h),
                        z.direction.normalize(),
                        z.skyColor.copy(u.color).multiplyScalar(w),
                        z.groundColor.copy(u.groundColor).multiplyScalar(w),
                        b.hemi[p] = z,
                        p++)
                }
                b.ambient[0] = i,
                b.ambient[1] = j,
                b.ambient[2] = k,
                c = b.hash,
                (c.directionalLength !== e || c.pointLength !== m || c.spotLength !== n || c.rectAreaLength !== o || c.hemiLength !== p || c.numDirectionalShadows !== q || c.numPointShadows !== r || c.numSpotShadows !== s) && (b.directional.length = e,
                b.spot.length = n,
                b.rectArea.length = o,
                b.point.length = m,
                b.hemi.length = p,
                b.directionalShadowMap.length = q,
                b.pointShadowMap.length = r,
                b.spotShadowMap.length = s,
                b.directionalShadowMatrix.length = q,
                b.pointShadowMatrix.length = r,
                b.spotShadowMatrix.length = s,
                c.directionalLength = e,
                c.pointLength = m,
                c.spotLength = n,
                c.rectAreaLength = o,
                c.hemiLength = p,
                c.numDirectionalShadows = q,
                c.numPointShadows = r,
                c.numSpotShadows = s,
                b.version = _i++)
            },
            state: b
        }
    }
    function Ec() {
        var a = new Dc
          , b = []
          , c = [];
        return {
            init: function() {
                b.length = 0,
                c.length = 0
            },
            state: {
                lightsArray: b,
                shadowsArray: c,
                lights: a
            },
            setupLights: function(d) {
                a.setup(b, c, d)
            },
            pushLight: function(a) {
                b.push(a)
            },
            pushShadow: function(a) {
                c.push(a)
            }
        }
    }
    function Fc() {
        function a(c) {
            c = c.target,
            c.removeEventListener("dispose", a),
            b.delete(c)
        }
        var b = new WeakMap;
        return {
            get: function(c, d) {
                if (!1 === b.has(c)) {
                    var e = new Ec;
                    b.set(c, new WeakMap),
                    b.get(c).set(d, e),
                    c.addEventListener("dispose", a)
                } else
                    !1 === b.get(c).has(d) ? (e = new Ec,
                    b.get(c).set(d, e)) : e = b.get(c).get(d);
                return e
            },
            dispose: function() {
                b = new WeakMap
            }
        }
    }
    function Gc(a) {
        A.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues(a)
    }
    function Hc(a) {
        A.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new e,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues(a)
    }
    function Ic(a, b, d) {
        function e(a, b, c) {
            c = a << 0 | b << 1 | c << 2;
            var d = o[c];
            return void 0 === d && (d = new Gc({
                depthPacking: 3201,
                morphTargets: a,
                skinning: b
            }),
            o[c] = d),
            d
        }
        function f(a, b, c) {
            c = a << 0 | b << 1 | c << 2;
            var d = p[c];
            return void 0 === d && (d = new Hc({
                morphTargets: a,
                skinning: b
            }),
            p[c] = d),
            d
        }
        function g(b, c, d, g, h, i) {
            var j = b.geometry
              , k = e
              , l = b.customDepthMaterial;
            return !0 === d.isPointLight && (k = f,
            l = b.customDistanceMaterial),
            void 0 === l ? (l = !1,
            !0 === c.morphTargets && (!0 === j.isBufferGeometry ? l = j.morphAttributes && j.morphAttributes.position && 0 < j.morphAttributes.position.length : !0 === j.isGeometry && (l = j.morphTargets && 0 < j.morphTargets.length)),
            j = !1,
            !0 === b.isSkinnedMesh && (!0 === c.skinning ? j = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b)),
            b = k(l, j, !0 === b.isInstancedMesh)) : b = l,
            a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (l = b.uuid,
            k = c.uuid,
            j = q[l],
            void 0 === j && (j = {},
            q[l] = j),
            l = j[k],
            void 0 === l && (l = b.clone(),
            j[k] = l),
            b = l),
            b.visible = c.visible,
            b.wireframe = c.wireframe,
            b.side = 3 === i ? null !== c.shadowSide ? c.shadowSide : c.side : null !== c.shadowSide ? c.shadowSide : r[c.side],
            b.clipShadows = c.clipShadows,
            b.clippingPlanes = c.clippingPlanes,
            b.clipIntersection = c.clipIntersection,
            b.wireframeLinewidth = c.wireframeLinewidth,
            b.linewidth = c.linewidth,
            !0 === d.isPointLight && !0 === b.isMeshDistanceMaterial && (b.referencePosition.setFromMatrixPosition(d.matrixWorld),
            b.nearDistance = g,
            b.farDistance = h),
            b
        }
        function j(c, d, e, f, h) {
            if (!1 !== c.visible) {
                if (c.layers.test(d.layers) && (c.isMesh || c.isLine || c.isPoints) && (c.castShadow || c.receiveShadow && 3 === h) && (!c.frustumCulled || k.intersectsObject(c))) {
                    c.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, c.matrixWorld);
                    var i = b.update(c)
                      , l = c.material;
                    if (Array.isArray(l))
                        for (var m = i.groups, n = 0, o = m.length; o > n; n++) {
                            var p = m[n]
                              , q = l[p.materialIndex];
                            q && q.visible && (q = g(c, q, f, e.near, e.far, h),
                            a.renderBufferDirect(e, null, i, q, c, p))
                        }
                    else
                        l.visible && (q = g(c, l, f, e.near, e.far, h),
                        a.renderBufferDirect(e, null, i, q, c, null))
                }
                for (c = c.children,
                i = 0,
                l = c.length; l > i; i++)
                    j(c[i], d, e, f, h)
            }
        }
        var k = new _
          , l = new c
          , m = new c
          , n = new h
          , o = []
          , p = []
          , q = {}
          , r = {
            0: 1,
            1: 0,
            2: 2
        }
          , s = new V({
            defines: {
                SAMPLE_RATE: .25,
                HALF_SAMPLE_RATE: .125
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new c
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        })
          , t = s.clone();
        t.defines.HORIZONAL_PASS = 1;
        var u = new O;
        u.setAttribute("position", new C(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        var v = new P(u,s)
          , w = this;
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(c, e, f) {
            if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate) && 0 !== c.length) {
                var g = a.getRenderTarget()
                  , h = a.getActiveCubeFace()
                  , o = a.getActiveMipmapLevel()
                  , p = a.state;
                p.setBlending(0),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                for (var q = 0, r = c.length; r > q; q++) {
                    var u = c[q]
                      , x = u.shadow;
                    if (void 0 === x)
                        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                    else {
                        l.copy(x.mapSize);
                        var y = x.getFrameExtents();
                        l.multiply(y),
                        m.copy(x.mapSize),
                        (l.x > d || l.y > d) && (console.warn("THREE.WebGLShadowMap:", u, "has shadow exceeding max texture size, reducing"),
                        l.x > d && (m.x = Math.floor(d / y.x),
                        l.x = m.x * y.x,
                        x.mapSize.x = m.x),
                        l.y > d && (m.y = Math.floor(d / y.y),
                        l.y = m.y * y.y,
                        x.mapSize.y = m.y)),
                        null !== x.map || x.isPointLightShadow || 3 !== this.type || (y = {
                            minFilter: 1006,
                            magFilter: 1006,
                            format: 1023
                        },
                        x.map = new i(l.x,l.y,y),
                        x.map.texture.name = u.name + ".shadowMap",
                        x.mapPass = new i(l.x,l.y,y),
                        x.camera.updateProjectionMatrix()),
                        null === x.map && (y = {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        },
                        x.map = new i(l.x,l.y,y),
                        x.map.texture.name = u.name + ".shadowMap",
                        x.camera.updateProjectionMatrix()),
                        a.setRenderTarget(x.map),
                        a.clear(),
                        y = x.getViewportCount();
                        for (var z = 0; y > z; z++) {
                            var A = x.getViewport(z);
                            n.set(m.x * A.x, m.y * A.y, m.x * A.z, m.y * A.w),
                            p.viewport(n),
                            x.updateMatrices(u, z),
                            k = x.getFrustum(),
                            j(e, f, x.camera, u, this.type)
                        }
                        x.isPointLightShadow || 3 !== this.type || (u = x,
                        x = f,
                        y = b.update(v),
                        s.uniforms.shadow_pass.value = u.map.texture,
                        s.uniforms.resolution.value = u.mapSize,
                        s.uniforms.radius.value = u.radius,
                        a.setRenderTarget(u.mapPass),
                        a.clear(),
                        a.renderBufferDirect(x, null, y, s, v, null),
                        t.uniforms.shadow_pass.value = u.mapPass.texture,
                        t.uniforms.resolution.value = u.mapSize,
                        t.uniforms.radius.value = u.radius,
                        a.setRenderTarget(u.map),
                        a.clear(),
                        a.renderBufferDirect(x, null, y, t, v, null))
                    }
                }
                w.needsUpdate = !1,
                a.setRenderTarget(g, h, o)
            }
        }
    }
    function Jc(a, b, c) {
        function d(b, c, d) {
            var e = new Uint8Array(4)
              , f = a.createTexture();
            for (a.bindTexture(b, f),
            a.texParameteri(b, 10241, 9728),
            a.texParameteri(b, 10240, 9728),
            b = 0; d > b; b++)
                a.texImage2D(c + b, 0, 6408, 1, 1, 0, 6408, 5121, e);
            return f
        }
        function e(c, d) {
            r[c] = 1,
            0 === s[c] && (a.enableVertexAttribArray(c),
            s[c] = 1),
            t[c] !== d && ((n ? a : b.get("ANGLE_instanced_arrays"))[n ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c, d),
            t[c] = d)
        }
        function f(b) {
            !0 !== u[b] && (a.enable(b),
            u[b] = !0)
        }
        function g(b) {
            !1 !== u[b] && (a.disable(b),
            u[b] = !1)
        }
        function i(b, c, d, e, h, i, j, k) {
            if (0 === b)
                w && (g(3042),
                w = !1);
            else if (w || (f(3042),
            w = !0),
            5 !== b) {
                if (b !== x || k !== E) {
                    if ((100 !== y || 100 !== B) && (a.blendEquation(32774),
                    B = y = 100),
                    k)
                        switch (b) {
                        case 1:
                            a.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            a.blendFunc(1, 1);
                            break;
                        case 3:
                            a.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            a.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", b)
                        }
                    else
                        switch (b) {
                        case 1:
                            a.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            a.blendFunc(770, 1);
                            break;
                        case 3:
                            a.blendFunc(0, 769);
                            break;
                        case 4:
                            a.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", b)
                        }
                    D = C = A = z = null,
                    x = b,
                    E = k
                }
            } else
                h = h || c,
                i = i || d,
                j = j || e,
                (c !== y || h !== B) && (a.blendEquationSeparate(R[c], R[h]),
                y = c,
                B = h),
                (d !== z || e !== A || i !== C || j !== D) && (a.blendFuncSeparate(S[d], S[e], S[i], S[j]),
                z = d,
                A = e,
                C = i,
                D = j),
                x = b,
                E = null
        }
        function j(b) {
            F !== b && (b ? a.frontFace(2304) : a.frontFace(2305),
            F = b)
        }
        function k(b) {
            0 !== b ? (f(2884),
            b !== G && (1 === b ? a.cullFace(1029) : 2 === b ? a.cullFace(1028) : a.cullFace(1032))) : g(2884),
            G = b
        }
        function l(b, c, d) {
            b ? (f(32823),
            (I !== c || J !== d) && (a.polygonOffset(c, d),
            I = c,
            J = d)) : g(32823)
        }
        function m(b) {
            void 0 === b && (b = 33984 + K - 1),
            M !== b && (a.activeTexture(b),
            M = b)
        }
        var n = c.isWebGL2
          , o = new function() {
            var b = !1
              , c = new h
              , d = null
              , e = new h(0,0,0,0);
            return {
                setMask: function(c) {
                    d === c || b || (a.colorMask(c, c, c, c),
                    d = c)
                },
                setLocked: function(a) {
                    b = a
                },
                setClear: function(b, d, f, g, h) {
                    !0 === h && (b *= g,
                    d *= g,
                    f *= g),
                    c.set(b, d, f, g),
                    !1 === e.equals(c) && (a.clearColor(b, d, f, g),
                    e.copy(c))
                },
                reset: function() {
                    b = !1,
                    d = null,
                    e.set(-1, 0, 0, 0)
                }
            }
        }
          , p = new function() {
            var b = !1
              , c = null
              , d = null
              , e = null;
            return {
                setTest: function(a) {
                    a ? f(2929) : g(2929)
                },
                setMask: function(d) {
                    c === d || b || (a.depthMask(d),
                    c = d)
                },
                setFunc: function(b) {
                    if (d !== b) {
                        if (b)
                            switch (b) {
                            case 0:
                                a.depthFunc(512);
                                break;
                            case 1:
                                a.depthFunc(519);
                                break;
                            case 2:
                                a.depthFunc(513);
                                break;
                            case 3:
                                a.depthFunc(515);
                                break;
                            case 4:
                                a.depthFunc(514);
                                break;
                            case 5:
                                a.depthFunc(518);
                                break;
                            case 6:
                                a.depthFunc(516);
                                break;
                            case 7:
                                a.depthFunc(517);
                                break;
                            default:
                                a.depthFunc(515)
                            }
                        else
                            a.depthFunc(515);
                        d = b
                    }
                },
                setLocked: function(a) {
                    b = a
                },
                setClear: function(b) {
                    e !== b && (a.clearDepth(b),
                    e = b)
                },
                reset: function() {
                    b = !1,
                    e = d = c = null
                }
            }
        }
          , q = new function() {
            var b = !1
              , c = null
              , d = null
              , e = null
              , h = null
              , i = null
              , j = null
              , k = null
              , l = null;
            return {
                setTest: function(a) {
                    b || (a ? f(2960) : g(2960))
                },
                setMask: function(d) {
                    c === d || b || (a.stencilMask(d),
                    c = d)
                },
                setFunc: function(b, c, f) {
                    (d !== b || e !== c || h !== f) && (a.stencilFunc(b, c, f),
                    d = b,
                    e = c,
                    h = f)
                },
                setOp: function(b, c, d) {
                    (i !== b || j !== c || k !== d) && (a.stencilOp(b, c, d),
                    i = b,
                    j = c,
                    k = d)
                },
                setLocked: function(a) {
                    b = a
                },
                setClear: function(b) {
                    l !== b && (a.clearStencil(b),
                    l = b)
                },
                reset: function() {
                    b = !1,
                    l = k = j = i = h = e = d = c = null
                }
            }
        }
        ;
        c = a.getParameter(34921);
        var r = new Uint8Array(c)
          , s = new Uint8Array(c)
          , t = new Uint8Array(c)
          , u = {}
          , v = null
          , w = null
          , x = null
          , y = null
          , z = null
          , A = null
          , B = null
          , C = null
          , D = null
          , E = !1
          , F = null
          , G = null
          , H = null
          , I = null
          , J = null
          , K = a.getParameter(35661)
          , L = !1;
        c = 0,
        c = a.getParameter(7938),
        -1 !== c.indexOf("WebGL") ? (c = parseFloat(/^WebGL ([0-9])/.exec(c)[1]),
        L = c >= 1) : -1 !== c.indexOf("OpenGL ES") && (c = parseFloat(/^OpenGL ES ([0-9])/.exec(c)[1]),
        L = c >= 2);
        var M = null
          , N = {}
          , O = new h
          , P = new h
          , Q = {};
        Q[3553] = d(3553, 3553, 1),
        Q[34067] = d(34067, 34069, 6),
        o.setClear(0, 0, 0, 1),
        p.setClear(1),
        q.setClear(0),
        f(2929),
        p.setFunc(3),
        j(!1),
        k(1),
        f(2884),
        i(0);
        var R = {
            100: 32774,
            101: 32778,
            102: 32779
        };
        n ? (R[103] = 32775,
        R[104] = 32776) : (c = b.get("EXT_blend_minmax"),
        null !== c && (R[103] = c.MIN_EXT,
        R[104] = c.MAX_EXT));
        var S = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };
        return {
            buffers: {
                color: o,
                depth: p,
                stencil: q
            },
            initAttributes: function() {
                for (var a = 0, b = r.length; b > a; a++)
                    r[a] = 0
            },
            enableAttribute: function(a) {
                e(a, 0)
            },
            enableAttributeAndDivisor: e,
            disableUnusedAttributes: function() {
                for (var b = 0, c = s.length; b !== c; ++b)
                    s[b] !== r[b] && (a.disableVertexAttribArray(b),
                    s[b] = 0)
            },
            enable: f,
            disable: g,
            useProgram: function(b) {
                return v !== b ? (a.useProgram(b),
                v = b,
                !0) : !1
            },
            setBlending: i,
            setMaterial: function(a, b) {
                2 === a.side ? g(2884) : f(2884);
                var c = 1 === a.side;
                b && (c = !c),
                j(c),
                1 === a.blending && !1 === a.transparent ? i(0) : i(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha),
                p.setFunc(a.depthFunc),
                p.setTest(a.depthTest),
                p.setMask(a.depthWrite),
                o.setMask(a.colorWrite),
                b = a.stencilWrite,
                q.setTest(b),
                b && (q.setMask(a.stencilWriteMask),
                q.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask),
                q.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass)),
                l(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
            },
            setFlipSided: j,
            setCullFace: k,
            setLineWidth: function(b) {
                b !== H && (L && a.lineWidth(b),
                H = b)
            },
            setPolygonOffset: l,
            setScissorTest: function(a) {
                a ? f(3089) : g(3089)
            },
            activeTexture: m,
            bindTexture: function(b, c) {
                null === M && m();
                var d = N[M];
                void 0 === d && (d = {
                    type: void 0,
                    texture: void 0
                },
                N[M] = d),
                (d.type !== b || d.texture !== c) && (a.bindTexture(b, c || Q[b]),
                d.type = b,
                d.texture = c)
            },
            unbindTexture: function() {
                var b = N[M];
                void 0 !== b && void 0 !== b.type && (a.bindTexture(b.type, null),
                b.type = void 0,
                b.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    a.compressedTexImage2D.apply(a, arguments)
                } catch (b) {
                    console.error("THREE.WebGLState:", b)
                }
            },
            texImage2D: function() {
                try {
                    a.texImage2D.apply(a, arguments)
                } catch (b) {
                    console.error("THREE.WebGLState:", b)
                }
            },
            texImage3D: function() {
                try {
                    a.texImage3D.apply(a, arguments)
                } catch (b) {
                    console.error("THREE.WebGLState:", b)
                }
            },
            scissor: function(b) {
                !1 === O.equals(b) && (a.scissor(b.x, b.y, b.z, b.w),
                O.copy(b))
            },
            viewport: function(b) {
                !1 === P.equals(b) && (a.viewport(b.x, b.y, b.z, b.w),
                P.copy(b))
            },
            reset: function() {
                for (var b = 0; b < s.length; b++)
                    1 === s[b] && (a.disableVertexAttribArray(b),
                    s[b] = 0);
                u = {},
                M = null,
                N = {},
                G = F = x = v = null,
                o.reset(),
                p.reset(),
                q.reset()
            }
        }
    }
    function Kc(a, b, c, d, e, f, g) {
        function h(a, b) {
            return G ? new OffscreenCanvas(a,b) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function i(a, b, c, d) {
            var e = 1;
            if ((a.width > d || a.height > d) && (e = d / Math.max(a.width, a.height)),
            1 > e || !0 === b) {
                if ("undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && a instanceof ImageBitmap)
                    return d = b ? Sg.floorPowerOfTwo : Math.floor,
                    b = d(e * a.width),
                    e = d(e * a.height),
                    void 0 === z && (z = h(b, e)),
                    c = c ? h(b, e) : z,
                    c.width = b,
                    c.height = e,
                    c.getContext("2d").drawImage(a, 0, 0, b, e),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + e + ")."),
                    c;
                "data"in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ").")
            }
            return a
        }
        function j(a) {
            return Sg.isPowerOfTwo(a.width) && Sg.isPowerOfTwo(a.height)
        }
        function k(a, b) {
            return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter
        }
        function l(b, c, e, f) {
            a.generateMipmap(b),
            d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E
        }
        function m(c, d, e) {
            if (!1 === A)
                return d;
            if (null !== c) {
                if (void 0 !== a[c])
                    return a[c];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + c + "'")
            }
            return c = d,
            6403 === d && (5126 === e && (c = 33326),
            5131 === e && (c = 33325),
            5121 === e && (c = 33321)),
            6407 === d && (5126 === e && (c = 34837),
            5131 === e && (c = 34843),
            5121 === e && (c = 32849)),
            6408 === d && (5126 === e && (c = 34836),
            5131 === e && (c = 34842),
            5121 === e && (c = 32856)),
            33325 === c || 33326 === c || 34842 === c || 34836 === c ? b.get("EXT_color_buffer_float") : (34843 === c || 34837 === c) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."),
            c
        }
        function n(a) {
            return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729
        }
        function o(b) {
            b = b.target,
            b.removeEventListener("dispose", o);
            var c = d.get(b);
            void 0 !== c.__webglInit && (a.deleteTexture(c.__webglTexture),
            d.remove(b)),
            b.isVideoTexture && F.delete(b),
            g.memory.textures--
        }
        function p(b) {
            b = b.target,
            b.removeEventListener("dispose", p);
            var c = d.get(b)
              , e = d.get(b.texture);
            if (b) {
                if (void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture),
                b.depthTexture && b.depthTexture.dispose(),
                b.isWebGLRenderTargetCube)
                    for (e = 0; 6 > e; e++)
                        a.deleteFramebuffer(c.__webglFramebuffer[e]),
                        c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
                else
                    a.deleteFramebuffer(c.__webglFramebuffer),
                    c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                if (b.isWebGLMultiviewRenderTarget) {
                    a.deleteTexture(c.__webglColorTexture),
                    a.deleteTexture(c.__webglDepthStencilTexture),
                    g.memory.textures -= 2,
                    e = 0;
                    for (var f = c.__webglViewFramebuffers.length; f > e; e++)
                        a.deleteFramebuffer(c.__webglViewFramebuffers[e])
                }
                d.remove(b.texture),
                d.remove(b)
            }
            g.memory.textures--
        }
        function q(a, b) {
            var e = d.get(a);
            if (a.isVideoTexture) {
                var f = g.render.frame;
                F.get(a) !== f && (F.set(a, f),
                a.update())
            }
            if (0 < a.version && e.__version !== a.version)
                if (f = a.image,
                void 0 === f)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== f.complete)
                        return v(e, a, b),
                        void 0;
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            c.activeTexture(33984 + b),
            c.bindTexture(3553, e.__webglTexture)
        }
        function r(b, e) {
            if (6 === b.image.length) {
                var g = d.get(b);
                if (0 < b.version && g.__version !== b.version) {
                    u(g, b),
                    c.activeTexture(33984 + e),
                    c.bindTexture(34067, g.__webglTexture),
                    a.pixelStorei(37440, b.flipY);
                    var h = b && b.isCompressedTexture;
                    e = b.image[0] && b.image[0].isDataTexture;
                    for (var n = [], o = 0; 6 > o; o++)
                        n[o] = h || e ? e ? b.image[o].image : b.image[o] : i(b.image[o], !1, !0, C);
                    var p = n[0]
                      , q = j(p) || A
                      , r = f.convert(b.format)
                      , s = f.convert(b.type)
                      , v = m(b.internalFormat, r, s);
                    if (t(34067, b, q),
                    h) {
                        for (o = 0; 6 > o; o++) {
                            var w = n[o].mipmaps;
                            for (h = 0; h < w.length; h++) {
                                var x = w[h];
                                1023 !== b.format && 1022 !== b.format ? null !== r ? c.compressedTexImage2D(34069 + o, h, v, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(34069 + o, h, v, x.width, x.height, 0, r, s, x.data)
                            }
                        }
                        g.__maxMipLevel = w.length - 1
                    } else {
                        for (w = b.mipmaps,
                        o = 0; 6 > o; o++)
                            if (e)
                                for (c.texImage2D(34069 + o, 0, v, n[o].width, n[o].height, 0, r, s, n[o].data),
                                h = 0; h < w.length; h++)
                                    x = w[h],
                                    x = x.image[o].image,
                                    c.texImage2D(34069 + o, h + 1, v, x.width, x.height, 0, r, s, x.data);
                            else
                                for (c.texImage2D(34069 + o, 0, v, r, s, n[o]),
                                h = 0; h < w.length; h++)
                                    x = w[h],
                                    c.texImage2D(34069 + o, h + 1, v, r, s, x.image[o]);
                        g.__maxMipLevel = w.length
                    }
                    k(b, q) && l(34067, b, p.width, p.height),
                    g.__version = b.version,
                    b.onUpdate && b.onUpdate(b)
                } else
                    c.activeTexture(33984 + e),
                    c.bindTexture(34067, g.__webglTexture)
            }
        }
        function s(a, b) {
            c.activeTexture(33984 + b),
            c.bindTexture(34067, d.get(a).__webglTexture)
        }
        function t(c, f, g) {
            g ? (a.texParameteri(c, 10242, J[f.wrapS]),
            a.texParameteri(c, 10243, J[f.wrapT]),
            32879 !== c && 35866 !== c || a.texParameteri(c, 32882, J[f.wrapR]),
            a.texParameteri(c, 10240, K[f.magFilter]),
            a.texParameteri(c, 10241, K[f.minFilter])) : (a.texParameteri(c, 10242, 33071),
            a.texParameteri(c, 10243, 33071),
            32879 !== c && 35866 !== c || a.texParameteri(c, 32882, 33071),
            1001 === f.wrapS && 1001 === f.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            a.texParameteri(c, 10240, n(f.magFilter)),
            a.texParameteri(c, 10241, n(f.minFilter)),
            1003 !== f.minFilter && 1006 !== f.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !(g = b.get("EXT_texture_filter_anisotropic")) || 1015 === f.type && null === b.get("OES_texture_float_linear") || 1016 === f.type && null === (A || b.get("OES_texture_half_float_linear")) || !(1 < f.anisotropy || d.get(f).__currentAnisotropy) || (a.texParameterf(c, g.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(f.anisotropy, e.getMaxAnisotropy())),
            d.get(f).__currentAnisotropy = f.anisotropy)
        }
        function u(b, c) {
            void 0 === b.__webglInit && (b.__webglInit = !0,
            c.addEventListener("dispose", o),
            b.__webglTexture = a.createTexture(),
            g.memory.textures++)
        }
        function v(b, d, e) {
            var g = 3553;
            d.isDataTexture2DArray && (g = 35866),
            d.isDataTexture3D && (g = 32879),
            u(b, d),
            c.activeTexture(33984 + e),
            c.bindTexture(g, b.__webglTexture),
            a.pixelStorei(37440, d.flipY),
            a.pixelStorei(37441, d.premultiplyAlpha),
            a.pixelStorei(3317, d.unpackAlignment),
            e = A ? !1 : 1001 !== d.wrapS || 1001 !== d.wrapT || 1003 !== d.minFilter && 1006 !== d.minFilter,
            e = e && !1 === j(d.image),
            e = i(d.image, e, !1, D);
            var h = j(e) || A
              , n = f.convert(d.format)
              , o = f.convert(d.type)
              , p = m(d.internalFormat, n, o);
            t(g, d, h);
            var q = d.mipmaps;
            if (d.isDepthTexture) {
                if (p = 6402,
                1015 === d.type) {
                    if (!1 === A)
                        throw Error("Float Depth Texture only supported in WebGL2.0");
                    p = 36012
                } else
                    A && (p = 33189);
                1026 === d.format && 6402 === p && 1012 !== d.type && 1014 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                d.type = 1012,
                o = f.convert(d.type)),
                1027 === d.format && (p = 34041,
                1020 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                d.type = 1020,
                o = f.convert(d.type))),
                c.texImage2D(3553, 0, p, e.width, e.height, 0, n, o, null)
            } else if (d.isDataTexture)
                if (0 < q.length && h) {
                    for (var r = 0, s = q.length; s > r; r++) {
                        var v = q[r];
                        c.texImage2D(3553, r, p, v.width, v.height, 0, n, o, v.data)
                    }
                    d.generateMipmaps = !1,
                    b.__maxMipLevel = q.length - 1
                } else
                    c.texImage2D(3553, 0, p, e.width, e.height, 0, n, o, e.data),
                    b.__maxMipLevel = 0;
            else if (d.isCompressedTexture) {
                for (r = 0,
                s = q.length; s > r; r++)
                    v = q[r],
                    1023 !== d.format && 1022 !== d.format ? null !== n ? c.compressedTexImage2D(3553, r, p, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(3553, r, p, v.width, v.height, 0, n, o, v.data);
                b.__maxMipLevel = q.length - 1
            } else if (d.isDataTexture2DArray)
                c.texImage3D(35866, 0, p, e.width, e.height, e.depth, 0, n, o, e.data),
                b.__maxMipLevel = 0;
            else if (d.isDataTexture3D)
                c.texImage3D(32879, 0, p, e.width, e.height, e.depth, 0, n, o, e.data),
                b.__maxMipLevel = 0;
            else if (0 < q.length && h) {
                for (r = 0,
                s = q.length; s > r; r++)
                    v = q[r],
                    c.texImage2D(3553, r, p, n, o, v);
                d.generateMipmaps = !1,
                b.__maxMipLevel = q.length - 1
            } else
                c.texImage2D(3553, 0, p, n, o, e),
                b.__maxMipLevel = 0;
            k(d, h) && l(g, d, e.width, e.height),
            b.__version = d.version,
            d.onUpdate && d.onUpdate(d)
        }
        function w(b, e, g, h) {
            var i = f.convert(e.texture.format)
              , j = f.convert(e.texture.type)
              , k = m(e.texture.internalFormat, i, j);
            c.texImage2D(h, 0, k, e.width, e.height, 0, i, j, null),
            a.bindFramebuffer(36160, b),
            a.framebufferTexture2D(36160, g, h, d.get(e.texture).__webglTexture, 0),
            a.bindFramebuffer(36160, null)
        }
        function x(b, c, d) {
            if (a.bindRenderbuffer(36161, b),
            c.depthBuffer && !c.stencilBuffer)
                d ? (d = y(c),
                a.renderbufferStorageMultisample(36161, d, 33189, c.width, c.height)) : a.renderbufferStorage(36161, 33189, c.width, c.height),
                a.framebufferRenderbuffer(36160, 36096, 36161, b);
            else if (c.depthBuffer && c.stencilBuffer)
                d ? (d = y(c),
                a.renderbufferStorageMultisample(36161, d, 35056, c.width, c.height)) : a.renderbufferStorage(36161, 34041, c.width, c.height),
                a.framebufferRenderbuffer(36160, 33306, 36161, b);
            else {
                b = f.convert(c.texture.format);
                var e = f.convert(c.texture.type);
                b = m(c.texture.internalFormat, b, e),
                d ? (d = y(c),
                a.renderbufferStorageMultisample(36161, d, b, c.width, c.height)) : a.renderbufferStorage(36161, b, c.width, c.height)
            }
            a.bindRenderbuffer(36161, null)
        }
        function y(a) {
            return A && a.isWebGLMultisampleRenderTarget ? Math.min(E, a.samples) : 0
        }
        var z, A = e.isWebGL2, B = e.maxTextures, C = e.maxCubemapSize, D = e.maxTextureSize, E = e.maxSamples, F = new WeakMap, G = !1;
        try {
            G = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (H) {}
        var I = 0
          , J = {
            1e3: 10497,
            1001: 33071,
            1002: 33648
        }
          , K = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987
        }
          , L = !1
          , M = !1;
        this.allocateTextureUnit = function() {
            var a = I;
            return a >= B && console.warn("THREE.WebGLTextures: Trying to use " + a + " texture units while this GPU supports only " + B),
            I += 1,
            a
        }
        ,
        this.resetTextureUnits = function() {
            I = 0
        }
        ,
        this.setTexture2D = q,
        this.setTexture2DArray = function(a, b) {
            var e = d.get(a);
            0 < a.version && e.__version !== a.version ? v(e, a, b) : (c.activeTexture(33984 + b),
            c.bindTexture(35866, e.__webglTexture))
        }
        ,
        this.setTexture3D = function(a, b) {
            var e = d.get(a);
            0 < a.version && e.__version !== a.version ? v(e, a, b) : (c.activeTexture(33984 + b),
            c.bindTexture(32879, e.__webglTexture))
        }
        ,
        this.setTextureCube = r,
        this.setTextureCubeDynamic = s,
        this.setupRenderTarget = function(e) {
            var h = d.get(e)
              , i = d.get(e.texture);
            e.addEventListener("dispose", p),
            i.__webglTexture = a.createTexture(),
            g.memory.textures++;
            var n = !0 === e.isWebGLRenderTargetCube
              , o = !0 === e.isWebGLMultisampleRenderTarget
              , r = !0 === e.isWebGLMultiviewRenderTarget
              , s = j(e) || A;
            if (n) {
                h.__webglFramebuffer = [];
                for (var u = 0; 6 > u; u++)
                    h.__webglFramebuffer[u] = a.createFramebuffer()
            } else if (h.__webglFramebuffer = a.createFramebuffer(),
            o)
                if (A) {
                    h.__webglMultisampledFramebuffer = a.createFramebuffer(),
                    h.__webglColorRenderbuffer = a.createRenderbuffer(),
                    a.bindRenderbuffer(36161, h.__webglColorRenderbuffer),
                    o = f.convert(e.texture.format);
                    var v = f.convert(e.texture.type);
                    o = m(e.texture.internalFormat, o, v),
                    v = y(e),
                    a.renderbufferStorageMultisample(36161, v, o, e.width, e.height),
                    a.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                    a.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer),
                    a.bindRenderbuffer(36161, null),
                    e.depthBuffer && (h.__webglDepthRenderbuffer = a.createRenderbuffer(),
                    x(h.__webglDepthRenderbuffer, e, !0)),
                    a.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            else if (r) {
                u = e.width;
                var z = e.height;
                o = e.numViews,
                a.bindFramebuffer(36160, h.__webglFramebuffer);
                var B = b.get("OVR_multiview2");
                g.memory.textures += 2,
                v = a.createTexture(),
                a.bindTexture(35866, v),
                a.texParameteri(35866, 10240, 9728),
                a.texParameteri(35866, 10241, 9728),
                a.texImage3D(35866, 0, 32856, u, z, o, 0, 6408, 5121, null),
                B.framebufferTextureMultiviewOVR(36160, 36064, v, 0, 0, o);
                var C = a.createTexture();
                for (a.bindTexture(35866, C),
                a.texParameteri(35866, 10240, 9728),
                a.texParameteri(35866, 10241, 9728),
                a.texImage3D(35866, 0, 35056, u, z, o, 0, 34041, 34042, null),
                B.framebufferTextureMultiviewOVR(36160, 33306, C, 0, 0, o),
                z = Array(o),
                u = 0; o > u; ++u)
                    z[u] = a.createFramebuffer(),
                    a.bindFramebuffer(36160, z[u]),
                    a.framebufferTextureLayer(36160, 36064, v, 0, u);
                h.__webglColorTexture = v,
                h.__webglDepthStencilTexture = C,
                h.__webglViewFramebuffers = z,
                a.bindFramebuffer(36160, null),
                a.bindTexture(35866, null)
            }
            if (n) {
                for (c.bindTexture(34067, i.__webglTexture),
                t(34067, e.texture, s),
                u = 0; 6 > u; u++)
                    w(h.__webglFramebuffer[u], e, 36064, 34069 + u);
                k(e.texture, s) && l(34067, e.texture, e.width, e.height),
                c.bindTexture(34067, null)
            } else
                r || (c.bindTexture(3553, i.__webglTexture),
                t(3553, e.texture, s),
                w(h.__webglFramebuffer, e, 36064, 3553),
                k(e.texture, s) && l(3553, e.texture, e.width, e.height),
                c.bindTexture(3553, null));
            if (e.depthBuffer) {
                if (h = d.get(e),
                i = !0 === e.isWebGLRenderTargetCube,
                e.depthTexture) {
                    if (i)
                        throw Error("target.depthTexture not supported in Cube render targets");
                    if (e && e.isWebGLRenderTargetCube)
                        throw Error("Depth Texture with cube render targets is not supported");
                    if (a.bindFramebuffer(36160, h.__webglFramebuffer),
                    !e.depthTexture || !e.depthTexture.isDepthTexture)
                        throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (d.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width,
                    e.depthTexture.image.height = e.height,
                    e.depthTexture.needsUpdate = !0),
                    q(e.depthTexture, 0),
                    h = d.get(e.depthTexture).__webglTexture,
                    1026 === e.depthTexture.format)
                        a.framebufferTexture2D(36160, 36096, 3553, h, 0);
                    else {
                        if (1027 !== e.depthTexture.format)
                            throw Error("Unknown depthTexture format");
                        a.framebufferTexture2D(36160, 33306, 3553, h, 0)
                    }
                } else if (i)
                    for (h.__webglDepthbuffer = [],
                    i = 0; 6 > i; i++)
                        a.bindFramebuffer(36160, h.__webglFramebuffer[i]),
                        h.__webglDepthbuffer[i] = a.createRenderbuffer(),
                        x(h.__webglDepthbuffer[i], e);
                else
                    a.bindFramebuffer(36160, h.__webglFramebuffer),
                    h.__webglDepthbuffer = a.createRenderbuffer(),
                    x(h.__webglDepthbuffer, e);
                a.bindFramebuffer(36160, null)
            }
        }
        ,
        this.updateRenderTargetMipmap = function(a) {
            var b = a.texture
              , e = j(a) || A;
            if (k(b, e)) {
                e = a.isWebGLRenderTargetCube ? 34067 : 3553;
                var f = d.get(b).__webglTexture;
                c.bindTexture(e, f),
                l(e, b, a.width, a.height),
                c.bindTexture(e, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(b) {
            if (b.isWebGLMultisampleRenderTarget)
                if (A) {
                    var c = d.get(b);
                    a.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
                    a.bindFramebuffer(36009, c.__webglFramebuffer),
                    c = b.width;
                    var e = b.height
                      , f = 16384;
                    b.depthBuffer && (f |= 256),
                    b.stencilBuffer && (f |= 1024),
                    a.blitFramebuffer(0, 0, c, e, 0, 0, c, e, f, 9728)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(a, b) {
            a && a.isWebGLRenderTarget && (!1 === L && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            L = !0),
            a = a.texture),
            q(a, b)
        }
        ,
        this.safeSetTextureCube = function(a, b) {
            a && a.isWebGLRenderTargetCube && (!1 === M && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            M = !0),
            a = a.texture),
            a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? r(a, b) : s(a, b)
        }
    }
    function Lc(a, b, c) {
        var d = c.isWebGL2;
        return {
            convert: function(a) {
                if (1009 === a)
                    return 5121;
                if (1017 === a)
                    return 32819;
                if (1018 === a)
                    return 32820;
                if (1019 === a)
                    return 33635;
                if (1010 === a)
                    return 5120;
                if (1011 === a)
                    return 5122;
                if (1012 === a)
                    return 5123;
                if (1013 === a)
                    return 5124;
                if (1014 === a)
                    return 5125;
                if (1015 === a)
                    return 5126;
                if (1016 === a) {
                    if (d)
                        return 5131;
                    var c = b.get("OES_texture_half_float");
                    return null !== c ? c.HALF_FLOAT_OES : null
                }
                if (1021 === a)
                    return 6406;
                if (1022 === a)
                    return 6407;
                if (1023 === a)
                    return 6408;
                if (1024 === a)
                    return 6409;
                if (1025 === a)
                    return 6410;
                if (1026 === a)
                    return 6402;
                if (1027 === a)
                    return 34041;
                if (1028 === a)
                    return 6403;
                if (1029 === a)
                    return 36244;
                if (1030 === a)
                    return 33319;
                if (1031 === a)
                    return 33320;
                if (1032 === a)
                    return 36248;
                if (1033 === a)
                    return 36249;
                if (33776 === a || 33777 === a || 33778 === a || 33779 === a) {
                    if (c = b.get("WEBGL_compressed_texture_s3tc"),
                    null === c)
                        return null;
                    if (33776 === a)
                        return c.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === a)
                        return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === a)
                        return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === a)
                        return c.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === a || 35841 === a || 35842 === a || 35843 === a) {
                    if (c = b.get("WEBGL_compressed_texture_pvrtc"),
                    null === c)
                        return null;
                    if (35840 === a)
                        return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === a)
                        return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === a)
                        return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === a)
                        return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                return 36196 === a ? (c = b.get("WEBGL_compressed_texture_etc1"),
                null !== c ? c.COMPRESSED_RGB_ETC1_WEBGL : null) : 37808 === a || 37809 === a || 37810 === a || 37811 === a || 37812 === a || 37813 === a || 37814 === a || 37815 === a || 37816 === a || 37817 === a || 37818 === a || 37819 === a || 37820 === a || 37821 === a ? (c = b.get("WEBGL_compressed_texture_astc"),
                null !== c ? a : null) : 1020 === a ? d ? 34042 : (c = b.get("WEBGL_depth_texture"),
                null !== c ? c.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    function Mc(a, b, c, d) {
        i.call(this, a, b, d),
        this.stencilBuffer = this.depthBuffer = !1,
        this.numViews = c
    }
    function Nc(a, b) {
        function d(a) {
            return a.isArrayCamera ? a.cameras : (l[0] = a,
            l)
        }
        function e(a) {
            if (void 0 === a.isArrayCamera)
                return !0;
            if (a = a.cameras,
            a.length > q)
                return !1;
            for (var b = 1, c = a.length; c > b; b++)
                if (a[0].viewport.z !== a[b].viewport.z || a[0].viewport.w !== a[b].viewport.w)
                    return !1;
            return !0
        }
        var g, h, i, j, l, m, n, o = a.extensions, p = a.properties, q = 0;
        this.isAvailable = function() {
            if (void 0 === n) {
                var a = o.get("OVR_multiview2");
                if (n = null !== a && !1 === b.getContextAttributes().antialias)
                    for (q = b.getParameter(a.MAX_VIEWS_OVR),
                    g = new Mc(0,0,2),
                    m = new c,
                    j = [],
                    i = [],
                    l = [],
                    a = 0; q > a; a++)
                        j[a] = new k,
                        i[a] = new f
            }
            return n
        }
        ,
        this.attachCamera = function(b) {
            if (!1 !== e(b)) {
                if ((h = a.getRenderTarget()) ? m.set(h.width, h.height) : a.getDrawingBufferSize(m),
                b.isArrayCamera) {
                    var c = b.cameras[0].viewport;
                    g.setSize(c.z, c.w),
                    g.setNumViews(b.cameras.length)
                } else
                    g.setSize(m.x, m.y),
                    g.setNumViews(2);
                a.setRenderTarget(g)
            }
        }
        ,
        this.detachCamera = function(c) {
            if (g === a.getRenderTarget()) {
                a.setRenderTarget(h);
                var d = g
                  , e = d.numViews
                  , f = p.get(d).__webglViewFramebuffers
                  , i = d.width;
                if (d = d.height,
                c.isArrayCamera)
                    for (var j = 0; e > j; j++) {
                        var k = c.cameras[j].viewport
                          , l = k.x
                          , n = k.y
                          , o = l + k.z;
                        k = n + k.w,
                        b.bindFramebuffer(36008, f[j]),
                        b.blitFramebuffer(0, 0, i, d, l, n, o, k, 16384, 9728)
                    }
                else
                    b.bindFramebuffer(36008, f[0]),
                    b.blitFramebuffer(0, 0, i, d, 0, 0, m.x, m.y, 16384, 9728)
            }
        }
        ,
        this.updateCameraProjectionMatricesUniform = function(a, c) {
            a = d(a);
            for (var e = 0; e < a.length; e++)
                j[e].copy(a[e].projectionMatrix);
            c.setValue(b, "projectionMatrices", j)
        }
        ,
        this.updateCameraViewMatricesUniform = function(a, c) {
            a = d(a);
            for (var e = 0; e < a.length; e++)
                j[e].copy(a[e].matrixWorldInverse);
            c.setValue(b, "viewMatrices", j)
        }
        ,
        this.updateObjectMatricesUniforms = function(a, c, e) {
            c = d(c);
            for (var f = 0; f < c.length; f++)
                j[f].multiplyMatrices(c[f].matrixWorldInverse, a.matrixWorld),
                i[f].getNormalMatrix(j[f]);
            e.setValue(b, "modelViewMatrices", j),
            e.setValue(b, "normalMatrices", i)
        }
    }
    function Oc(a) {
        X.call(this),
        this.cameras = a || []
    }
    function Pc() {
        n.call(this),
        this.type = "Group"
    }
    function Qc(a, b) {
        function c(a) {
            var b = p.get(a.inputSource);
            b && b.dispatchEvent({
                type: a.type
            })
        }
        function d() {
            p.forEach(function(a, b) {
                a.dispatchEvent({
                    type: "disconnected",
                    data: b
                }),
                a.visible = !1
            }),
            p.clear(),
            a.setFramebuffer(null),
            a.setRenderTarget(a.getRenderTarget()),
            w.stop(),
            j.dispatchEvent({
                type: "sessionend"
            }),
            j.isPresenting = !1
        }
        function f(a) {
            l = a,
            w.setContext(k),
            w.start(),
            j.dispatchEvent({
                type: "sessionstart"
            }),
            j.isPresenting = !0
        }
        function g(a) {
            for (var b = k.inputSources, c = 0; c < o.length; c++)
                p.set(b[c], o[c]);
            for (c = 0; c < a.removed.length; c++) {
                b = a.removed[c];
                var d = p.get(b);
                d && (d.dispatchEvent({
                    type: "disconnected",
                    data: b
                }),
                p.delete(b))
            }
            for (c = 0; c < a.added.length; c++)
                b = a.added[c],
                (d = p.get(b)) && d.dispatchEvent({
                    type: "connected",
                    data: b
                })
        }
        function i(a, b) {
            null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix),
            a.matrixWorldInverse.getInverse(a.matrixWorld)
        }
        var j = this
          , k = null
          , l = null
          , m = "local-floor"
          , n = null
          , o = []
          , p = new Map
          , q = new X;
        q.layers.enable(1),
        q.viewport = new h;
        var r = new X;
        r.layers.enable(2),
        r.viewport = new h;
        var s = new Oc([q, r]);
        s.layers.enable(1),
        s.layers.enable(2),
        this.isPresenting = this.enabled = !1,
        this.getController = function(a) {
            var b = o[a];
            return void 0 === b && (b = new Pc,
            b.matrixAutoUpdate = !1,
            b.visible = !1,
            o[a] = b),
            b
        }
        ,
        this.setFramebufferScaleFactor = function() {}
        ,
        this.setReferenceSpaceType = function(a) {
            m = a
        }
        ,
        this.getReferenceSpace = function() {
            return l
        }
        ,
        this.getSession = function() {
            return k
        }
        ,
        this.setSession = function(a) {
            k = a,
            null !== k && (k.addEventListener("select", c),
            k.addEventListener("selectstart", c),
            k.addEventListener("selectend", c),
            k.addEventListener("squeeze", c),
            k.addEventListener("squeezestart", c),
            k.addEventListener("squeezeend", c),
            k.addEventListener("end", d),
            a = b.getContextAttributes(),
            a = new XRWebGLLayer(k,b,{
                antialias: a.antialias,
                alpha: a.alpha,
                depth: a.depth,
                stencil: a.stencil
            }),
            k.updateRenderState({
                baseLayer: a
            }),
            k.requestReferenceSpace(m).then(f),
            k.addEventListener("inputsourceschange", g))
        }
        ;
        var t = new e
          , u = new e;
        this.getCamera = function(a) {
            var b = a.parent
              , c = s.cameras;
            i(s, b);
            for (var d = 0; d < c.length; d++)
                i(c[d], b);
            for (a.matrixWorld.copy(s.matrixWorld),
            a = a.children,
            d = 0,
            b = a.length; b > d; d++)
                a[d].updateMatrixWorld(!0);
            t.setFromMatrixPosition(q.matrixWorld),
            u.setFromMatrixPosition(r.matrixWorld),
            d = t.distanceTo(u);
            var e = q.projectionMatrix.elements
              , f = r.projectionMatrix.elements
              , g = e[14] / (e[10] - 1);
            a = e[14] / (e[10] + 1),
            b = (e[9] + 1) / e[5],
            c = (e[9] - 1) / e[5];
            var h = (e[8] - 1) / e[0]
              , j = (f[8] + 1) / f[0];
            return f = g * h,
            e = g * j,
            j = d / (-h + j),
            h = j * -h,
            q.matrixWorld.decompose(s.position, s.quaternion, s.scale),
            s.translateX(h),
            s.translateZ(j),
            s.matrixWorld.compose(s.position, s.quaternion, s.scale),
            s.matrixWorldInverse.getInverse(s.matrixWorld),
            g += j,
            j = a + j,
            s.projectionMatrix.makePerspective(f - h, e + (d - h), b * a / j * g, c * a / j * g, g, j),
            s
        }
        ;
        var v = null
          , w = new ab;
        w.setAnimationLoop(function(b, c) {
            if (n = c.getViewerPose(l),
            null !== n) {
                var d = n.views
                  , e = k.renderState.baseLayer;
                a.setFramebuffer(e.framebuffer);
                for (var f = 0; f < d.length; f++) {
                    var g = d[f]
                      , h = e.getViewport(g)
                      , i = s.cameras[f];
                    i.matrix.fromArray(g.transform.inverse.matrix).getInverse(i.matrix),
                    i.projectionMatrix.fromArray(g.projectionMatrix),
                    i.viewport.set(h.x, h.y, h.width, h.height),
                    0 === f && s.matrix.copy(i.matrix)
                }
            }
            for (d = k.inputSources,
            f = 0; f < o.length; f++)
                e = o[f],
                (g = d[f]) && (g = c.getPose(g.targetRaySpace, l),
                null !== g) ? (e.matrix.fromArray(g.transform.matrix),
                e.matrix.decompose(e.position, e.rotation, e.scale),
                e.visible = !0) : e.visible = !1;
            v && v(b, c)
        }),
        this.setAnimationLoop = function(a) {
            v = a
        }
        ,
        this.dispose = function() {}
    }
    function Rc(a) {
        function b() {
            yb = new ib(wb),
            zb = new gb(wb,yb,a),
            !1 === zb.isWebGL2 && (yb.get("WEBGL_depth_texture"),
            yb.get("OES_texture_float"),
            yb.get("OES_texture_half_float"),
            yb.get("OES_texture_half_float_linear"),
            yb.get("OES_standard_derivatives"),
            yb.get("OES_element_index_uint"),
            yb.get("ANGLE_instanced_arrays")),
            yb.get("OES_texture_float_linear"),
            Ob = new Lc(wb,yb,zb),
            Ab = new Jc(wb,yb,zb),
            Ab.scissor(U.copy(mb).multiplyScalar(Y).floor()),
            Ab.viewport(S.copy(db).multiplyScalar(Y).floor()),
            Bb = new lb(wb),
            Cb = new wc,
            Db = new Kc(wb,yb,Ab,Cb,zb,Ob,Bb),
            Eb = new bb(wb),
            Fb = new jb(wb,Eb,Bb),
            Gb = new ob(wb,Fb,Eb,Bb),
            Lb = new nb(wb),
            Hb = new vc(G,yb,zb),
            Ib = new Ac,
            Jb = new Fc,
            Kb = new eb(G,Ab,Gb,A),
            Mb = new fb(wb,yb,Bb,zb),
            Nb = new kb(wb,yb,Bb,zb),
            Bb.programs = Hb.programs,
            G.capabilities = zb,
            G.extensions = yb,
            G.properties = Cb,
            G.renderLists = Ib,
            G.state = Ab,
            G.info = Bb
        }
        function d(a) {
            a.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            H = !0
        }
        function f() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            H = !1,
            b()
        }
        function g(a) {
            a = a.target,
            a.removeEventListener("dispose", g),
            i(a),
            Cb.remove(a)
        }
        function i(a) {
            var b = Cb.get(a).program;
            a.program = void 0,
            void 0 !== b && Hb.releaseProgram(b)
        }
        function j(a, b) {
            a.render(function(a) {
                G.renderBufferImmediate(a, b)
            })
        }
        function l(a, b, c, d) {
            if (!1 !== a.visible) {
                if (a.layers.test(b.layers))
                    if (a.isGroup)
                        c = a.renderOrder;
                    else if (a.isLOD)
                        !0 === a.autoUpdate && a.update(b);
                    else if (a.isLight)
                        F.pushLight(a),
                        a.castShadow && F.pushShadow(a);
                    else if (a.isSprite) {
                        if (!a.frustumCulled || qb.intersectsSprite(a)) {
                            d && vb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ub);
                            var e = Gb.update(a)
                              , f = a.material;
                            f.visible && E.push(a, e, f, c, vb.z, null)
                        }
                    } else if (a.isImmediateRenderObject)
                        d && vb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ub),
                        E.push(a, null, a.material, c, vb.z, null);
                    else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.frame !== Bb.render.frame && (a.skeleton.update(),
                    a.skeleton.frame = Bb.render.frame),
                    !a.frustumCulled || qb.intersectsObject(a)))
                        if (d && vb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ub),
                        e = Gb.update(a),
                        f = a.material,
                        Array.isArray(f))
                            for (var g = e.groups, h = 0, i = g.length; i > h; h++) {
                                var j = g[h]
                                  , k = f[j.materialIndex];
                                k && k.visible && E.push(a, e, k, c, vb.z, j)
                            }
                        else
                            f.visible && E.push(a, e, f, c, vb.z, null);
                for (a = a.children,
                h = 0,
                i = a.length; i > h; h++)
                    l(a[h], b, c, d)
            }
        }
        function m(a, b, c, d) {
            for (var e = 0, f = a.length; f > e; e++) {
                var g = a[e]
                  , h = g.object
                  , i = g.geometry
                  , j = void 0 === d ? g.material : d;
                if (g = g.group,
                c.isArrayCamera)
                    if (R = c,
                    Pb.enabled && Qb.isAvailable())
                        n(h, b, c, i, j, g);
                    else
                        for (var k = c.cameras, l = 0, m = k.length; m > l; l++) {
                            var o = k[l];
                            h.layers.test(o.layers) && (Ab.viewport(S.copy(o.viewport)),
                            F.setupLights(o),
                            n(h, b, o, i, j, g))
                        }
                else
                    R = null,
                    n(h, b, c, i, j, g)
            }
        }
        function n(a, b, c, d, e, f) {
            if (a.onBeforeRender(G, b, c, d, e, f),
            F = Jb.get(b, R || c),
            a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld),
            a.normalMatrix.getNormalMatrix(a.modelViewMatrix),
            a.isImmediateRenderObject) {
                var g = q(c, b, e, a);
                Ab.setMaterial(e),
                O = t = null,
                P = !1,
                j(a, g)
            } else
                G.renderBufferDirect(c, b, d, e, a, f);
            a.onAfterRender(G, b, c, d, e, f),
            F = Jb.get(b, R || c)
        }
        function p(a, b, c) {
            var d = Cb.get(a)
              , e = F.state.lights
              , f = e.state.version;
            c = Hb.getParameters(a, e.state, F.state.shadowsArray, b, rb.numPlanes, rb.numIntersection, c);
            var h = Hb.getProgramCacheKey(a, c)
              , j = d.program
              , k = !0;
            if (void 0 === j)
                a.addEventListener("dispose", g);
            else if (j.cacheKey !== h)
                i(a);
            else {
                if (d.lightsStateVersion !== f)
                    d.lightsStateVersion = f;
                else if (void 0 !== c.shaderID)
                    return;
                k = !1
            }
            if (k && (c.shaderID ? (h = Ni[c.shaderID],
            d.shader = {
                name: a.type,
                uniforms: T(h.uniforms),
                vertexShader: h.vertexShader,
                fragmentShader: h.fragmentShader
            }) : d.shader = {
                name: a.type,
                uniforms: a.uniforms,
                vertexShader: a.vertexShader,
                fragmentShader: a.fragmentShader
            },
            a.onBeforeCompile(d.shader, G),
            h = Hb.getProgramCacheKey(a, c),
            j = Hb.acquireProgram(a, d.shader, c, h),
            d.program = j,
            d.environment = a.isMeshStandardMaterial ? b.environment : null,
            d.outputEncoding = G.outputEncoding,
            a.program = j),
            c = j.getAttributes(),
            a.morphTargets)
                for (h = a.numSupportedMorphTargets = 0; h < G.maxMorphTargets; h++)
                    0 <= c["morphTarget" + h] && a.numSupportedMorphTargets++;
            if (a.morphNormals)
                for (h = a.numSupportedMorphNormals = 0; h < G.maxMorphNormals; h++)
                    0 <= c["morphNormal" + h] && a.numSupportedMorphNormals++;
            c = d.shader.uniforms,
            (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) && (d.numClippingPlanes = rb.numPlanes,
            d.numIntersection = rb.numIntersection,
            c.clippingPlanes = rb.uniform),
            d.fog = b.fog,
            d.needsLights = a.isMeshLambertMaterial || a.isMeshToonMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.isShadowMaterial || a.isShaderMaterial && !0 === a.lights,
            d.lightsStateVersion = f,
            d.needsLights && (c.ambientLightColor.value = e.state.ambient,
            c.lightProbe.value = e.state.probe,
            c.directionalLights.value = e.state.directional,
            c.spotLights.value = e.state.spot,
            c.rectAreaLights.value = e.state.rectArea,
            c.pointLights.value = e.state.point,
            c.hemisphereLights.value = e.state.hemi,
            c.directionalShadowMap.value = e.state.directionalShadowMap,
            c.directionalShadowMatrix.value = e.state.directionalShadowMatrix,
            c.spotShadowMap.value = e.state.spotShadowMap,
            c.spotShadowMatrix.value = e.state.spotShadowMatrix,
            c.pointShadowMap.value = e.state.pointShadowMap,
            c.pointShadowMatrix.value = e.state.pointShadowMatrix),
            a = d.program.getUniforms(),
            a = bc.seqWithValue(a.seq, c),
            d.uniformsList = a
        }
        function q(a, b, c, d) {
            Db.resetTextureUnits();
            var e = b.fog
              , f = c.isMeshStandardMaterial ? b.environment : null
              , g = Cb.get(c)
              , h = F.state.lights;
            sb && (tb || a !== Q) && rb.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, g, a === Q && c.id === N),
            c.version === g.__version && (void 0 === g.program ? c.needsUpdate = !0 : c.fog && g.fog !== e ? c.needsUpdate = !0 : g.environment !== f ? c.needsUpdate = !0 : g.needsLights && g.lightsStateVersion !== h.state.version ? c.needsUpdate = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === rb.numPlanes && g.numIntersection === rb.numIntersection ? g.outputEncoding !== G.outputEncoding && (c.needsUpdate = !0) : c.needsUpdate = !0),
            c.version !== g.__version && (p(c, b, d),
            g.__version = c.version);
            var i = !1
              , j = !1
              , k = !1;
            b = g.program,
            h = b.getUniforms();
            var l = g.shader.uniforms;
            if (Ab.useProgram(b.program) && (k = j = i = !0),
            c.id !== N && (N = c.id,
            j = !0),
            (i || Q !== a) && (0 < b.numMultiviewViews ? Qb.updateCameraProjectionMatricesUniform(a, h) : h.setValue(wb, "projectionMatrix", a.projectionMatrix),
            zb.logarithmicDepthBuffer && h.setValue(wb, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)),
            Q !== a && (Q = a,
            k = j = !0),
            (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshToonMaterial || c.isMeshStandardMaterial || c.envMap) && (i = h.map.cameraPosition,
            void 0 !== i && i.setValue(wb, vb.setFromMatrixPosition(a.matrixWorld))),
            (c.isMeshPhongMaterial || c.isMeshToonMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial) && h.setValue(wb, "isOrthographic", !0 === a.isOrthographicCamera),
            (c.isMeshPhongMaterial || c.isMeshToonMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && (0 < b.numMultiviewViews ? Qb.updateCameraViewMatricesUniform(a, h) : h.setValue(wb, "viewMatrix", a.matrixWorldInverse))),
            c.skinning && (h.setOptional(wb, d, "bindMatrix"),
            h.setOptional(wb, d, "bindMatrixInverse"),
            i = d.skeleton)) {
                var m = i.bones;
                if (zb.floatVertexTextures) {
                    if (void 0 === i.boneTexture) {
                        m = Math.sqrt(4 * m.length),
                        m = Sg.ceilPowerOfTwo(m),
                        m = Math.max(m, 4);
                        var n = new Float32Array(m * m * 4);
                        n.set(i.boneMatrices);
                        var o = new $(n,m,m,1023,1015);
                        i.boneMatrices = n,
                        i.boneTexture = o,
                        i.boneTextureSize = m
                    }
                    h.setValue(wb, "boneTexture", i.boneTexture, Db),
                    h.setValue(wb, "boneTextureSize", i.boneTextureSize)
                } else
                    h.setOptional(wb, i, "boneMatrices")
            }
            if ((j || g.receiveShadow !== d.receiveShadow) && (g.receiveShadow = d.receiveShadow,
            h.setValue(wb, "receiveShadow", d.receiveShadow)),
            j) {
                if (h.setValue(wb, "toneMappingExposure", G.toneMappingExposure),
                h.setValue(wb, "toneMappingWhitePoint", G.toneMappingWhitePoint),
                g.needsLights && (j = k,
                l.ambientLightColor.needsUpdate = j,
                l.lightProbe.needsUpdate = j,
                l.directionalLights.needsUpdate = j,
                l.pointLights.needsUpdate = j,
                l.spotLights.needsUpdate = j,
                l.rectAreaLights.needsUpdate = j,
                l.hemisphereLights.needsUpdate = j),
                e && c.fog && (l.fogColor.value.copy(e.color),
                e.isFog ? (l.fogNear.value = e.near,
                l.fogFar.value = e.far) : e.isFogExp2 && (l.fogDensity.value = e.density)),
                c.isMeshBasicMaterial)
                    r(l, c);
                else if (c.isMeshLambertMaterial)
                    r(l, c),
                    c.emissiveMap && (l.emissiveMap.value = c.emissiveMap);
                else if (c.isMeshToonMaterial)
                    r(l, c),
                    l.specular.value.copy(c.specular),
                    l.shininess.value = Math.max(c.shininess, 1e-4),
                    c.gradientMap && (l.gradientMap.value = c.gradientMap),
                    c.emissiveMap && (l.emissiveMap.value = c.emissiveMap),
                    c.bumpMap && (l.bumpMap.value = c.bumpMap,
                    l.bumpScale.value = c.bumpScale,
                    1 === c.side && (l.bumpScale.value *= -1)),
                    c.normalMap && (l.normalMap.value = c.normalMap,
                    l.normalScale.value.copy(c.normalScale),
                    1 === c.side && l.normalScale.value.negate()),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias);
                else if (c.isMeshPhongMaterial)
                    r(l, c),
                    l.specular.value.copy(c.specular),
                    l.shininess.value = Math.max(c.shininess, 1e-4),
                    c.emissiveMap && (l.emissiveMap.value = c.emissiveMap),
                    c.bumpMap && (l.bumpMap.value = c.bumpMap,
                    l.bumpScale.value = c.bumpScale,
                    1 === c.side && (l.bumpScale.value *= -1)),
                    c.normalMap && (l.normalMap.value = c.normalMap,
                    l.normalScale.value.copy(c.normalScale),
                    1 === c.side && l.normalScale.value.negate()),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias);
                else if (c.isMeshStandardMaterial)
                    r(l, c, f),
                    c.isMeshPhysicalMaterial ? (s(l, c, f),
                    l.reflectivity.value = c.reflectivity,
                    l.clearcoat.value = c.clearcoat,
                    l.clearcoatRoughness.value = c.clearcoatRoughness,
                    c.sheen && l.sheen.value.copy(c.sheen),
                    c.clearcoatNormalMap && (l.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),
                    l.clearcoatNormalMap.value = c.clearcoatNormalMap,
                    1 === c.side && l.clearcoatNormalScale.value.negate()),
                    l.transparency.value = c.transparency) : s(l, c, f);
                else if (c.isMeshMatcapMaterial)
                    r(l, c),
                    c.matcap && (l.matcap.value = c.matcap),
                    c.bumpMap && (l.bumpMap.value = c.bumpMap,
                    l.bumpScale.value = c.bumpScale,
                    1 === c.side && (l.bumpScale.value *= -1)),
                    c.normalMap && (l.normalMap.value = c.normalMap,
                    l.normalScale.value.copy(c.normalScale),
                    1 === c.side && l.normalScale.value.negate()),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias);
                else if (c.isMeshDepthMaterial)
                    r(l, c),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias);
                else if (c.isMeshDistanceMaterial)
                    r(l, c),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias),
                    l.referencePosition.value.copy(c.referencePosition),
                    l.nearDistance.value = c.nearDistance,
                    l.farDistance.value = c.farDistance;
                else if (c.isMeshNormalMaterial)
                    r(l, c),
                    c.bumpMap && (l.bumpMap.value = c.bumpMap,
                    l.bumpScale.value = c.bumpScale,
                    1 === c.side && (l.bumpScale.value *= -1)),
                    c.normalMap && (l.normalMap.value = c.normalMap,
                    l.normalScale.value.copy(c.normalScale),
                    1 === c.side && l.normalScale.value.negate()),
                    c.displacementMap && (l.displacementMap.value = c.displacementMap,
                    l.displacementScale.value = c.displacementScale,
                    l.displacementBias.value = c.displacementBias);
                else if (c.isLineBasicMaterial)
                    l.diffuse.value.copy(c.color),
                    l.opacity.value = c.opacity,
                    c.isLineDashedMaterial && (l.dashSize.value = c.dashSize,
                    l.totalSize.value = c.dashSize + c.gapSize,
                    l.scale.value = c.scale);
                else if (c.isPointsMaterial) {
                    if (l.diffuse.value.copy(c.color),
                    l.opacity.value = c.opacity,
                    l.size.value = c.size * Y,
                    l.scale.value = .5 * X,
                    c.map && (l.map.value = c.map),
                    c.alphaMap && (l.alphaMap.value = c.alphaMap),
                    c.map)
                        var q = c.map;
                    else
                        c.alphaMap && (q = c.alphaMap);
                    void 0 !== q && (!0 === q.matrixAutoUpdate && q.updateMatrix(),
                    l.uvTransform.value.copy(q.matrix))
                } else if (c.isSpriteMaterial) {
                    if (l.diffuse.value.copy(c.color),
                    l.opacity.value = c.opacity,
                    l.rotation.value = c.rotation,
                    c.map && (l.map.value = c.map),
                    c.alphaMap && (l.alphaMap.value = c.alphaMap),
                    c.map)
                        var t = c.map;
                    else
                        c.alphaMap && (t = c.alphaMap);
                    void 0 !== t && (!0 === t.matrixAutoUpdate && t.updateMatrix(),
                    l.uvTransform.value.copy(t.matrix))
                } else
                    c.isShadowMaterial && (l.color.value.copy(c.color),
                    l.opacity.value = c.opacity);
                void 0 !== l.ltc_1 && (l.ltc_1.value = Mi.LTC_1),
                void 0 !== l.ltc_2 && (l.ltc_2.value = Mi.LTC_2),
                bc.upload(wb, g.uniformsList, l, Db),
                c.isShaderMaterial && (c.uniformsNeedUpdate = !1)
            }
            return c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (bc.upload(wb, g.uniformsList, l, Db),
            c.uniformsNeedUpdate = !1),
            c.isSpriteMaterial && h.setValue(wb, "center", d.center),
            0 < b.numMultiviewViews ? Qb.updateObjectMatricesUniforms(d, a, h) : (h.setValue(wb, "modelViewMatrix", d.modelViewMatrix),
            h.setValue(wb, "normalMatrix", d.normalMatrix)),
            h.setValue(wb, "modelMatrix", d.matrixWorld),
            b
        }
        function r(a, b, c) {
            if (a.opacity.value = b.opacity,
            b.color && a.diffuse.value.copy(b.color),
            b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
            b.map && (a.map.value = b.map),
            b.alphaMap && (a.alphaMap.value = b.alphaMap),
            b.specularMap && (a.specularMap.value = b.specularMap),
            (c = b.envMap || c) && (a.envMap.value = c,
            a.flipEnvMap.value = c.isCubeTexture ? -1 : 1,
            a.reflectivity.value = b.reflectivity,
            a.refractionRatio.value = b.refractionRatio,
            a.maxMipLevel.value = Cb.get(c).__maxMipLevel),
            b.lightMap && (a.lightMap.value = b.lightMap,
            a.lightMapIntensity.value = b.lightMapIntensity),
            b.aoMap && (a.aoMap.value = b.aoMap,
            a.aoMapIntensity.value = b.aoMapIntensity),
            b.map)
                var d = b.map;
            else
                b.specularMap ? d = b.specularMap : b.displacementMap ? d = b.displacementMap : b.normalMap ? d = b.normalMap : b.bumpMap ? d = b.bumpMap : b.roughnessMap ? d = b.roughnessMap : b.metalnessMap ? d = b.metalnessMap : b.alphaMap ? d = b.alphaMap : b.emissiveMap && (d = b.emissiveMap);
            if (void 0 !== d && (d.isWebGLRenderTarget && (d = d.texture),
            !0 === d.matrixAutoUpdate && d.updateMatrix(),
            a.uvTransform.value.copy(d.matrix)),
            b.aoMap)
                var e = b.aoMap;
            else
                b.lightMap && (e = b.lightMap);
            void 0 !== e && (e.isWebGLRenderTarget && (e = e.texture),
            !0 === e.matrixAutoUpdate && e.updateMatrix(),
            a.uv2Transform.value.copy(e.matrix))
        }
        function s(a, b, c) {
            a.roughness.value = b.roughness,
            a.metalness.value = b.metalness,
            b.roughnessMap && (a.roughnessMap.value = b.roughnessMap),
            b.metalnessMap && (a.metalnessMap.value = b.metalnessMap),
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap),
            b.bumpMap && (a.bumpMap.value = b.bumpMap,
            a.bumpScale.value = b.bumpScale,
            1 === b.side && (a.bumpScale.value *= -1)),
            b.normalMap && (a.normalMap.value = b.normalMap,
            a.normalScale.value.copy(b.normalScale),
            1 === b.side && a.normalScale.value.negate()),
            b.displacementMap && (a.displacementMap.value = b.displacementMap,
            a.displacementScale.value = b.displacementScale,
            a.displacementBias.value = b.displacementBias),
            (b.envMap || c) && (a.envMapIntensity.value = b.envMapIntensity)
        }
        var t;
        a = a || {};
        var u = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , v = void 0 !== a.context ? a.context : null
          , w = void 0 !== a.alpha ? a.alpha : !1
          , x = void 0 !== a.depth ? a.depth : !0
          , y = void 0 !== a.stencil ? a.stencil : !0
          , z = void 0 !== a.antialias ? a.antialias : !1
          , A = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0
          , B = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1
          , C = void 0 !== a.powerPreference ? a.powerPreference : "default"
          , D = void 0 !== a.failIfMajorPerformanceCaveat ? a.failIfMajorPerformanceCaveat : !1
          , E = null
          , F = null;
        this.domElement = u,
        this.debug = {
            checkShaderErrors: !0
        },
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = 3e3,
        this.physicallyCorrectLights = !1,
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var G = this
          , H = !1
          , I = null
          , J = 0
          , K = 0
          , L = null
          , M = null
          , N = -1
          , O = t = null
          , P = !1
          , Q = null
          , R = null
          , S = new h
          , U = new h
          , V = null
          , W = u.width
          , X = u.height
          , Y = 1
          , Z = null
          , cb = null
          , db = new h(0,0,W,X)
          , mb = new h(0,0,W,X)
          , pb = !1
          , qb = new _
          , rb = new hb
          , sb = !1
          , tb = !1
          , ub = new k
          , vb = new e;
        try {
            w = {
                alpha: w,
                depth: x,
                stencil: y,
                antialias: z,
                premultipliedAlpha: A,
                preserveDrawingBuffer: B,
                powerPreference: C,
                failIfMajorPerformanceCaveat: D,
                xrCompatible: !0
            },
            u.addEventListener("webglcontextlost", d, !1),
            u.addEventListener("webglcontextrestored", f, !1);
            var wb = v || u.getContext("webgl", w) || u.getContext("experimental-webgl", w);
            if (null === wb) {
                if (null !== u.getContext("webgl"))
                    throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === wb.getShaderPrecisionFormat && (wb.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (xb) {
            throw console.error("THREE.WebGLRenderer: " + xb.message),
            xb
        }
        var yb, zb, Ab, Bb, Cb, Db, Eb, Fb, Gb, Hb, Ib, Jb, Kb, Lb, Mb, Nb, Ob;
        b();
        var Pb = new Qc(G,wb);
        this.xr = Pb;
        var Qb = new Nc(G,wb)
          , Rb = new Ic(G,Gb,zb.maxTextureSize);
        this.shadowMap = Rb,
        this.getContext = function() {
            return wb
        }
        ,
        this.getContextAttributes = function() {
            return wb.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var a = yb.get("WEBGL_lose_context");
            a && a.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var a = yb.get("WEBGL_lose_context");
            a && a.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Y
        }
        ,
        this.setPixelRatio = function(a) {
            void 0 !== a && (Y = a,
            this.setSize(W, X, !1))
        }
        ,
        this.getSize = function(a) {
            return void 0 === a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            a = new c),
            a.set(W, X)
        }
        ,
        this.setSize = function(a, b, c) {
            Pb.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = a,
            X = b,
            u.width = Math.floor(a * Y),
            u.height = Math.floor(b * Y),
            !1 !== c && (u.style.width = a + "px",
            u.style.height = b + "px"),
            this.setViewport(0, 0, a, b))
        }
        ,
        this.getDrawingBufferSize = function(a) {
            return void 0 === a && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            a = new c),
            a.set(W * Y, X * Y).floor()
        }
        ,
        this.setDrawingBufferSize = function(a, b, c) {
            W = a,
            X = b,
            Y = c,
            u.width = Math.floor(a * c),
            u.height = Math.floor(b * c),
            this.setViewport(0, 0, a, b)
        }
        ,
        this.getCurrentViewport = function(a) {
            return void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            a = new h),
            a.copy(S)
        }
        ,
        this.getViewport = function(a) {
            return a.copy(db)
        }
        ,
        this.setViewport = function(a, b, c, d) {
            a.isVector4 ? db.set(a.x, a.y, a.z, a.w) : db.set(a, b, c, d),
            Ab.viewport(S.copy(db).multiplyScalar(Y).floor())
        }
        ,
        this.getScissor = function(a) {
            return a.copy(mb)
        }
        ,
        this.setScissor = function(a, b, c, d) {
            a.isVector4 ? mb.set(a.x, a.y, a.z, a.w) : mb.set(a, b, c, d),
            Ab.scissor(U.copy(mb).multiplyScalar(Y).floor())
        }
        ,
        this.getScissorTest = function() {
            return pb
        }
        ,
        this.setScissorTest = function(a) {
            Ab.setScissorTest(pb = a)
        }
        ,
        this.setOpaqueSort = function(a) {
            Z = a
        }
        ,
        this.setTransparentSort = function(a) {
            cb = a
        }
        ,
        this.getClearColor = function() {
            return Kb.getClearColor()
        }
        ,
        this.setClearColor = function() {
            Kb.setClearColor.apply(Kb, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Kb.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Kb.setClearAlpha.apply(Kb, arguments)
        }
        ,
        this.clear = function(a, b, c) {
            var d = 0;
            (void 0 === a || a) && (d |= 16384),
            (void 0 === b || b) && (d |= 256),
            (void 0 === c || c) && (d |= 1024),
            wb.clear(d)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            u.removeEventListener("webglcontextlost", d, !1),
            u.removeEventListener("webglcontextrestored", f, !1),
            Ib.dispose(),
            Jb.dispose(),
            Cb.dispose(),
            Gb.dispose(),
            Pb.dispose(),
            Ub.stop()
        }
        ,
        this.renderBufferImmediate = function(a, b) {
            Ab.initAttributes();
            var c = Cb.get(a);
            a.hasPositions && !c.position && (c.position = wb.createBuffer()),
            a.hasNormals && !c.normal && (c.normal = wb.createBuffer()),
            a.hasUvs && !c.uv && (c.uv = wb.createBuffer()),
            a.hasColors && !c.color && (c.color = wb.createBuffer()),
            b = b.getAttributes(),
            a.hasPositions && (wb.bindBuffer(34962, c.position),
            wb.bufferData(34962, a.positionArray, 35048),
            Ab.enableAttribute(b.position),
            wb.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0)),
            a.hasNormals && (wb.bindBuffer(34962, c.normal),
            wb.bufferData(34962, a.normalArray, 35048),
            Ab.enableAttribute(b.normal),
            wb.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0)),
            a.hasUvs && (wb.bindBuffer(34962, c.uv),
            wb.bufferData(34962, a.uvArray, 35048),
            Ab.enableAttribute(b.uv),
            wb.vertexAttribPointer(b.uv, 2, 5126, !1, 0, 0)),
            a.hasColors && (wb.bindBuffer(34962, c.color),
            wb.bufferData(34962, a.colorArray, 35048),
            Ab.enableAttribute(b.color),
            wb.vertexAttribPointer(b.color, 3, 5126, !1, 0, 0)),
            Ab.disableUnusedAttributes(),
            wb.drawArrays(4, 0, a.count),
            a.count = 0
        }
        ;
        var Sb = new o;
        this.renderBufferDirect = function(a, b, c, d, e, f) {
            null === b && (b = Sb);
            var g = e.isMesh && 0 > e.matrixWorld.determinant()
              , h = q(a, b, d, e);
            Ab.setMaterial(d, g);
            var i = !1;
            if ((t !== c.id || O !== h.id || P !== (!0 === d.wireframe)) && (t = c.id,
            O = h.id,
            P = !0 === d.wireframe,
            i = !0),
            (d.morphTargets || d.morphNormals) && (Lb.update(e, c, d, h),
            i = !0),
            a = c.index,
            b = c.attributes.position,
            null === a) {
                if (void 0 === b || 0 === b.count)
                    return
            } else if (0 === a.count)
                return;
            var j = 1;
            if (!0 === d.wireframe && (a = Fb.getWireframeAttribute(c),
            j = 2),
            g = Mb,
            null !== a) {
                var k = Eb.get(a);
                g = Nb,
                g.setIndex(k)
            }
            if (i) {
                if (!1 !== zb.isWebGL2 || !e.isInstancedMesh && !c.isInstancedBufferGeometry || null !== yb.get("ANGLE_instanced_arrays")) {
                    Ab.initAttributes(),
                    i = c.attributes,
                    h = h.getAttributes();
                    var l = d.defaultAttributeValues;
                    for (x in h) {
                        var m = h[x];
                        if (m >= 0) {
                            var n = i[x];
                            if (void 0 !== n) {
                                var o = n.normalized
                                  , p = n.itemSize
                                  , r = Eb.get(n);
                                if (void 0 !== r) {
                                    var s = r.buffer
                                      , u = r.type;
                                    if (r = r.bytesPerElement,
                                    n.isInterleavedBufferAttribute) {
                                        var v = n.data
                                          , w = v.stride;
                                        n = n.offset,
                                        v && v.isInstancedInterleavedBuffer ? (Ab.enableAttributeAndDivisor(m, v.meshPerAttribute),
                                        void 0 === c.maxInstancedCount && (c.maxInstancedCount = v.meshPerAttribute * v.count)) : Ab.enableAttribute(m),
                                        wb.bindBuffer(34962, s),
                                        wb.vertexAttribPointer(m, p, u, o, w * r, n * r)
                                    } else
                                        n.isInstancedBufferAttribute ? (Ab.enableAttributeAndDivisor(m, n.meshPerAttribute),
                                        void 0 === c.maxInstancedCount && (c.maxInstancedCount = n.meshPerAttribute * n.count)) : Ab.enableAttribute(m),
                                        wb.bindBuffer(34962, s),
                                        wb.vertexAttribPointer(m, p, u, o, 0, 0)
                                }
                            } else if ("instanceMatrix" === x)
                                r = Eb.get(e.instanceMatrix),
                                void 0 !== r && (s = r.buffer,
                                u = r.type,
                                Ab.enableAttributeAndDivisor(m + 0, 1),
                                Ab.enableAttributeAndDivisor(m + 1, 1),
                                Ab.enableAttributeAndDivisor(m + 2, 1),
                                Ab.enableAttributeAndDivisor(m + 3, 1),
                                wb.bindBuffer(34962, s),
                                wb.vertexAttribPointer(m + 0, 4, u, !1, 64, 0),
                                wb.vertexAttribPointer(m + 1, 4, u, !1, 64, 16),
                                wb.vertexAttribPointer(m + 2, 4, u, !1, 64, 32),
                                wb.vertexAttribPointer(m + 3, 4, u, !1, 64, 48));
                            else if (void 0 !== l && (o = l[x],
                            void 0 !== o))
                                switch (o.length) {
                                case 2:
                                    wb.vertexAttrib2fv(m, o);
                                    break;
                                case 3:
                                    wb.vertexAttrib3fv(m, o);
                                    break;
                                case 4:
                                    wb.vertexAttrib4fv(m, o);
                                    break;
                                default:
                                    wb.vertexAttrib1fv(m, o)
                                }
                        }
                    }
                    Ab.disableUnusedAttributes()
                }
                null !== a && wb.bindBuffer(34963, k.buffer)
            }
            var x = c.drawRange.start * j;
            i = null !== f ? f.start * j : 0,
            k = Math.max(x, i),
            f = Math.max(0, Math.min(null !== a ? a.count : b.count, x + c.drawRange.count * j, i + (null !== f ? f.count * j : 1 / 0)) - 1 - k + 1),
            0 !== f && (e.isMesh ? !0 === d.wireframe ? (Ab.setLineWidth(d.wireframeLinewidth * (null === L ? Y : 1)),
            g.setMode(1)) : g.setMode(4) : e.isLine ? (d = d.linewidth,
            void 0 === d && (d = 1),
            Ab.setLineWidth(d * (null === L ? Y : 1)),
            e.isLineSegments ? g.setMode(1) : e.isLineLoop ? g.setMode(2) : g.setMode(3)) : e.isPoints ? g.setMode(0) : e.isSprite && g.setMode(4),
            e.isInstancedMesh ? g.renderInstances(c, k, f, e.count) : c.isInstancedBufferGeometry ? g.renderInstances(c, k, f, c.maxInstancedCount) : g.render(k, f))
        }
        ,
        this.compile = function(a, b) {
            F = Jb.get(a, b),
            F.init(),
            a.traverse(function(a) {
                a.isLight && (F.pushLight(a),
                a.castShadow && F.pushShadow(a))
            }),
            F.setupLights(b),
            a.traverse(function(b) {
                if (b.material)
                    if (Array.isArray(b.material))
                        for (var c = 0; c < b.material.length; c++)
                            p(b.material[c], a, b);
                    else
                        p(b.material, a, b)
            })
        }
        ;
        var Tb = null
          , Ub = new ab;
        Ub.setAnimationLoop(function(a) {
            Pb.isPresenting || Tb && Tb(a)
        }),
        "undefined" != typeof window && Ub.setContext(window),
        this.setAnimationLoop = function(a) {
            Tb = a,
            Pb.setAnimationLoop(a),
            Ub.start()
        }
        ,
        this.render = function(a, b, c, d) {
            if (void 0 !== c) {
                console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                var e = c
            }
            if (void 0 !== d) {
                console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                var f = d
            }
            b && b.isCamera ? H || (O = t = null,
            P = !1,
            N = -1,
            Q = null,
            !0 === a.autoUpdate && a.updateMatrixWorld(),
            null === b.parent && b.updateMatrixWorld(),
            Pb.enabled && Pb.isPresenting && (b = Pb.getCamera(b)),
            F = Jb.get(a, b),
            F.init(),
            a.onBeforeRender(G, a, b, e || L),
            ub.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
            qb.setFromMatrix(ub),
            tb = this.localClippingEnabled,
            sb = rb.init(this.clippingPlanes, tb, b),
            E = Ib.get(a, b),
            E.init(),
            l(a, b, 0, G.sortObjects),
            !0 === G.sortObjects && E.sort(Z, cb),
            sb && rb.beginShadows(),
            Rb.render(F.state.shadowsArray, a, b),
            F.setupLights(b),
            sb && rb.endShadows(),
            this.info.autoReset && this.info.reset(),
            void 0 !== e && this.setRenderTarget(e),
            Pb.enabled && Qb.isAvailable() && Qb.attachCamera(b),
            Kb.render(E, a, b, f),
            c = E.opaque,
            d = E.transparent,
            a.overrideMaterial ? (e = a.overrideMaterial,
            c.length && m(c, a, b, e),
            d.length && m(d, a, b, e)) : (c.length && m(c, a, b),
            d.length && m(d, a, b)),
            a.onAfterRender(G, a, b),
            null !== L && (Db.updateRenderTargetMipmap(L),
            Db.updateMultisampleRenderTarget(L)),
            Ab.buffers.depth.setTest(!0),
            Ab.buffers.depth.setMask(!0),
            Ab.buffers.color.setMask(!0),
            Ab.setPolygonOffset(!1),
            Pb.enabled && Qb.isAvailable() && Qb.detachCamera(b),
            F = E = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.setFramebuffer = function(a) {
            I !== a && null === L && wb.bindFramebuffer(36160, a),
            I = a
        }
        ,
        this.getActiveCubeFace = function() {
            return J
        }
        ,
        this.getActiveMipmapLevel = function() {
            return K
        }
        ,
        this.getRenderTarget = function() {
            return L
        }
        ,
        this.setRenderTarget = function(a, b, c) {
            L = a,
            J = b,
            K = c,
            a && void 0 === Cb.get(a).__webglFramebuffer && Db.setupRenderTarget(a);
            var d = I
              , e = !1;
            a ? (d = Cb.get(a).__webglFramebuffer,
            a.isWebGLRenderTargetCube ? (d = d[b || 0],
            e = !0) : d = a.isWebGLMultisampleRenderTarget ? Cb.get(a).__webglMultisampledFramebuffer : d,
            S.copy(a.viewport),
            U.copy(a.scissor),
            V = a.scissorTest) : (S.copy(db).multiplyScalar(Y).floor(),
            U.copy(mb).multiplyScalar(Y).floor(),
            V = pb),
            M !== d && (wb.bindFramebuffer(36160, d),
            M = d),
            Ab.viewport(S),
            Ab.scissor(U),
            Ab.setScissorTest(V),
            e && (a = Cb.get(a.texture),
            wb.framebufferTexture2D(36160, 36064, 34069 + (b || 0), a.__webglTexture, c || 0))
        }
        ,
        this.readRenderTargetPixels = function(a, b, c, d, e, f, g) {
            if (a && a.isWebGLRenderTarget) {
                var h = Cb.get(a).__webglFramebuffer;
                if (a.isWebGLRenderTargetCube && void 0 !== g && (h = h[g]),
                h) {
                    g = !1,
                    h !== M && (wb.bindFramebuffer(36160, h),
                    g = !0);
                    try {
                        var i = a.texture
                          , j = i.format
                          , k = i.type;
                        1023 !== j && Ob.convert(j) !== wb.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === k || Ob.convert(k) === wb.getParameter(35738) || 1015 === k && (zb.isWebGL2 || yb.get("OES_texture_float") || yb.get("WEBGL_color_buffer_float")) || 1016 === k && (zb.isWebGL2 ? yb.get("EXT_color_buffer_float") : yb.get("EXT_color_buffer_half_float")) ? 36053 === wb.checkFramebufferStatus(36160) ? b >= 0 && b <= a.width - d && c >= 0 && c <= a.height - e && wb.readPixels(b, c, d, e, Ob.convert(j), Ob.convert(k), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        g && wb.bindFramebuffer(36160, M)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(a, b, c) {
            void 0 === c && (c = 0);
            var d = Math.pow(2, -c)
              , e = Math.floor(b.image.width * d);
            d = Math.floor(b.image.height * d);
            var f = Ob.convert(b.format);
            Db.setTexture2D(b, 0),
            wb.copyTexImage2D(3553, c, f, a.x, a.y, e, d, 0),
            Ab.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(a, b, c, d) {
            var e = b.image.width
              , f = b.image.height
              , g = Ob.convert(c.format)
              , h = Ob.convert(c.type);
            Db.setTexture2D(c, 0),
            b.isDataTexture ? wb.texSubImage2D(3553, d || 0, a.x, a.y, e, f, g, h, b.image.data) : wb.texSubImage2D(3553, d || 0, a.x, a.y, g, h, b.image),
            Ab.unbindTexture()
        }
        ,
        this.initTexture = function(a) {
            Db.setTexture2D(a, 0),
            Ab.unbindTexture()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    function Sc(a, b) {
        this.name = "",
        this.color = new v(a),
        this.density = void 0 !== b ? b : 25e-5
    }
    function Tc(a, b, c) {
        this.name = "",
        this.color = new v(a),
        this.near = void 0 !== b ? b : 1,
        this.far = void 0 !== c ? c : 1e3
    }
    function Uc(a, b) {
        this.array = a,
        this.stride = b,
        this.count = void 0 !== a ? a.length / b : 0,
        this.usage = 35044,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Vc(a, b, c, d) {
        this.data = a,
        this.itemSize = b,
        this.offset = c,
        this.normalized = !0 === d
    }
    function Wc(a) {
        A.call(this),
        this.type = "SpriteMaterial",
        this.color = new v(16777215),
        this.alphaMap = this.map = null,
        this.rotation = 0,
        this.transparent = this.sizeAttenuation = !0,
        this.setValues(a)
    }
    function Xc(a) {
        if (n.call(this),
        this.type = "Sprite",
        void 0 === bj) {
            bj = new O;
            var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            b = new Uc(b,5),
            bj.setIndex([0, 1, 2, 0, 2, 3]),
            bj.setAttribute("position", new Vc(b,3,0,!1)),
            bj.setAttribute("uv", new Vc(b,2,3,!1))
        }
        this.geometry = bj,
        this.material = void 0 !== a ? a : new Wc,
        this.center = new c(.5,.5)
    }
    function Yc(a, b, c, d, e, f) {
        fj.subVectors(a, c).addScalar(.5).multiply(d),
        void 0 !== e ? (gj.x = f * fj.x - e * fj.y,
        gj.y = e * fj.x + f * fj.y) : gj.copy(fj),
        a.copy(b),
        a.x += gj.x,
        a.y += gj.y,
        a.applyMatrix4(hj)
    }
    function Zc() {
        n.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }),
        this.autoUpdate = !0
    }
    function $c(a, b) {
        a && a.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        P.call(this, a, b),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new k,
        this.bindMatrixInverse = new k
    }
    function _c(a, b) {
        if (a = a || [],
        this.bones = a.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        this.frame = -1,
        void 0 === b)
            this.calculateInverses();
        else if (this.bones.length === b.length)
            this.boneInverses = b.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [],
            a = 0,
            b = this.bones.length; b > a; a++)
                this.boneInverses.push(new k)
    }
    function ad() {
        n.call(this),
        this.type = "Bone"
    }
    function bd(a, b, c) {
        P.call(this, a, b),
        this.instanceMatrix = new C(new Float32Array(16 * c),16),
        this.count = c
    }
    function cd(a) {
        A.call(this),
        this.type = "LineBasicMaterial",
        this.color = new v(16777215),
        this.linewidth = 1,
        this.linejoin = this.linecap = "round",
        this.setValues(a)
    }
    function dd(a, b, c) {
        1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
        n.call(this),
        this.type = "Line",
        this.geometry = void 0 !== a ? a : new O,
        this.material = void 0 !== b ? b : new cd({
            color: 16777215 * Math.random()
        })
    }
    function ed(a, b) {
        dd.call(this, a, b),
        this.type = "LineSegments"
    }
    function fd(a, b) {
        dd.call(this, a, b),
        this.type = "LineLoop"
    }
    function gd(a) {
        A.call(this),
        this.type = "PointsMaterial",
        this.color = new v(16777215),
        this.alphaMap = this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.setValues(a)
    }
    function hd(a, b) {
        n.call(this),
        this.type = "Points",
        this.geometry = void 0 !== a ? a : new O,
        this.material = void 0 !== b ? b : new gd({
            color: 16777215 * Math.random()
        }),
        this.updateMorphTargets()
    }
    function id(a, b, c, d, f, g, h) {
        var i = Ej.distanceSqToPoint(a);
        c > i && (c = new e,
        Ej.closestPointToPoint(a, c),
        c.applyMatrix4(d),
        a = f.ray.origin.distanceTo(c),
        a < f.near || a > f.far || g.push({
            distance: a,
            distanceToRay: Math.sqrt(i),
            point: c,
            index: b,
            face: null,
            object: h
        }))
    }
    function jd(a, b, c, d, e, f, h, i, j) {
        g.call(this, a, b, c, d, e, f, h, i, j),
        this.format = void 0 !== h ? h : 1022,
        this.minFilter = void 0 !== f ? f : 1006,
        this.magFilter = void 0 !== e ? e : 1006,
        this.generateMipmaps = !1
    }
    function kd(a, b, c, d, e, f, h, i, j, k, l, m) {
        g.call(this, null, f, h, i, j, k, d, e, l, m),
        this.image = {
            width: b,
            height: c
        },
        this.mipmaps = a,
        this.generateMipmaps = this.flipY = !1
    }
    function ld(a, b, c, d, e, f, h, i, j) {
        g.call(this, a, b, c, d, e, f, h, i, j),
        this.needsUpdate = !0
    }
    function md(a, b, c, d, e, f, h, i, j, k) {
        if (k = void 0 !== k ? k : 1026,
        1026 !== k && 1027 !== k)
            throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === c && 1026 === k && (c = 1012),
        void 0 === c && 1027 === k && (c = 1020),
        g.call(this, null, d, e, f, h, i, k, c, j),
        this.image = {
            width: a,
            height: b
        },
        this.magFilter = void 0 !== h ? h : 1003,
        this.minFilter = void 0 !== i ? i : 1003,
        this.generateMipmaps = this.flipY = !1
    }
    function nd(a) {
        O.call(this),
        this.type = "WireframeGeometry";
        var b, c, d, f = [], g = [0, 0], h = {}, i = ["a", "b", "c"];
        if (a && a.isGeometry) {
            var j = a.faces
              , k = 0;
            for (c = j.length; c > k; k++) {
                var l = j[k];
                for (b = 0; 3 > b; b++) {
                    var m = l[i[b]]
                      , n = l[i[(b + 1) % 3]];
                    g[0] = Math.min(m, n),
                    g[1] = Math.max(m, n),
                    m = g[0] + "," + g[1],
                    void 0 === h[m] && (h[m] = {
                        index1: g[0],
                        index2: g[1]
                    })
                }
            }
            for (m in h)
                k = h[m],
                i = a.vertices[k.index1],
                f.push(i.x, i.y, i.z),
                i = a.vertices[k.index2],
                f.push(i.x, i.y, i.z)
        } else if (a && a.isBufferGeometry)
            if (i = new e,
            null !== a.index) {
                j = a.attributes.position,
                l = a.index;
                var o = a.groups;
                for (0 === o.length && (o = [{
                    start: 0,
                    count: l.count,
                    materialIndex: 0
                }]),
                a = 0,
                d = o.length; d > a; ++a)
                    for (k = o[a],
                    b = k.start,
                    c = k.count,
                    k = b,
                    c = b + c; c > k; k += 3)
                        for (b = 0; 3 > b; b++)
                            m = l.getX(k + b),
                            n = l.getX(k + (b + 1) % 3),
                            g[0] = Math.min(m, n),
                            g[1] = Math.max(m, n),
                            m = g[0] + "," + g[1],
                            void 0 === h[m] && (h[m] = {
                                index1: g[0],
                                index2: g[1]
                            });
                for (m in h)
                    k = h[m],
                    i.fromBufferAttribute(j, k.index1),
                    f.push(i.x, i.y, i.z),
                    i.fromBufferAttribute(j, k.index2),
                    f.push(i.x, i.y, i.z)
            } else
                for (j = a.attributes.position,
                k = 0,
                c = j.count / 3; c > k; k++)
                    for (b = 0; 3 > b; b++)
                        h = 3 * k + b,
                        i.fromBufferAttribute(j, h),
                        f.push(i.x, i.y, i.z),
                        h = 3 * k + (b + 1) % 3,
                        i.fromBufferAttribute(j, h),
                        f.push(i.x, i.y, i.z);
        this.setAttribute("position", new K(f,3))
    }
    function od(a, b, c) {
        S.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: a,
            slices: b,
            stacks: c
        },
        this.fromBufferGeometry(new pd(a,b,c)),
        this.mergeVertices()
    }
    function pd(a, b, c) {
        O.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: a,
            slices: b,
            stacks: c
        };
        var d, f, g = [], h = [], i = [], j = [], k = new e, l = new e, m = new e, n = new e, o = new e;
        3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var p = b + 1;
        for (d = 0; c >= d; d++) {
            var q = d / c;
            for (f = 0; b >= f; f++) {
                var r = f / b;
                a(r, q, l),
                h.push(l.x, l.y, l.z),
                r - 1e-5 >= 0 ? (a(r - 1e-5, q, m),
                n.subVectors(l, m)) : (a(r + 1e-5, q, m),
                n.subVectors(m, l)),
                q - 1e-5 >= 0 ? (a(r, q - 1e-5, m),
                o.subVectors(l, m)) : (a(r, q + 1e-5, m),
                o.subVectors(m, l)),
                k.crossVectors(n, o).normalize(),
                i.push(k.x, k.y, k.z),
                j.push(r, q)
            }
        }
        for (d = 0; c > d; d++)
            for (f = 0; b > f; f++)
                a = d * p + f + 1,
                k = (d + 1) * p + f + 1,
                l = (d + 1) * p + f,
                g.push(d * p + f, a, l),
                g.push(a, k, l);
        this.setIndex(g),
        this.setAttribute("position", new K(h,3)),
        this.setAttribute("normal", new K(i,3)),
        this.setAttribute("uv", new K(j,2))
    }
    function qd(a, b, c, d) {
        S.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        },
        this.fromBufferGeometry(new rd(a,b,c,d)),
        this.mergeVertices()
    }
    function rd(a, b, d, f) {
        function g(a) {
            j.push(a.x, a.y, a.z)
        }
        function h(b, c) {
            b *= 3,
            c.x = a[b + 0],
            c.y = a[b + 1],
            c.z = a[b + 2]
        }
        function i(a, b, c, d) {
            0 > d && 1 === a.x && (k[b] = a.x - 1),
            0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
        }
        O.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: a,
            indices: b,
            radius: d,
            detail: f
        },
        d = d || 1,
        f = f || 0;
        var j = []
          , k = [];
        !function(a) {
            for (var c = new e, d = new e, f = new e, i = 0; i < b.length; i += 3) {
                h(b[i + 0], c),
                h(b[i + 1], d),
                h(b[i + 2], f);
                var j, k, l = c, m = d, n = f, o = Math.pow(2, a), p = [];
                for (k = 0; o >= k; k++) {
                    p[k] = [];
                    var q = l.clone().lerp(n, k / o)
                      , r = m.clone().lerp(n, k / o)
                      , s = o - k;
                    for (j = 0; s >= j; j++)
                        p[k][j] = 0 === j && k === o ? q : q.clone().lerp(r, j / s)
                }
                for (k = 0; o > k; k++)
                    for (j = 0; 2 * (o - k) - 1 > j; j++)
                        l = Math.floor(j / 2),
                        0 === j % 2 ? (g(p[k][l + 1]),
                        g(p[k + 1][l]),
                        g(p[k][l])) : (g(p[k][l + 1]),
                        g(p[k + 1][l + 1]),
                        g(p[k + 1][l]))
            }
        }(f),
        function(a) {
            for (var b = new e, c = 0; c < j.length; c += 3)
                b.x = j[c + 0],
                b.y = j[c + 1],
                b.z = j[c + 2],
                b.normalize().multiplyScalar(a),
                j[c + 0] = b.x,
                j[c + 1] = b.y,
                j[c + 2] = b.z
        }(d),
        function() {
            for (var a = new e, b = 0; b < j.length; b += 3)
                a.x = j[b + 0],
                a.y = j[b + 1],
                a.z = j[b + 2],
                k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
            a = new e,
            b = new e;
            for (var d = new e, f = new e, g = new c, h = new c, l = new c, m = 0, n = 0; m < j.length; m += 9,
            n += 6) {
                a.set(j[m + 0], j[m + 1], j[m + 2]),
                b.set(j[m + 3], j[m + 4], j[m + 5]),
                d.set(j[m + 6], j[m + 7], j[m + 8]),
                g.set(k[n + 0], k[n + 1]),
                h.set(k[n + 2], k[n + 3]),
                l.set(k[n + 4], k[n + 5]),
                f.copy(a).add(b).add(d).divideScalar(3);
                var o = Math.atan2(f.z, -f.x);
                i(g, n + 0, a, o),
                i(h, n + 2, b, o),
                i(l, n + 4, d, o)
            }
            for (a = 0; a < k.length; a += 6)
                b = k[a + 0],
                d = k[a + 2],
                f = k[a + 4],
                g = Math.min(b, d, f),
                .9 < Math.max(b, d, f) && .1 > g && (.2 > b && (k[a + 0] += 1),
                .2 > d && (k[a + 2] += 1),
                .2 > f && (k[a + 4] += 1))
        }(),
        this.setAttribute("position", new K(j,3)),
        this.setAttribute("normal", new K(j.slice(),3)),
        this.setAttribute("uv", new K(k,2)),
        0 === f ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function sd(a, b) {
        S.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: a,
            detail: b
        },
        this.fromBufferGeometry(new td(a,b)),
        this.mergeVertices()
    }
    function td(a, b) {
        rd.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: a,
            detail: b
        }
    }
    function ud(a, b) {
        S.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: a,
            detail: b
        },
        this.fromBufferGeometry(new vd(a,b)),
        this.mergeVertices()
    }
    function vd(a, b) {
        rd.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: a,
            detail: b
        }
    }
    function wd(a, b) {
        S.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: a,
            detail: b
        },
        this.fromBufferGeometry(new xd(a,b)),
        this.mergeVertices()
    }
    function xd(a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        rd.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: a,
            detail: b
        }
    }
    function yd(a, b) {
        S.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: a,
            detail: b
        },
        this.fromBufferGeometry(new zd(a,b)),
        this.mergeVertices()
    }
    function zd(a, b) {
        var c = (1 + Math.sqrt(5)) / 2
          , d = 1 / c;
        rd.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: a,
            detail: b
        }
    }
    function Ad(a, b, c, d, e, f) {
        S.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: a,
            tubularSegments: b,
            radius: c,
            radialSegments: d,
            closed: e
        },
        void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."),
        a = new Bd(a,b,c,d,e),
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function Bd(a, b, d, f, g) {
        function h(c) {
            o = a.getPointAt(c / b, o);
            var e = i.normals[c];
            for (c = i.binormals[c],
            k = 0; f >= k; k++) {
                var g = k / f * Math.PI * 2
                  , h = Math.sin(g);
                g = -Math.cos(g),
                m.x = g * e.x + h * c.x,
                m.y = g * e.y + h * c.y,
                m.z = g * e.z + h * c.z,
                m.normalize(),
                q.push(m.x, m.y, m.z),
                l.x = o.x + d * m.x,
                l.y = o.y + d * m.y,
                l.z = o.z + d * m.z,
                p.push(l.x, l.y, l.z)
            }
        }
        O.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: a,
            tubularSegments: b,
            radius: d,
            radialSegments: f,
            closed: g
        },
        b = b || 64,
        d = d || 1,
        f = f || 8,
        g = g || !1;
        var i = a.computeFrenetFrames(b, g);
        this.tangents = i.tangents,
        this.normals = i.normals,
        this.binormals = i.binormals;
        var j, k, l = new e, m = new e, n = new c, o = new e, p = [], q = [], r = [], s = [];
        for (j = 0; b > j; j++)
            h(j);
        for (h(!1 === g ? b : 0),
        j = 0; b >= j; j++)
            for (k = 0; f >= k; k++)
                n.x = j / b,
                n.y = k / f,
                r.push(n.x, n.y);
        !function() {
            for (k = 1; b >= k; k++)
                for (j = 1; f >= j; j++) {
                    var a = (f + 1) * k + (j - 1)
                      , c = (f + 1) * k + j
                      , d = (f + 1) * (k - 1) + j;
                    s.push((f + 1) * (k - 1) + (j - 1), a, d),
                    s.push(a, c, d)
                }
        }(),
        this.setIndex(s),
        this.setAttribute("position", new K(p,3)),
        this.setAttribute("normal", new K(q,3)),
        this.setAttribute("uv", new K(r,2))
    }
    function Cd(a, b, c, d, e, f, g) {
        S.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
        },
        void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new Dd(a,b,c,d,e,f)),
        this.mergeVertices()
    }
    function Dd(a, b, c, d, f, g) {
        function h(a, b, c, d, e) {
            var f = Math.sin(a);
            b = c / b * a,
            c = Math.cos(b),
            e.x = d * (2 + c) * .5 * Math.cos(a),
            e.y = d * (2 + c) * f * .5,
            e.z = d * Math.sin(b) * .5
        }
        O.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: f,
            q: g
        },
        a = a || 1,
        b = b || .4,
        c = Math.floor(c) || 64,
        d = Math.floor(d) || 8,
        f = f || 2,
        g = g || 3;
        var i, j = [], k = [], l = [], m = [], n = new e, o = new e, p = new e, q = new e, r = new e, s = new e, t = new e;
        for (i = 0; c >= i; ++i) {
            var u = i / c * f * Math.PI * 2;
            for (h(u, f, g, a, p),
            h(u + .01, f, g, a, q),
            s.subVectors(q, p),
            t.addVectors(q, p),
            r.crossVectors(s, t),
            t.crossVectors(r, s),
            r.normalize(),
            t.normalize(),
            u = 0; d >= u; ++u) {
                var v = u / d * Math.PI * 2
                  , w = -b * Math.cos(v);
                v = b * Math.sin(v),
                n.x = p.x + (w * t.x + v * r.x),
                n.y = p.y + (w * t.y + v * r.y),
                n.z = p.z + (w * t.z + v * r.z),
                k.push(n.x, n.y, n.z),
                o.subVectors(n, p).normalize(),
                l.push(o.x, o.y, o.z),
                m.push(i / c),
                m.push(u / d)
            }
        }
        for (u = 1; c >= u; u++)
            for (i = 1; d >= i; i++)
                a = (d + 1) * u + (i - 1),
                b = (d + 1) * u + i,
                f = (d + 1) * (u - 1) + i,
                j.push((d + 1) * (u - 1) + (i - 1), a, f),
                j.push(a, b, f);
        this.setIndex(j),
        this.setAttribute("position", new K(k,3)),
        this.setAttribute("normal", new K(l,3)),
        this.setAttribute("uv", new K(m,2))
    }
    function Ed(a, b, c, d, e) {
        S.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        },
        this.fromBufferGeometry(new Fd(a,b,c,d,e)),
        this.mergeVertices()
    }
    function Fd(a, b, c, d, f) {
        O.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: f
        },
        a = a || 1,
        b = b || .4,
        c = Math.floor(c) || 8,
        d = Math.floor(d) || 6,
        f = f || 2 * Math.PI;
        var g, h, i = [], j = [], k = [], l = [], m = new e, n = new e, o = new e;
        for (g = 0; c >= g; g++)
            for (h = 0; d >= h; h++) {
                var p = h / d * f
                  , q = g / c * Math.PI * 2;
                n.x = (a + b * Math.cos(q)) * Math.cos(p),
                n.y = (a + b * Math.cos(q)) * Math.sin(p),
                n.z = b * Math.sin(q),
                j.push(n.x, n.y, n.z),
                m.x = a * Math.cos(p),
                m.y = a * Math.sin(p),
                o.subVectors(n, m).normalize(),
                k.push(o.x, o.y, o.z),
                l.push(h / d),
                l.push(g / c)
            }
        for (g = 1; c >= g; g++)
            for (h = 1; d >= h; h++)
                a = (d + 1) * (g - 1) + h - 1,
                b = (d + 1) * (g - 1) + h,
                f = (d + 1) * g + h,
                i.push((d + 1) * g + h - 1, a, f),
                i.push(a, b, f);
        this.setIndex(i),
        this.setAttribute("position", new K(j,3)),
        this.setAttribute("normal", new K(k,3)),
        this.setAttribute("uv", new K(l,2))
    }
    function Gd(a, b, c, d, e) {
        for (var f, g = 0, h = b, i = c - d; c > h; h += d)
            g += (a[i] - a[h]) * (a[h + 1] + a[i + 1]),
            i = h;
        if (e === g > 0)
            for (e = b; c > e; e += d)
                f = Ud(e, a[e], a[e + 1], f);
        else
            for (e = c - d; e >= b; e -= d)
                f = Ud(e, a[e], a[e + 1], f);
        return f && Qd(f, f.next) && (Vd(f),
        f = f.next),
        f
    }
    function Hd(a, b) {
        if (!a)
            return a;
        b || (b = a);
        do {
            var c = !1;
            if (a.steiner || !Qd(a, a.next) && 0 !== Pd(a.prev, a, a.next))
                a = a.next;
            else {
                if (Vd(a),
                a = b = a.prev,
                a === a.next)
                    break;
                c = !0
            }
        } while (c || a !== b);
        return b
    }
    function Id(a, b, c, d, e, f, g) {
        if (a) {
            if (!g && f) {
                var h = a
                  , i = h;
                do
                    null === i.z && (i.z = Md(i.x, i.y, d, e, f)),
                    i.prevZ = i.prev,
                    i = i.nextZ = i.next;
                while (i !== h);
                i.prevZ.nextZ = null,
                i.prevZ = null,
                h = i;
                var j, k, l, m, n = 1;
                do {
                    i = h;
                    var o = h = null;
                    for (k = 0; i; ) {
                        k++;
                        var p = i;
                        for (j = l = 0; n > j && (l++,
                        p = p.nextZ); j++)
                            ;
                        for (m = n; l > 0 || m > 0 && p; )
                            0 !== l && (0 === m || !p || i.z <= p.z) ? (j = i,
                            i = i.nextZ,
                            l--) : (j = p,
                            p = p.nextZ,
                            m--),
                            o ? o.nextZ = j : h = j,
                            j.prevZ = o,
                            o = j;
                        i = p
                    }
                    o.nextZ = null,
                    n *= 2
                } while (k > 1)
            }
            for (h = a; a.prev !== a.next; ) {
                if (i = a.prev,
                p = a.next,
                f)
                    o = Jd(a, d, e, f);
                else
                    a: if (o = a,
                    k = o.prev,
                    l = o,
                    n = o.next,
                    0 <= Pd(k, l, n))
                        o = !1;
                    else {
                        for (j = o.next.next; j !== o.prev; ) {
                            if (Od(k.x, k.y, l.x, l.y, n.x, n.y, j.x, j.y) && 0 <= Pd(j.prev, j, j.next)) {
                                o = !1;
                                break a
                            }
                            j = j.next
                        }
                        o = !0
                    }
                if (o)
                    b.push(i.i / c),
                    b.push(a.i / c),
                    b.push(p.i / c),
                    Vd(a),
                    h = a = p.next;
                else if (a = p,
                a === h) {
                    if (g) {
                        if (1 === g) {
                            g = b,
                            h = c,
                            i = a;
                            do
                                p = i.prev,
                                o = i.next.next,
                                !Qd(p, o) && Rd(p, i, i.next, o) && Sd(p, o) && Sd(o, p) && (g.push(p.i / h),
                                g.push(i.i / h),
                                g.push(o.i / h),
                                Vd(i),
                                Vd(i.next),
                                i = a = o),
                                i = i.next;
                            while (i !== a);
                            a = i,
                            Id(a, b, c, d, e, f, 2)
                        } else if (2 === g)
                            a: {
                                g = a;
                                do {
                                    for (h = g.next.next; h !== g.prev; ) {
                                        if (i = g.i !== h.i) {
                                            if (i = g,
                                            p = h,
                                            o = i.next.i !== p.i && i.prev.i !== p.i) {
                                                b: {
                                                    o = i;
                                                    do {
                                                        if (o.i !== i.i && o.next.i !== i.i && o.i !== p.i && o.next.i !== p.i && Rd(o, o.next, i, p)) {
                                                            o = !0;
                                                            break b
                                                        }
                                                        o = o.next
                                                    } while (o !== i);
                                                    o = !1
                                                }
                                                o = !o
                                            }
                                            if (o = o && Sd(i, p) && Sd(p, i)) {
                                                o = i,
                                                k = !1,
                                                l = (i.x + p.x) / 2,
                                                p = (i.y + p.y) / 2;
                                                do
                                                    o.y > p != o.next.y > p && o.next.y !== o.y && l < (o.next.x - o.x) * (p - o.y) / (o.next.y - o.y) + o.x && (k = !k),
                                                    o = o.next;
                                                while (o !== i);
                                                o = k
                                            }
                                            i = o
                                        }
                                        if (i) {
                                            a = Td(g, h),
                                            g = Hd(g, g.next),
                                            a = Hd(a, a.next),
                                            Id(g, b, c, d, e, f),
                                            Id(a, b, c, d, e, f);
                                            break a
                                        }
                                        h = h.next
                                    }
                                    g = g.next
                                } while (g !== a)
                            }
                    } else
                        Id(Hd(a), b, c, d, e, f, 1);
                    break
                }
            }
        }
    }
    function Jd(a, b, c, d) {
        var e = a.prev
          , f = a.next;
        if (0 <= Pd(e, a, f))
            return !1;
        var g = e.x > a.x ? e.x > f.x ? e.x : f.x : a.x > f.x ? a.x : f.x
          , h = e.y > a.y ? e.y > f.y ? e.y : f.y : a.y > f.y ? a.y : f.y
          , i = Md(e.x < a.x ? e.x < f.x ? e.x : f.x : a.x < f.x ? a.x : f.x, e.y < a.y ? e.y < f.y ? e.y : f.y : a.y < f.y ? a.y : f.y, b, c, d);
        for (b = Md(g, h, b, c, d),
        c = a.prevZ,
        d = a.nextZ; c && c.z >= i && d && d.z <= b; ) {
            if (c !== a.prev && c !== a.next && Od(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= Pd(c.prev, c, c.next))
                return !1;
            if (c = c.prevZ,
            d !== a.prev && d !== a.next && Od(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= Pd(d.prev, d, d.next))
                return !1;
            d = d.nextZ
        }
        for (; c && c.z >= i; ) {
            if (c !== a.prev && c !== a.next && Od(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= Pd(c.prev, c, c.next))
                return !1;
            c = c.prevZ
        }
        for (; d && d.z <= b; ) {
            if (d !== a.prev && d !== a.next && Od(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= Pd(d.prev, d, d.next))
                return !1;
            d = d.nextZ
        }
        return !0
    }
    function Kd(a, b) {
        return a.x - b.x
    }
    function Ld(a, b) {
        var c = b
          , d = a.x
          , e = a.y
          , f = -1 / 0;
        do {
            if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
                var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                if (d >= g && g > f) {
                    if (f = g,
                    g === d) {
                        if (e === c.y)
                            return c;
                        if (e === c.next.y)
                            return c.next
                    }
                    var h = c.x < c.next.x ? c : c.next
                }
            }
            c = c.next
        } while (c !== b);
        if (!h)
            return null;
        if (d === f)
            return h.prev;
        b = h,
        g = h.x;
        var i = h.y
          , j = 1 / 0;
        for (c = h.next; c !== b; ) {
            if (d >= c.x && c.x >= g && d !== c.x && Od(i > e ? d : f, e, g, i, i > e ? f : d, e, c.x, c.y)) {
                var k = Math.abs(e - c.y) / (d - c.x);
                (j > k || k === j && c.x > h.x) && Sd(c, a) && (h = c,
                j = k)
            }
            c = c.next
        }
        return h
    }
    function Md(a, b, c, d, e) {
        return a = 32767 * (a - c) * e,
        b = 32767 * (b - d) * e,
        a = 16711935 & (a | a << 8),
        a = 252645135 & (a | a << 4),
        a = 858993459 & (a | a << 2),
        b = 16711935 & (b | b << 8),
        b = 252645135 & (b | b << 4),
        b = 858993459 & (b | b << 2),
        1431655765 & (a | a << 1) | (1431655765 & (b | b << 1)) << 1
    }
    function Nd(a) {
        var b = a
          , c = a;
        do
            (b.x < c.x || b.x === c.x && b.y < c.y) && (c = b),
            b = b.next;
        while (b !== a);
        return c
    }
    function Od(a, b, c, d, e, f, g, h) {
        return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0
    }
    function Pd(a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)
    }
    function Qd(a, b) {
        return a.x === b.x && a.y === b.y
    }
    function Rd(a, b, c, d) {
        return Qd(a, c) && Qd(b, d) || Qd(a, d) && Qd(c, b) ? !0 : 0 < Pd(a, b, c) != 0 < Pd(a, b, d) && 0 < Pd(c, d, a) != 0 < Pd(c, d, b)
    }
    function Sd(a, b) {
        return 0 > Pd(a.prev, a, a.next) ? 0 <= Pd(a, b, a.next) && 0 <= Pd(a, a.prev, b) : 0 > Pd(a, b, a.prev) || 0 > Pd(a, a.next, b)
    }
    function Td(a, b) {
        var c = new Wd(a.i,a.x,a.y)
          , d = new Wd(b.i,b.x,b.y)
          , e = a.next
          , f = b.prev;
        return a.next = b,
        b.prev = a,
        c.next = e,
        e.prev = c,
        d.next = c,
        c.prev = d,
        f.next = d,
        d.prev = f,
        d
    }
    function Ud(a, b, c, d) {
        return a = new Wd(a,b,c),
        d ? (a.next = d.next,
        a.prev = d,
        d.next.prev = a,
        d.next = a) : (a.prev = a,
        a.next = a),
        a
    }
    function Vd(a) {
        a.next.prev = a.prev,
        a.prev.next = a.next,
        a.prevZ && (a.prevZ.nextZ = a.nextZ),
        a.nextZ && (a.nextZ.prevZ = a.prevZ)
    }
    function Wd(a, b, c) {
        this.i = a,
        this.x = b,
        this.y = c,
        this.nextZ = this.prevZ = this.z = this.next = this.prev = null,
        this.steiner = !1
    }
    function Xd(a) {
        var b = a.length;
        b > 2 && a[b - 1].equals(a[0]) && a.pop()
    }
    function Yd(a, b) {
        for (var c = 0; c < b.length; c++)
            a.push(b[c].x),
            a.push(b[c].y)
    }
    function Zd(a, b) {
        S.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: a,
            options: b
        },
        this.fromBufferGeometry(new $d(a,b)),
        this.mergeVertices()
    }
    function $d(a, b) {
        function d(a) {
            function d(a, b, c) {
                return b || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                b.clone().multiplyScalar(c).add(a)
            }
            function i(a, b, d) {
                var e = a.x - b.x
                  , f = a.y - b.y
                  , g = d.x - a.x
                  , h = d.y - a.y
                  , i = e * e + f * f;
                if (Math.abs(e * h - f * g) > Number.EPSILON) {
                    var j = Math.sqrt(i)
                      , k = Math.sqrt(g * g + h * h);
                    if (i = b.x - f / j,
                    b = b.y + e / j,
                    h = ((d.x - h / k - i) * h - (d.y + g / k - b) * g) / (e * h - f * g),
                    g = i + e * h - a.x,
                    e = b + f * h - a.y,
                    f = g * g + e * e,
                    2 >= f)
                        return new c(g,e);
                    f = Math.sqrt(f / 2)
                } else
                    a = !1,
                    e > Number.EPSILON ? g > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? g < -Number.EPSILON && (a = !0) : Math.sign(f) === Math.sign(h) && (a = !0),
                    a ? (g = -f,
                    f = Math.sqrt(i)) : (g = e,
                    e = f,
                    f = Math.sqrt(i / 2));
                return new c(g / f,e / f)
            }
            function j(a, b) {
                for (P = a.length; 0 <= --P; ) {
                    var c = P
                      , d = P - 1;
                    0 > d && (d = a.length - 1);
                    var e, h = q + 2 * w;
                    for (e = 0; h > e; e++) {
                        var i = N * e
                          , j = N * (e + 1)
                          , k = b + d + i
                          , l = b + d + j;
                        j = b + c + j,
                        m(b + c + i),
                        m(k),
                        m(j),
                        m(k),
                        m(l),
                        m(j),
                        i = g.length / 3,
                        i = y.generateSideWallUV(f, g, i - 6, i - 3, i - 2, i - 1),
                        n(i[0]),
                        n(i[1]),
                        n(i[3]),
                        n(i[1]),
                        n(i[2]),
                        n(i[3])
                    }
                }
            }
            function k(a, b, c) {
                o.push(a),
                o.push(b),
                o.push(c)
            }
            function l(a, b, c) {
                m(a),
                m(b),
                m(c),
                a = g.length / 3,
                a = y.generateTopUV(f, g, a - 3, a - 2, a - 1),
                n(a[0]),
                n(a[1]),
                n(a[2])
            }
            function m(a) {
                g.push(o[3 * a]),
                g.push(o[3 * a + 1]),
                g.push(o[3 * a + 2])
            }
            function n(a) {
                h.push(a.x),
                h.push(a.y)
            }
            var o = []
              , p = void 0 !== b.curveSegments ? b.curveSegments : 12
              , q = void 0 !== b.steps ? b.steps : 1
              , r = void 0 !== b.depth ? b.depth : 100
              , s = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0
              , t = void 0 !== b.bevelThickness ? b.bevelThickness : 6
              , u = void 0 !== b.bevelSize ? b.bevelSize : t - 2
              , v = void 0 !== b.bevelOffset ? b.bevelOffset : 0
              , w = void 0 !== b.bevelSegments ? b.bevelSegments : 3
              , x = b.extrudePath
              , y = void 0 !== b.UVGenerator ? b.UVGenerator : Jj;
            void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            r = b.amount);
            var z = !1;
            if (x) {
                var A = x.getSpacedPoints(q);
                z = !0,
                s = !1;
                var B = x.computeFrenetFrames(q, !1)
                  , C = new e
                  , D = new e
                  , E = new e
            }
            s || (v = u = t = w = 0);
            var F;
            p = a.extractPoints(p),
            a = p.shape;
            var G = p.holes;
            if (!Ij.isClockWise(a)) {
                a = a.reverse();
                var H = 0;
                for (F = G.length; F > H; H++) {
                    var I = G[H];
                    Ij.isClockWise(I) && (G[H] = I.reverse())
                }
            }
            var J = Ij.triangulateShape(a, G)
              , K = a;
            for (H = 0,
            F = G.length; F > H; H++)
                I = G[H],
                a = a.concat(I);
            var L, M, N = a.length, O = J.length;
            p = [];
            var P = 0
              , Q = K.length
              , R = Q - 1;
            for (L = P + 1; Q > P; P++,
            R++,
            L++)
                R === Q && (R = 0),
                L === Q && (L = 0),
                p[P] = i(K[P], K[R], K[L]);
            x = [];
            var S = p.concat();
            for (H = 0,
            F = G.length; F > H; H++) {
                I = G[H];
                var T = [];
                for (P = 0,
                Q = I.length,
                R = Q - 1,
                L = P + 1; Q > P; P++,
                R++,
                L++)
                    R === Q && (R = 0),
                    L === Q && (L = 0),
                    T[P] = i(I[P], I[R], I[L]);
                x.push(T),
                S = S.concat(T)
            }
            for (R = 0; w > R; R++) {
                Q = R / w;
                var U = t * Math.cos(Q * Math.PI / 2);
                for (L = u * Math.sin(Q * Math.PI / 2) + v,
                P = 0,
                Q = K.length; Q > P; P++) {
                    var V = d(K[P], p[P], L);
                    k(V.x, V.y, -U)
                }
                for (H = 0,
                F = G.length; F > H; H++)
                    for (I = G[H],
                    T = x[H],
                    P = 0,
                    Q = I.length; Q > P; P++)
                        V = d(I[P], T[P], L),
                        k(V.x, V.y, -U)
            }
            for (L = u + v,
            P = 0; N > P; P++)
                V = s ? d(a[P], S[P], L) : a[P],
                z ? (D.copy(B.normals[0]).multiplyScalar(V.x),
                C.copy(B.binormals[0]).multiplyScalar(V.y),
                E.copy(A[0]).add(D).add(C),
                k(E.x, E.y, E.z)) : k(V.x, V.y, 0);
            for (Q = 1; q >= Q; Q++)
                for (P = 0; N > P; P++)
                    V = s ? d(a[P], S[P], L) : a[P],
                    z ? (D.copy(B.normals[Q]).multiplyScalar(V.x),
                    C.copy(B.binormals[Q]).multiplyScalar(V.y),
                    E.copy(A[Q]).add(D).add(C),
                    k(E.x, E.y, E.z)) : k(V.x, V.y, r / q * Q);
            for (R = w - 1; R >= 0; R--) {
                for (Q = R / w,
                U = t * Math.cos(Q * Math.PI / 2),
                L = u * Math.sin(Q * Math.PI / 2) + v,
                P = 0,
                Q = K.length; Q > P; P++)
                    V = d(K[P], p[P], L),
                    k(V.x, V.y, r + U);
                for (H = 0,
                F = G.length; F > H; H++)
                    for (I = G[H],
                    T = x[H],
                    P = 0,
                    Q = I.length; Q > P; P++)
                        V = d(I[P], T[P], L),
                        z ? k(V.x, V.y + A[q - 1].y, A[q - 1].x + U) : k(V.x, V.y, r + U)
            }
            !function() {
                var a = g.length / 3;
                if (s) {
                    var b = 0 * N;
                    for (P = 0; O > P; P++)
                        M = J[P],
                        l(M[2] + b, M[1] + b, M[0] + b);
                    for (b = N * (q + 2 * w),
                    P = 0; O > P; P++)
                        M = J[P],
                        l(M[0] + b, M[1] + b, M[2] + b)
                } else {
                    for (P = 0; O > P; P++)
                        M = J[P],
                        l(M[2], M[1], M[0]);
                    for (P = 0; O > P; P++)
                        M = J[P],
                        l(M[0] + N * q, M[1] + N * q, M[2] + N * q)
                }
                f.addGroup(a, g.length / 3 - a, 0)
            }(),
            function() {
                var a = g.length / 3
                  , b = 0;
                for (j(K, b),
                b += K.length,
                H = 0,
                F = G.length; F > H; H++)
                    I = G[H],
                    j(I, b),
                    b += I.length;
                f.addGroup(a, g.length / 3 - a, 1)
            }()
        }
        O.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: a,
            options: b
        },
        a = Array.isArray(a) ? a : [a];
        for (var f = this, g = [], h = [], i = 0, j = a.length; j > i; i++)
            d(a[i]);
        this.setAttribute("position", new K(g,3)),
        this.setAttribute("uv", new K(h,2)),
        this.computeVertexNormals()
    }
    function _d(a, b, c) {
        if (c.shapes = [],
        Array.isArray(a))
            for (var d = 0, e = a.length; e > d; d++)
                c.shapes.push(a[d].uuid);
        else
            c.shapes.push(a.uuid);
        return void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON()),
        c
    }
    function ae(a, b) {
        S.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: a,
            parameters: b
        },
        this.fromBufferGeometry(new be(a,b)),
        this.mergeVertices()
    }
    function be(a, b) {
        b = b || {};
        var c = b.font;
        return c && c.isFont ? (a = c.generateShapes(a, b.size),
        b.depth = void 0 !== b.height ? b.height : 50,
        void 0 === b.bevelThickness && (b.bevelThickness = 10),
        void 0 === b.bevelSize && (b.bevelSize = 8),
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1),
        $d.call(this, a, b),
        this.type = "TextBufferGeometry",
        void 0) : (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
        new S)
    }
    function ce(a, b, c, d, e, f, g) {
        S.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        },
        this.fromBufferGeometry(new de(a,b,c,d,e,f,g)),
        this.mergeVertices()
    }
    function de(a, b, c, d, f, g, h) {
        O.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: f,
            thetaStart: g,
            thetaLength: h
        },
        a = a || 1,
        b = Math.max(3, Math.floor(b) || 8),
        c = Math.max(2, Math.floor(c) || 6),
        d = void 0 !== d ? d : 0,
        f = void 0 !== f ? f : 2 * Math.PI,
        g = void 0 !== g ? g : 0,
        h = void 0 !== h ? h : Math.PI;
        var i, j, k = Math.min(g + h, Math.PI), l = 0, m = [], n = new e, o = new e, p = [], q = [], r = [], s = [];
        for (j = 0; c >= j; j++) {
            var t = []
              , u = j / c
              , v = 0;
            for (0 == j && 0 == g ? v = .5 / b : j == c && k == Math.PI && (v = -.5 / b),
            i = 0; b >= i; i++) {
                var w = i / b;
                n.x = -a * Math.cos(d + w * f) * Math.sin(g + u * h),
                n.y = a * Math.cos(g + u * h),
                n.z = a * Math.sin(d + w * f) * Math.sin(g + u * h),
                q.push(n.x, n.y, n.z),
                o.copy(n).normalize(),
                r.push(o.x, o.y, o.z),
                s.push(w + v, 1 - u),
                t.push(l++)
            }
            m.push(t)
        }
        for (j = 0; c > j; j++)
            for (i = 0; b > i; i++)
                a = m[j][i + 1],
                d = m[j][i],
                f = m[j + 1][i],
                h = m[j + 1][i + 1],
                (0 !== j || g > 0) && p.push(a, d, h),
                (j !== c - 1 || k < Math.PI) && p.push(d, f, h);
        this.setIndex(p),
        this.setAttribute("position", new K(q,3)),
        this.setAttribute("normal", new K(r,3)),
        this.setAttribute("uv", new K(s,2))
    }
    function ee(a, b, c, d, e, f) {
        S.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        },
        this.fromBufferGeometry(new fe(a,b,c,d,e,f)),
        this.mergeVertices()
    }
    function fe(a, b, d, f, g, h) {
        O.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: d,
            phiSegments: f,
            thetaStart: g,
            thetaLength: h
        },
        a = a || .5,
        b = b || 1,
        g = void 0 !== g ? g : 0,
        h = void 0 !== h ? h : 2 * Math.PI,
        d = void 0 !== d ? Math.max(3, d) : 8,
        f = void 0 !== f ? Math.max(1, f) : 1;
        var i, j, k = [], l = [], m = [], n = [], o = a, p = (b - a) / f, q = new e, r = new c;
        for (i = 0; f >= i; i++) {
            for (j = 0; d >= j; j++)
                a = g + j / d * h,
                q.x = o * Math.cos(a),
                q.y = o * Math.sin(a),
                l.push(q.x, q.y, q.z),
                m.push(0, 0, 1),
                r.x = (q.x / b + 1) / 2,
                r.y = (q.y / b + 1) / 2,
                n.push(r.x, r.y);
            o += p
        }
        for (i = 0; f > i; i++)
            for (b = i * (d + 1),
            j = 0; d > j; j++)
                a = j + b,
                g = a + d + 1,
                h = a + d + 2,
                o = a + 1,
                k.push(a, g, o),
                k.push(g, h, o);
        this.setIndex(k),
        this.setAttribute("position", new K(l,3)),
        this.setAttribute("normal", new K(m,3)),
        this.setAttribute("uv", new K(n,2))
    }
    function ge(a, b, c, d) {
        S.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
        },
        this.fromBufferGeometry(new he(a,b,c,d)),
        this.mergeVertices()
    }
    function he(a, b, d, f) {
        O.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: a,
            segments: b,
            phiStart: d,
            phiLength: f
        },
        b = Math.floor(b) || 12,
        d = d || 0,
        f = f || 2 * Math.PI,
        f = Sg.clamp(f, 0, 2 * Math.PI);
        var g, h = [], i = [], j = [], k = 1 / b, l = new e, m = new c;
        for (g = 0; b >= g; g++) {
            var n = d + g * k * f
              , o = Math.sin(n)
              , p = Math.cos(n);
            for (n = 0; n <= a.length - 1; n++)
                l.x = a[n].x * o,
                l.y = a[n].y,
                l.z = a[n].x * p,
                i.push(l.x, l.y, l.z),
                m.x = g / b,
                m.y = n / (a.length - 1),
                j.push(m.x, m.y)
        }
        for (g = 0; b > g; g++)
            for (n = 0; n < a.length - 1; n++)
                d = n + g * a.length,
                k = d + a.length,
                l = d + a.length + 1,
                m = d + 1,
                h.push(d, k, m),
                h.push(k, l, m);
        if (this.setIndex(h),
        this.setAttribute("position", new K(i,3)),
        this.setAttribute("uv", new K(j,2)),
        this.computeVertexNormals(),
        f === 2 * Math.PI)
            for (f = this.attributes.normal.array,
            h = new e,
            i = new e,
            j = new e,
            d = b * a.length * 3,
            n = g = 0; g < a.length; g++,
            n += 3)
                h.x = f[n + 0],
                h.y = f[n + 1],
                h.z = f[n + 2],
                i.x = f[d + n + 0],
                i.y = f[d + n + 1],
                i.z = f[d + n + 2],
                j.addVectors(h, i).normalize(),
                f[n + 0] = f[d + n + 0] = j.x,
                f[n + 1] = f[d + n + 1] = j.y,
                f[n + 2] = f[d + n + 2] = j.z
    }
    function ie(a, b) {
        S.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        b = b.curveSegments),
        this.parameters = {
            shapes: a,
            curveSegments: b
        },
        this.fromBufferGeometry(new je(a,b)),
        this.mergeVertices()
    }
    function je(a, b) {
        function c(a) {
            var c, h = e.length / 3;
            a = a.extractPoints(b);
            var j = a.shape
              , k = a.holes;
            for (!1 === Ij.isClockWise(j) && (j = j.reverse()),
            a = 0,
            c = k.length; c > a; a++) {
                var l = k[a];
                !0 === Ij.isClockWise(l) && (k[a] = l.reverse())
            }
            var m = Ij.triangulateShape(j, k);
            for (a = 0,
            c = k.length; c > a; a++)
                l = k[a],
                j = j.concat(l);
            for (a = 0,
            c = j.length; c > a; a++)
                l = j[a],
                e.push(l.x, l.y, 0),
                f.push(0, 0, 1),
                g.push(l.x, l.y);
            for (a = 0,
            c = m.length; c > a; a++)
                j = m[a],
                d.push(j[0] + h, j[1] + h, j[2] + h),
                i += 3
        }
        O.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: a,
            curveSegments: b
        },
        b = b || 12;
        var d = []
          , e = []
          , f = []
          , g = []
          , h = 0
          , i = 0;
        if (!1 === Array.isArray(a))
            c(a);
        else
            for (var j = 0; j < a.length; j++)
                c(a[j]),
                this.addGroup(h, i, j),
                h += i,
                i = 0;
        this.setIndex(d),
        this.setAttribute("position", new K(e,3)),
        this.setAttribute("normal", new K(f,3)),
        this.setAttribute("uv", new K(g,2))
    }
    function ke(a, b) {
        if (b.shapes = [],
        Array.isArray(a))
            for (var c = 0, d = a.length; d > c; c++)
                b.shapes.push(a[c].uuid);
        else
            b.shapes.push(a.uuid);
        return b
    }
    function le(a, b) {
        O.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: b
        };
        var c = [];
        b = Math.cos(Sg.DEG2RAD * (void 0 !== b ? b : 1));
        var d = [0, 0]
          , e = {}
          , f = ["a", "b", "c"];
        if (a.isBufferGeometry) {
            var g = new S;
            g.fromBufferGeometry(a)
        } else
            g = a.clone();
        g.mergeVertices(),
        g.computeFaceNormals(),
        a = g.vertices,
        g = g.faces;
        for (var h = 0, i = g.length; i > h; h++)
            for (var j = g[h], k = 0; 3 > k; k++) {
                var l = j[f[k]]
                  , m = j[f[(k + 1) % 3]];
                d[0] = Math.min(l, m),
                d[1] = Math.max(l, m),
                l = d[0] + "," + d[1],
                void 0 === e[l] ? e[l] = {
                    index1: d[0],
                    index2: d[1],
                    face1: h,
                    face2: void 0
                } : e[l].face2 = h
            }
        for (l in e)
            d = e[l],
            (void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) && (f = a[d.index1],
            c.push(f.x, f.y, f.z),
            f = a[d.index2],
            c.push(f.x, f.y, f.z));
        this.setAttribute("position", new K(c,3))
    }
    function me(a, b, c, d, e, f, g, h) {
        S.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        },
        this.fromBufferGeometry(new ne(a,b,c,d,e,f,g,h)),
        this.mergeVertices()
    }
    function ne(a, b, d, f, g, h, i, j) {
        function k(d) {
            var g, h = new c, k = new e, r = 0, u = !0 === d ? a : b, v = !0 === d ? 1 : -1, w = q;
            for (g = 1; f >= g; g++)
                n.push(0, s * v, 0),
                o.push(0, v, 0),
                p.push(.5, .5),
                q++;
            var x = q;
            for (g = 0; f >= g; g++) {
                var y = g / f * j + i
                  , z = Math.cos(y);
                y = Math.sin(y),
                k.x = u * y,
                k.y = s * v,
                k.z = u * z,
                n.push(k.x, k.y, k.z),
                o.push(0, v, 0),
                h.x = .5 * z + .5,
                h.y = .5 * y * v + .5,
                p.push(h.x, h.y),
                q++
            }
            for (g = 0; f > g; g++)
                h = w + g,
                k = x + g,
                !0 === d ? m.push(k, k + 1, h) : m.push(k + 1, k, h),
                r += 3;
            l.addGroup(t, r, !0 === d ? 1 : 2),
            t += r
        }
        O.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: d,
            radialSegments: f,
            heightSegments: g,
            openEnded: h,
            thetaStart: i,
            thetaLength: j
        };
        var l = this;
        a = void 0 !== a ? a : 1,
        b = void 0 !== b ? b : 1,
        d = d || 1,
        f = Math.floor(f) || 8,
        g = Math.floor(g) || 1,
        h = void 0 !== h ? h : !1,
        i = void 0 !== i ? i : 0,
        j = void 0 !== j ? j : 2 * Math.PI;
        var m = []
          , n = []
          , o = []
          , p = []
          , q = 0
          , r = []
          , s = d / 2
          , t = 0;
        !function() {
            var c, h, k = new e, u = new e, v = 0, w = (b - a) / d;
            for (h = 0; g >= h; h++) {
                var x = []
                  , y = h / g
                  , z = y * (b - a) + a;
                for (c = 0; f >= c; c++) {
                    var A = c / f
                      , B = A * j + i
                      , C = Math.sin(B);
                    B = Math.cos(B),
                    u.x = z * C,
                    u.y = -y * d + s,
                    u.z = z * B,
                    n.push(u.x, u.y, u.z),
                    k.set(C, w, B).normalize(),
                    o.push(k.x, k.y, k.z),
                    p.push(A, 1 - y),
                    x.push(q++)
                }
                r.push(x)
            }
            for (c = 0; f > c; c++)
                for (h = 0; g > h; h++)
                    k = r[h + 1][c],
                    u = r[h + 1][c + 1],
                    w = r[h][c + 1],
                    m.push(r[h][c], k, w),
                    m.push(k, u, w),
                    v += 6;
            l.addGroup(t, v, 0),
            t += v
        }(),
        !1 === h && (a > 0 && k(!0),
        b > 0 && k(!1)),
        this.setIndex(m),
        this.setAttribute("position", new K(n,3)),
        this.setAttribute("normal", new K(o,3)),
        this.setAttribute("uv", new K(p,2))
    }
    function oe(a, b, c, d, e, f, g) {
        me.call(this, 0, a, b, c, d, e, f, g),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }
    function pe(a, b, c, d, e, f, g) {
        ne.call(this, 0, a, b, c, d, e, f, g),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }
    function qe(a, b, c, d) {
        S.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        },
        this.fromBufferGeometry(new re(a,b,c,d)),
        this.mergeVertices()
    }
    function re(a, b, d, f) {
        O.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: a,
            segments: b,
            thetaStart: d,
            thetaLength: f
        },
        a = a || 1,
        b = void 0 !== b ? Math.max(3, b) : 8,
        d = void 0 !== d ? d : 0,
        f = void 0 !== f ? f : 2 * Math.PI;
        var g, h = [], i = [], j = [], k = [], l = new e, m = new c;
        i.push(0, 0, 0),
        j.push(0, 0, 1),
        k.push(.5, .5);
        var n = 0;
        for (g = 3; b >= n; n++,
        g += 3) {
            var o = d + n / b * f;
            l.x = a * Math.cos(o),
            l.y = a * Math.sin(o),
            i.push(l.x, l.y, l.z),
            j.push(0, 0, 1),
            m.x = (i[g] / a + 1) / 2,
            m.y = (i[g + 1] / a + 1) / 2,
            k.push(m.x, m.y)
        }
        for (g = 1; b >= g; g++)
            h.push(g, g + 1, 0);
        this.setIndex(h),
        this.setAttribute("position", new K(i,3)),
        this.setAttribute("normal", new K(j,3)),
        this.setAttribute("uv", new K(k,2))
    }
    function se(a) {
        A.call(this),
        this.type = "ShadowMaterial",
        this.color = new v(0),
        this.transparent = !0,
        this.setValues(a)
    }
    function te(a) {
        V.call(this, a),
        this.type = "RawShaderMaterial"
    }
    function ue(a) {
        A.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new v(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new v(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new c(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function ve(a) {
        ue.call(this),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearcoatRoughness = this.clearcoat = 0,
        this.sheen = null,
        this.clearcoatNormalScale = new c(1,1),
        this.clearcoatNormalMap = null,
        this.transparency = 0,
        this.setValues(a)
    }
    function we(a) {
        A.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new v(16777215),
        this.specular = new v(1118481),
        this.shininess = 30,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new v(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new c(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function xe(a) {
        A.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new v(16777215),
        this.specular = new v(1118481),
        this.shininess = 30,
        this.lightMap = this.gradientMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new v(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new c(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = this.specularMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function ye(a) {
        A.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new c(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.fog = !1,
        this.setValues(a)
    }
    function ze(a) {
        A.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new v(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new v(0),
        this.emissiveIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function Ae(a) {
        A.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new v(16777215),
        this.bumpMap = this.map = this.matcap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new c(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(a)
    }
    function Be(a) {
        cd.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(a)
    }
    function Ce(a, b, c, d) {
        this.parameterPositions = a,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== d ? d : new b.constructor(c),
        this.sampleValues = b,
        this.valueSize = c
    }
    function De(a, b, c, d) {
        Ce.call(this, a, b, c, d),
        this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }
    function Ee(a, b, c, d) {
        Ce.call(this, a, b, c, d)
    }
    function Fe(a, b, c, d) {
        Ce.call(this, a, b, c, d)
    }
    function Ge(a, b, c, d) {
        if (void 0 === a)
            throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === b || 0 === b.length)
            throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
        this.name = a,
        this.times = Mj.convertArray(b, this.TimeBufferType),
        this.values = Mj.convertArray(c, this.ValueBufferType),
        this.setInterpolation(d || this.DefaultInterpolation)
    }
    function He(a, b, c) {
        Ge.call(this, a, b, c)
    }
    function Ie(a, b, c, d) {
        Ge.call(this, a, b, c, d)
    }
    function Je(a, b, c, d) {
        Ge.call(this, a, b, c, d)
    }
    function Ke(a, b, c, d) {
        Ce.call(this, a, b, c, d)
    }
    function Le(a, b, c, d) {
        Ge.call(this, a, b, c, d)
    }
    function Me(a, b, c, d) {
        Ge.call(this, a, b, c, d)
    }
    function Ne(a, b, c, d) {
        Ge.call(this, a, b, c, d)
    }
    function Oe(a, b, c) {
        this.name = a,
        this.tracks = c,
        this.duration = void 0 !== b ? b : -1,
        this.uuid = Sg.generateUUID(),
        0 > this.duration && this.resetDuration()
    }
    function Pe(a) {
        switch (a.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Je;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Ne;
        case "color":
            return Ie;
        case "quaternion":
            return Le;
        case "bool":
        case "boolean":
            return He;
        case "string":
            return Me
        }
        throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a)
    }
    function Qe(a) {
        if (void 0 === a.type)
            throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var b = Pe(a.type);
        if (void 0 === a.times) {
            var c = []
              , d = [];
            Mj.flattenJSON(a.keys, c, d, "value"),
            a.times = c,
            a.values = d
        }
        return void 0 !== b.parse ? b.parse(a) : new b(a.name,a.times,a.values,a.interpolation)
    }
    function Re(a, b, c) {
        var d = this
          , e = !1
          , f = 0
          , g = 0
          , h = void 0
          , i = [];
        this.onStart = void 0,
        this.onLoad = a,
        this.onProgress = b,
        this.onError = c,
        this.itemStart = function(a) {
            g++,
            !1 === e && void 0 !== d.onStart && d.onStart(a, f, g),
            e = !0
        }
        ,
        this.itemEnd = function(a) {
            f++,
            void 0 !== d.onProgress && d.onProgress(a, f, g),
            f === g && (e = !1,
            void 0 !== d.onLoad) && d.onLoad()
        }
        ,
        this.itemError = function(a) {
            void 0 !== d.onError && d.onError(a)
        }
        ,
        this.resolveURL = function(a) {
            return h ? h(a) : a
        }
        ,
        this.setURLModifier = function(a) {
            return h = a,
            this
        }
        ,
        this.addHandler = function(a, b) {
            return i.push(a, b),
            this
        }
        ,
        this.removeHandler = function(a) {
            return a = i.indexOf(a),
            -1 !== a && i.splice(a, 2),
            this
        }
        ,
        this.getHandler = function(a) {
            for (var b = 0, c = i.length; c > b; b += 2) {
                var d = i[b]
                  , e = i[b + 1];
                if (d.global && (d.lastIndex = 0),
                d.test(a))
                    return e
            }
            return null
        }
    }
    function Se(a) {
        this.manager = void 0 !== a ? a : Oj,
        this.crossOrigin = "anonymous",
        this.resourcePath = this.path = ""
    }
    function Te(a) {
        Se.call(this, a)
    }
    function Ue(a) {
        Se.call(this, a)
    }
    function Ve(a) {
        Se.call(this, a)
    }
    function We(a) {
        Se.call(this, a)
    }
    function Xe(a) {
        Se.call(this, a)
    }
    function Ye(a) {
        Se.call(this, a)
    }
    function Ze(a) {
        Se.call(this, a)
    }
    function $e() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function _e(a, b, c, d, e, f, g, h) {
        $e.call(this),
        this.type = "EllipseCurve",
        this.aX = a || 0,
        this.aY = b || 0,
        this.xRadius = c || 1,
        this.yRadius = d || 1,
        this.aStartAngle = e || 0,
        this.aEndAngle = f || 2 * Math.PI,
        this.aClockwise = g || !1,
        this.aRotation = h || 0
    }
    function af(a, b, c, d, e, f) {
        _e.call(this, a, b, c, c, d, e, f),
        this.type = "ArcCurve"
    }
    function bf() {
        var a = 0
          , b = 0
          , c = 0
          , d = 0;
        return {
            initCatmullRom: function(e, f, g, h, i) {
                e = i * (g - e),
                h = i * (h - f),
                a = f,
                b = e,
                c = -3 * f + 3 * g - 2 * e - h,
                d = 2 * f - 2 * g + e + h
            },
            initNonuniformCatmullRom: function(e, f, g, h, i, j, k) {
                e = ((f - e) / i - (g - e) / (i + j) + (g - f) / j) * j,
                h = ((g - f) / j - (h - f) / (j + k) + (h - g) / k) * j,
                a = f,
                b = e,
                c = -3 * f + 3 * g - 2 * e - h,
                d = 2 * f - 2 * g + e + h
            },
            calc: function(e) {
                var f = e * e;
                return a + b * e + c * f + d * f * e
            }
        }
    }
    function cf(a, b, c, d) {
        $e.call(this),
        this.type = "CatmullRomCurve3",
        this.points = a || [],
        this.closed = b || !1,
        this.curveType = c || "centripetal",
        this.tension = d || .5
    }
    function df(a, b, c, d, e) {
        b = .5 * (d - b),
        e = .5 * (e - c);
        var f = a * a;
        return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
    }
    function ef(a, b, c, d) {
        var e = 1 - a;
        return e * e * b + 2 * (1 - a) * a * c + a * a * d
    }
    function ff(a, b, c, d, e) {
        var f = 1 - a
          , g = 1 - a;
        return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
    }
    function gf(a, b, d, e) {
        $e.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = a || new c,
        this.v1 = b || new c,
        this.v2 = d || new c,
        this.v3 = e || new c
    }
    function hf(a, b, c, d) {
        $e.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = a || new e,
        this.v1 = b || new e,
        this.v2 = c || new e,
        this.v3 = d || new e
    }
    function jf(a, b) {
        $e.call(this),
        this.type = "LineCurve",
        this.v1 = a || new c,
        this.v2 = b || new c
    }
    function kf(a, b) {
        $e.call(this),
        this.type = "LineCurve3",
        this.v1 = a || new e,
        this.v2 = b || new e
    }
    function lf(a, b, d) {
        $e.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = a || new c,
        this.v1 = b || new c,
        this.v2 = d || new c
    }
    function mf(a, b, c) {
        $e.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = a || new e,
        this.v1 = b || new e,
        this.v2 = c || new e
    }
    function nf(a) {
        $e.call(this),
        this.type = "SplineCurve",
        this.points = a || []
    }
    function of() {
        $e.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function pf(a) {
        of.call(this),
        this.type = "Path",
        this.currentPoint = new c,
        a && this.setFromPoints(a)
    }
    function qf(a) {
        pf.call(this, a),
        this.uuid = Sg.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function rf(a, b) {
        n.call(this),
        this.type = "Light",
        this.color = new v(a),
        this.intensity = void 0 !== b ? b : 1,
        this.receiveShadow = void 0
    }
    function sf(a, b, c) {
        rf.call(this, a, c),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(n.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new v(b)
    }
    function tf(a) {
        this.camera = a,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new c(512,512),
        this.mapPass = this.map = null,
        this.matrix = new k,
        this._frustum = new _,
        this._frameExtents = new c(1,1),
        this._viewportCount = 1,
        this._viewports = [new h(0,0,1,1)]
    }
    function uf() {
        tf.call(this, new X(50,1,.5,500))
    }
    function vf(a, b, c, d, e, f) {
        rf.call(this, a, b),
        this.type = "SpotLight",
        this.position.copy(n.DefaultUp),
        this.updateMatrix(),
        this.target = new n,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(a) {
                this.intensity = a / Math.PI
            }
        }),
        this.distance = void 0 !== c ? c : 0,
        this.angle = void 0 !== d ? d : Math.PI / 3,
        this.penumbra = void 0 !== e ? e : 0,
        this.decay = void 0 !== f ? f : 1,
        this.shadow = new uf
    }
    function wf() {
        tf.call(this, new X(90,1,.5,500)),
        this._frameExtents = new c(4,2),
        this._viewportCount = 6,
        this._viewports = [new h(2,1,1,1), new h(0,1,1,1), new h(3,1,1,1), new h(1,1,1,1), new h(3,0,1,1), new h(1,0,1,1)],
        this._cubeDirections = [new e(1,0,0), new e(-1,0,0), new e(0,0,1), new e(0,0,-1), new e(0,1,0), new e(0,-1,0)],
        this._cubeUps = [new e(0,1,0), new e(0,1,0), new e(0,1,0), new e(0,1,0), new e(0,0,1), new e(0,0,-1)]
    }
    function xf(a, b, c, d) {
        rf.call(this, a, b),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(a) {
                this.intensity = a / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== c ? c : 0,
        this.decay = void 0 !== d ? d : 1,
        this.shadow = new wf
    }
    function yf(a, b, c, d, e, f) {
        W.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== a ? a : -1,
        this.right = void 0 !== b ? b : 1,
        this.top = void 0 !== c ? c : 1,
        this.bottom = void 0 !== d ? d : -1,
        this.near = void 0 !== e ? e : .1,
        this.far = void 0 !== f ? f : 2e3,
        this.updateProjectionMatrix()
    }
    function zf() {
        tf.call(this, new yf(-5,5,5,-5,.5,500))
    }
    function Af(a, b) {
        rf.call(this, a, b),
        this.type = "DirectionalLight",
        this.position.copy(n.DefaultUp),
        this.updateMatrix(),
        this.target = new n,
        this.shadow = new zf
    }
    function Bf(a, b) {
        rf.call(this, a, b),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function Cf(a, b, c, d) {
        rf.call(this, a, b),
        this.type = "RectAreaLight",
        this.width = void 0 !== c ? c : 10,
        this.height = void 0 !== d ? d : 10
    }
    function Df(a) {
        Se.call(this, a),
        this.textures = {}
    }
    function Ef() {
        O.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function Ff(a, b, c, d) {
        "number" == typeof c && (d = c,
        c = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        C.call(this, a, b, c),
        this.meshPerAttribute = d || 1
    }
    function Gf(a) {
        Se.call(this, a)
    }
    function Hf(a) {
        Se.call(this, a)
    }
    function If(a) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        Se.call(this, a),
        this.options = void 0
    }
    function Jf() {
        this.type = "ShapePath",
        this.color = new v,
        this.subPaths = [],
        this.currentPath = null
    }
    function Kf(a) {
        this.type = "Font",
        this.data = a
    }
    function Lf(a) {
        Se.call(this, a)
    }
    function Mf(a) {
        Se.call(this, a)
    }
    function Nf() {
        this.coefficients = [];
        for (var a = 0; 9 > a; a++)
            this.coefficients.push(new e)
    }
    function Of(a, b) {
        rf.call(this, void 0, b),
        this.sh = void 0 !== a ? a : new Nf
    }
    function Pf(a, b, c) {
        Of.call(this, void 0, c),
        a = (new v).set(a),
        c = (new v).set(b),
        b = new e(a.r,a.g,a.b),
        a = new e(c.r,c.g,c.b),
        c = Math.sqrt(Math.PI);
        var d = c * Math.sqrt(.75);
        this.sh.coefficients[0].copy(b).add(a).multiplyScalar(c),
        this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(d)
    }
    function Qf(a, b) {
        Of.call(this, void 0, b),
        a = (new v).set(a),
        this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    function Rf() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new X,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new X,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    function Sf(a) {
        this.autoStart = void 0 !== a ? a : !0,
        this.elapsedTime = this.oldTime = this.startTime = 0,
        this.running = !1
    }
    function Tf() {
        n.call(this),
        this.type = "AudioListener",
        this.context = _j.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new Sf
    }
    function Uf(a) {
        n.call(this),
        this.type = "Audio",
        this.listener = a,
        this.context = a.context,
        this.gain = this.context.createGain(),
        this.gain.connect(a.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.offset = this.loopEnd = this.loopStart = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this._pausedAt = this._startedAt = 0,
        this.filters = []
    }
    function Vf(a) {
        Uf.call(this, a),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    function Wf(a, b) {
        this.analyser = a.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== b ? b : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        a.getOutput().connect(this.analyser)
    }
    function Xf(a, b, c) {
        switch (this.binding = a,
        this.valueSize = c,
        a = Float64Array,
        b) {
        case "quaternion":
            b = this._slerp;
            break;
        case "string":
        case "bool":
            a = Array,
            b = this._select;
            break;
        default:
            b = this._lerp
        }
        this.buffer = new a(4 * c),
        this._mixBufferRegion = b,
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }
    function Yf(a, b, c) {
        c = c || Zf.parseTrackName(b),
        this._targetGroup = a,
        this._bindings = a.subscribe_(b, c)
    }
    function Zf(a, b, c) {
        this.path = b,
        this.parsedPath = c || Zf.parseTrackName(b),
        this.node = Zf.findNode(a, this.parsedPath.nodeName) || a,
        this.rootNode = a
    }
    function $f() {
        this.uuid = Sg.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var a = {};
        this._indicesByUUID = a;
        for (var b = 0, c = arguments.length; b !== c; ++b)
            a[arguments[b].uuid] = b;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var d = this;
        this.stats = {
            objects: {
                get total() {
                    return d._objects.length
                },
                get inUse() {
                    return this.total - d.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return d._bindings.length
            }
        }
    }
    function _f(a, b, c) {
        this._mixer = a,
        this._clip = b,
        this._localRoot = c || null,
        a = b.tracks,
        b = a.length,
        c = Array(b);
        for (var d = {
            endingStart: 2400,
            endingEnd: 2400
        }, e = 0; e !== b; ++e) {
            var f = a[e].createInterpolant(null);
            c[e] = f,
            f.settings = d
        }
        this._interpolantSettings = d,
        this._interpolants = c,
        this._propertyBindings = Array(b),
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }
    function ag(a) {
        this._root = a,
        this._initMemoryManager(),
        this.time = this._accuIndex = 0,
        this.timeScale = 1
    }
    function bg(a, b) {
        "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        a = b),
        this.value = a
    }
    function cg(a, b, c) {
        Uc.call(this, a, b),
        this.meshPerAttribute = c || 1
    }
    function dg(a, b, c, d) {
        this.ray = new s(a,b),
        this.near = c || 0,
        this.far = d || 1 / 0,
        this.camera = null,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function eg(a, b) {
        return a.distance - b.distance
    }
    function fg(a, b, c, d) {
        if (!1 !== a.visible && (a.raycast(b, c),
        !0 === d)) {
            a = a.children,
            d = 0;
            for (var e = a.length; e > d; d++)
                fg(a[d], b, c, !0)
        }
    }
    function gg(a, b, c) {
        return this.radius = void 0 !== a ? a : 1,
        this.phi = void 0 !== b ? b : 0,
        this.theta = void 0 !== c ? c : 0,
        this
    }
    function hg(a, b, c) {
        return this.radius = void 0 !== a ? a : 1,
        this.theta = void 0 !== b ? b : 0,
        this.y = void 0 !== c ? c : 0,
        this
    }
    function ig(a, b) {
        this.min = void 0 !== a ? a : new c(1 / 0,1 / 0),
        this.max = void 0 !== b ? b : new c(-1 / 0,-1 / 0)
    }
    function jg(a, b) {
        this.start = void 0 !== a ? a : new e,
        this.end = void 0 !== b ? b : new e
    }
    function kg(a) {
        n.call(this),
        this.material = a,
        this.render = function() {}
    }
    function lg(a, b) {
        n.call(this),
        this.light = a,
        this.light.updateMatrixWorld(),
        this.matrix = a.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = b,
        a = new O,
        b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var c = 0, d = 1; 32 > c; c++,
        d++) {
            var e = c / 32 * Math.PI * 2
              , f = d / 32 * Math.PI * 2;
            b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
        }
        a.setAttribute("position", new K(b,3)),
        b = new cd({
            fog: !1
        }),
        this.cone = new ed(a,b),
        this.add(this.cone),
        this.update()
    }
    function mg(a) {
        var b = [];
        a && a.isBone && b.push(a);
        for (var c = 0; c < a.children.length; c++)
            b.push.apply(b, mg(a.children[c]));
        return b
    }
    function ng(a) {
        for (var b = mg(a), c = new O, d = [], e = [], f = new v(0,0,1), g = new v(0,1,0), h = 0; h < b.length; h++) {
            var i = b[h];
            i.parent && i.parent.isBone && (d.push(0, 0, 0),
            d.push(0, 0, 0),
            e.push(f.r, f.g, f.b),
            e.push(g.r, g.g, g.b))
        }
        c.setAttribute("position", new K(d,3)),
        c.setAttribute("color", new K(e,3)),
        d = new cd({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        ed.call(this, c, d),
        this.root = a,
        this.bones = b,
        this.matrix = a.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function og(a, b, c) {
        this.light = a,
        this.light.updateMatrixWorld(),
        this.color = c,
        a = new de(b,4,2),
        b = new B({
            wireframe: !0,
            fog: !1
        }),
        P.call(this, a, b),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function pg(a, b, c) {
        n.call(this),
        this.light = a,
        this.light.updateMatrixWorld(),
        this.matrix = a.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = c,
        a = new vd(b),
        a.rotateY(.5 * Math.PI),
        this.material = new B({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = 2),
        b = a.getAttribute("position"),
        b = new Float32Array(3 * b.count),
        a.setAttribute("color", new C(b,3)),
        this.add(new P(a,this.material)),
        this.update()
    }
    function qg(a, b, c, d) {
        a = a || 10,
        b = b || 10,
        c = new v(void 0 !== c ? c : 4473924),
        d = new v(void 0 !== d ? d : 8947848);
        var e = b / 2
          , f = a / b
          , g = a / 2;
        a = [];
        for (var h = [], i = 0, j = 0, k = -g; b >= i; i++,
        k += f) {
            a.push(-g, 0, k, g, 0, k),
            a.push(k, 0, -g, k, 0, g);
            var l = i === e ? c : d;
            l.toArray(h, j),
            j += 3,
            l.toArray(h, j),
            j += 3,
            l.toArray(h, j),
            j += 3,
            l.toArray(h, j),
            j += 3
        }
        b = new O,
        b.setAttribute("position", new K(a,3)),
        b.setAttribute("color", new K(h,3)),
        c = new cd({
            vertexColors: 2
        }),
        ed.call(this, b, c)
    }
    function rg(a, b, c, d, e, f) {
        a = a || 10,
        b = b || 16,
        c = c || 8,
        d = d || 64,
        e = new v(void 0 !== e ? e : 4473924),
        f = new v(void 0 !== f ? f : 8947848);
        var g, h = [], i = [];
        for (g = 0; b >= g; g++) {
            var j = g / b * 2 * Math.PI
              , k = Math.sin(j) * a;
            j = Math.cos(j) * a,
            h.push(0, 0, 0),
            h.push(k, 0, j);
            var l = 1 & g ? e : f;
            i.push(l.r, l.g, l.b),
            i.push(l.r, l.g, l.b)
        }
        for (g = 0; c >= g; g++) {
            l = 1 & g ? e : f;
            var m = a - a / c * g;
            for (b = 0; d > b; b++)
                j = b / d * 2 * Math.PI,
                k = Math.sin(j) * m,
                j = Math.cos(j) * m,
                h.push(k, 0, j),
                i.push(l.r, l.g, l.b),
                j = (b + 1) / d * 2 * Math.PI,
                k = Math.sin(j) * m,
                j = Math.cos(j) * m,
                h.push(k, 0, j),
                i.push(l.r, l.g, l.b)
        }
        a = new O,
        a.setAttribute("position", new K(h,3)),
        a.setAttribute("color", new K(i,3)),
        h = new cd({
            vertexColors: 2
        }),
        ed.call(this, a, h)
    }
    function sg(a, b, c) {
        n.call(this),
        this.light = a,
        this.light.updateMatrixWorld(),
        this.matrix = a.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = c,
        void 0 === b && (b = 1),
        a = new O,
        a.setAttribute("position", new K([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0],3)),
        b = new cd({
            fog: !1
        }),
        this.lightPlane = new dd(a,b),
        this.add(this.lightPlane),
        a = new O,
        a.setAttribute("position", new K([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new dd(a,b),
        this.add(this.targetLine),
        this.update()
    }
    function tg(a) {
        function b(a, b, d) {
            c(a, d),
            c(b, d)
        }
        function c(a, b) {
            f.push(0, 0, 0),
            g.push(b.r, b.g, b.b),
            void 0 === h[a] && (h[a] = []),
            h[a].push(f.length / 3 - 1)
        }
        var d = new O
          , e = new cd({
            color: 16777215,
            vertexColors: 1
        })
          , f = []
          , g = []
          , h = {}
          , i = new v(16755200)
          , j = new v(16711680)
          , k = new v(43775)
          , l = new v(16777215)
          , m = new v(3355443);
        b("n1", "n2", i),
        b("n2", "n4", i),
        b("n4", "n3", i),
        b("n3", "n1", i),
        b("f1", "f2", i),
        b("f2", "f4", i),
        b("f4", "f3", i),
        b("f3", "f1", i),
        b("n1", "f1", i),
        b("n2", "f2", i),
        b("n3", "f3", i),
        b("n4", "f4", i),
        b("p", "n1", j),
        b("p", "n2", j),
        b("p", "n3", j),
        b("p", "n4", j),
        b("u1", "u2", k),
        b("u2", "u3", k),
        b("u3", "u1", k),
        b("c", "t", l),
        b("p", "c", m),
        b("cn1", "cn2", m),
        b("cn3", "cn4", m),
        b("cf1", "cf2", m),
        b("cf3", "cf4", m),
        d.setAttribute("position", new K(f,3)),
        d.setAttribute("color", new K(g,3)),
        ed.call(this, d, e),
        this.camera = a,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = a.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = h,
        this.update()
    }
    function ug(a, b, c, d, e, f, g) {
        if (Fk.set(e, f, g).unproject(d),
        a = b[a],
        void 0 !== a)
            for (c = c.getAttribute("position"),
            b = 0,
            d = a.length; d > b; b++)
                c.setXYZ(a[b], Fk.x, Fk.y, Fk.z)
    }
    function vg(a, b) {
        this.object = a,
        void 0 === b && (b = 16776960),
        a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var c = new Float32Array(24)
          , d = new O;
        d.setIndex(new C(a,1)),
        d.setAttribute("position", new C(c,3)),
        ed.call(this, d, new cd({
            color: b
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function wg(a, b) {
        this.type = "Box3Helper",
        this.box = a,
        b = b || 16776960,
        a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var c = new O;
        c.setIndex(new C(a,1)),
        c.setAttribute("position", new K([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        ed.call(this, c, new cd({
            color: b
        })),
        this.geometry.computeBoundingSphere()
    }
    function xg(a, b, c) {
        this.type = "PlaneHelper",
        this.plane = a,
        this.size = void 0 === b ? 1 : b,
        a = void 0 !== c ? c : 16776960,
        b = new O,
        b.setAttribute("position", new K([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        b.computeBoundingSphere(),
        dd.call(this, b, new cd({
            color: a
        })),
        b = new O,
        b.setAttribute("position", new K([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        b.computeBoundingSphere(),
        this.add(new P(b,new B({
            color: a,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function yg(a, b, c, d, f, g) {
        n.call(this),
        void 0 === a && (a = new e(0,0,1)),
        void 0 === b && (b = new e(0,0,0)),
        void 0 === c && (c = 1),
        void 0 === d && (d = 16776960),
        void 0 === f && (f = .2 * c),
        void 0 === g && (g = .2 * f),
        void 0 === Ik && (Ik = new O,
        Ik.setAttribute("position", new K([0, 0, 0, 0, 1, 0],3)),
        Jk = new ne(0,.5,1,5,1),
        Jk.translate(0, -.5, 0)),
        this.position.copy(b),
        this.line = new dd(Ik,new cd({
            color: d
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new P(Jk,new B({
            color: d
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(a),
        this.setLength(c, f, g)
    }
    function zg(a) {
        a = a || 1;
        var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
        a = new O,
        a.setAttribute("position", new K(b,3)),
        a.setAttribute("color", new K([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
        b = new cd({
            vertexColors: 2
        }),
        ed.call(this, a, b)
    }
    function Ag(a) {
        Yk = a,
        Dg(Qk)
    }
    function Bg(a) {
        var b = {
            magFilter: 1003,
            minFilter: 1003,
            generateMipmaps: !1,
            type: a ? a.type : 1009,
            format: a ? a.format : 1023,
            encoding: a ? a.encoding : 3002,
            depthBuffer: !1,
            stencilBuffer: !1
        }
          , c = Eg(b);
        return c.depthBuffer = a ? !1 : !0,
        Xk = Eg(b),
        c
    }
    function Cg() {
        Xk.dispose(),
        Yk.setRenderTarget(null);
        var a = Yk.getSize(new c);
        Yk.setViewport(0, 0, a.x, a.y)
    }
    function Dg(a) {
        var b = new o;
        b.add(new P(Uk[0],a)),
        Yk.compile(b, Pk)
    }
    function Eg(a) {
        return a = new i(3 * Lk,3 * Lk,a),
        a.texture.mapping = 306,
        a.texture.name = "PMREM.cubeUv",
        a.scissorTest = !0,
        a
    }
    function Fg(a, b, c, d) {
        var e = 1 / Yk.getPixelRatio();
        a *= e,
        b *= e,
        c *= e,
        d *= e,
        Yk.setViewport(a, b, c, d),
        Yk.setScissor(a, b, c, d)
    }
    function Gg(a) {
        var b = Yk.autoClear;
        Yk.autoClear = !1;
        for (var c = 1; Nk > c; c++)
            Hg(a, c - 1, c, Math.sqrt(Wk[c] * Wk[c] - Wk[c - 1] * Wk[c - 1]), _k[(c - 1) % _k.length]);
        Yk.autoClear = b
    }
    function Hg(a, b, c, d, e) {
        Ig(a, Xk, b, c, d, "latitudinal", e),
        Ig(Xk, a, c, c, d, "longitudinal", e)
    }
    function Ig(a, b, c, d, e, f, g) {
        "latitudinal" !== f && "longitudinal" !== f && console.error("blur direction must be either latitudinal or longitudinal!");
        var h = new o;
        h.add(new P(Uk[d],Qk));
        var i = Qk.uniforms
          , j = Vk[c] - 1;
        j = isFinite(e) ? Math.PI / (2 * j) : 2 * Math.PI / 39;
        var k = e / j
          , l = isFinite(e) ? 1 + Math.floor(3 * k) : 20;
        l > 20 && console.warn("sigmaRadians, " + e + ", is too large and will clip, as it requested " + l + " samples when the maximum is set to 20");
        for (var m = [], n = 0, p = 0; 20 > p; ++p)
            e = p / k,
            e = Math.exp(-e * e / 2),
            m.push(e),
            0 == p ? n += e : l > p && (n += 2 * e);
        for (p = 0; p < m.length; p++)
            m[p] /= n;
        i.envMap.value = a.texture,
        i.samples.value = l,
        i.weights.value = m,
        i.latitudinal.value = "latitudinal" === f,
        g && (i.poleAxis.value = g),
        i.dTheta.value = j,
        i.mipInt.value = 8 - c,
        i.inputEncoding.value = Ok[a.texture.encoding],
        i.outputEncoding.value = Ok[a.texture.encoding],
        a = Vk[d],
        e = 3 * Math.max(0, Lk - 2 * a),
        d = (0 === d ? 0 : 2 * Lk) + 2 * a * (d > 4 ? d - 8 + 4 : 0),
        Yk.setRenderTarget(b),
        Fg(e, d, 3 * a, 2 * a),
        Yk.render(h, Pk)
    }
    function Jg() {
        var a = new c(1,1);
        return a = new te({
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: a
                },
                inputEncoding: {
                    value: Ok[3e3]
                },
                outputEncoding: {
                    value: Ok[3e3]
                }
            },
            vertexShader: Lg(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n" + Mg() + "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	vec3 outputDirection = normalize(vOutputDirection);\n	vec2 uv;\n	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n	vec2 f = fract(uv / texelSize - 0.5);\n	uv -= f * texelSize;\n	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.x += texelSize.x;\n	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.y += texelSize.y;\n	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.x -= texelSize.x;\n	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	vec3 tm = mix(tl, tr, f.x);\n	vec3 bm = mix(bl, br, f.x);\n	gl_FragColor.rgb = mix(tm, bm, f.y);\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        }),
        a.type = "EquirectangularToCubeUV",
        a
    }
    function Kg() {
        var a = new te({
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Ok[3e3]
                },
                outputEncoding: {
                    value: Ok[3e3]
                }
            },
            vertexShader: Lg(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n" + Mg() + "\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        });
        return a.type = "CubemapToCubeUV",
        a
    }
    function Lg() {
        return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n	uv = 2.0 * uv - 1.0;\n	vec3 direction = vec3(uv, 1.0);\n	if (face == 0.0) {\n		direction = direction.zyx;\n		direction.z *= -1.0;\n	} else if (face == 1.0) {\n		direction = direction.xzy;\n		direction.z *= -1.0;\n	} else if (face == 3.0) {\n		direction = direction.zyx;\n		direction.x *= -1.0;\n	} else if (face == 4.0) {\n		direction = direction.xzy;\n		direction.y *= -1.0;\n	} else if (face == 5.0) {\n		direction.xz *= -1.0;\n	}\n	return direction;\n}\nvoid main() {\n	vOutputDirection = getDirection(uv, faceIndex);\n	gl_Position = vec4( position, 1.0 );\n}\n	"
    }
    function Mg() {
        return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n	if(inputEncoding == 0){\n		return value;\n	}else if(inputEncoding == 1){\n		return sRGBToLinear(value);\n	}else if(inputEncoding == 2){\n		return RGBEToLinear(value);\n	}else if(inputEncoding == 3){\n		return RGBMToLinear(value, 7.0);\n	}else if(inputEncoding == 4){\n		return RGBMToLinear(value, 16.0);\n	}else if(inputEncoding == 5){\n		return RGBDToLinear(value, 256.0);\n	}else{\n		return GammaToLinear(value, 2.2);\n	}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n	if(outputEncoding == 0){\n		return value;\n	}else if(outputEncoding == 1){\n		return LinearTosRGB(value);\n	}else if(outputEncoding == 2){\n		return LinearToRGBE(value);\n	}else if(outputEncoding == 3){\n		return LinearToRGBM(value, 7.0);\n	}else if(outputEncoding == 4){\n		return LinearToRGBM(value, 16.0);\n	}else if(outputEncoding == 5){\n		return LinearToRGBD(value, 256.0);\n	}else{\n		return LinearToGamma(value, 2.2);\n	}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n	return inputTexelToLinear(color);\n}\n	"
    }
    function Ng(a) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        cf.call(this, a),
        this.type = "catmullrom",
        this.closed = !0
    }
    function Og(a) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        cf.call(this, a),
        this.type = "catmullrom"
    }
    function Pg(a) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        cf.call(this, a),
        this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(a) {
        return "number" == typeof a && isFinite(a) && Math.floor(a) === a
    }
    ),
    void 0 === Math.sign && (Math.sign = function(a) {
        return 0 > a ? -1 : a > 0 ? 1 : +a
    }
    ),
    !1 == "name"in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(a) {
        if (void 0 === a || null === a)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var b = Object(a), c = 1; c < arguments.length; c++) {
            var d = arguments[c];
            if (void 0 !== d && null !== d)
                for (var e in d)
                    Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
        }
        return b
    }
    ),
    Object.assign(b.prototype, {
        addEventListener: function(a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var c = this._listeners;
            void 0 === c[a] && (c[a] = []),
            -1 === c[a].indexOf(b) && c[a].push(b)
        },
        hasEventListener: function(a, b) {
            if (void 0 === this._listeners)
                return !1;
            var c = this._listeners;
            return void 0 !== c[a] && -1 !== c[a].indexOf(b)
        },
        removeEventListener: function(a, b) {
            void 0 !== this._listeners && (a = this._listeners[a],
            void 0 !== a && (b = a.indexOf(b),
            -1 !== b && a.splice(b, 1)))
        },
        dispatchEvent: function(a) {
            if (void 0 !== this._listeners) {
                var b = this._listeners[a.type];
                if (void 0 !== b) {
                    a.target = this,
                    b = b.slice(0);
                    for (var c = 0, d = b.length; d > c; c++)
                        b[c].call(this, a)
                }
            }
        }
    });
    for (var Qg = [], Rg = 0; 256 > Rg; Rg++)
        Qg[Rg] = (16 > Rg ? "0" : "") + Rg.toString(16);
    var Sg = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var a = 4294967295 * Math.random() | 0
              , b = 4294967295 * Math.random() | 0
              , c = 4294967295 * Math.random() | 0
              , d = 4294967295 * Math.random() | 0;
            return (Qg[255 & a] + Qg[a >> 8 & 255] + Qg[a >> 16 & 255] + Qg[a >> 24 & 255] + "-" + Qg[255 & b] + Qg[b >> 8 & 255] + "-" + Qg[b >> 16 & 15 | 64] + Qg[b >> 24 & 255] + "-" + Qg[63 & c | 128] + Qg[c >> 8 & 255] + "-" + Qg[c >> 16 & 255] + Qg[c >> 24 & 255] + Qg[255 & d] + Qg[d >> 8 & 255] + Qg[d >> 16 & 255] + Qg[d >> 24 & 255]).toUpperCase()
        },
        clamp: function(a, b, c) {
            return Math.max(b, Math.min(c, a))
        },
        euclideanModulo: function(a, b) {
            return (a % b + b) % b
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        },
        lerp: function(a, b, c) {
            return (1 - c) * a + c * b
        },
        smoothstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b),
            a * a * (3 - 2 * a))
        },
        smootherstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b),
            a * a * a * (a * (6 * a - 15) + 10))
        },
        randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        },
        randFloat: function(a, b) {
            return a + Math.random() * (b - a)
        },
        randFloatSpread: function(a) {
            return a * (.5 - Math.random())
        },
        degToRad: function(a) {
            return a * Sg.DEG2RAD
        },
        radToDeg: function(a) {
            return a * Sg.RAD2DEG
        },
        isPowerOfTwo: function(a) {
            return 0 === (a & a - 1) && 0 !== a
        },
        ceilPowerOfTwo: function(a) {
            return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
        },
        floorPowerOfTwo: function(a) {
            return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
        }
    };
    Object.defineProperties(c.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(a) {
                this.x = a
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(a) {
                this.y = a
            }
        }
    }),
    Object.assign(c.prototype, {
        isVector2: !0,
        set: function(a, b) {
            return this.x = a,
            this.y = b,
            this
        },
        setScalar: function(a) {
            return this.y = this.x = a,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            default:
                throw Error("index is out of range: " + a)
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b)) : (this.x += a.x,
            this.y += a.y,
            this)
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b,
            this.y += a.y * b,
            this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b)) : (this.x -= a.x,
            this.y -= a.y,
            this)
        },
        subScalar: function(a) {
            return this.x -= a,
            this.y -= a,
            this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this
        },
        multiply: function(a) {
            return this.x *= a.x,
            this.y *= a.y,
            this
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this
        },
        divide: function(a) {
            return this.x /= a.x,
            this.y /= a.y,
            this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        applyMatrix3: function(a) {
            var b = this.x
              , c = this.y;
            return a = a.elements,
            this.x = a[0] * b + a[3] * c + a[6],
            this.y = a[1] * b + a[4] * c + a[7],
            this
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x),
            this.y = Math.min(this.y, a.y),
            this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x),
            this.y = Math.max(this.y, a.y),
            this
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)),
            this.y = Math.max(a.y, Math.min(b.y, this.y)),
            this
        },
        clampScalar: function(a, b) {
            return this.x = Math.max(a, Math.min(b, this.x)),
            this.y = Math.max(a, Math.min(b, this.y)),
            this
        },
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var a = Math.atan2(this.y, this.x);
            return 0 > a && (a += 2 * Math.PI),
            a
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x;
            return a = this.y - a.y,
            b * b + a * a
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0),
            this.x = a[b],
            this.y = a[b + 1],
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this.x,
            a[b + 1] = this.y,
            a
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = a.getX(b),
            this.y = a.getY(b),
            this
        },
        rotateAround: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = this.x - a.x
              , e = this.y - a.y;
            return this.x = d * c - e * b + a.x,
            this.y = d * b + e * c + a.y,
            this
        }
    }),
    Object.assign(d, {
        slerp: function(a, b, c, d) {
            return c.copy(a).slerp(b, d)
        },
        slerpFlat: function(a, b, c, d, e, f, g) {
            var h = c[d + 0]
              , i = c[d + 1]
              , j = c[d + 2];
            c = c[d + 3],
            d = e[f + 0];
            var k = e[f + 1]
              , l = e[f + 2];
            if (e = e[f + 3],
            c !== e || h !== d || i !== k || j !== l) {
                f = 1 - g;
                var m = h * d + i * k + j * l + c * e
                  , n = m >= 0 ? 1 : -1
                  , o = 1 - m * m;
                o > Number.EPSILON && (o = Math.sqrt(o),
                m = Math.atan2(o, m * n),
                f = Math.sin(f * m) / o,
                g = Math.sin(g * m) / o),
                n *= g,
                h = h * f + d * n,
                i = i * f + k * n,
                j = j * f + l * n,
                c = c * f + e * n,
                f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c),
                h *= g,
                i *= g,
                j *= g,
                c *= g)
            }
            a[b] = h,
            a[b + 1] = i,
            a[b + 2] = j,
            a[b + 3] = c
        }
    }),
    Object.defineProperties(d.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(a) {
                this._x = a,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(a) {
                this._y = a,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(a) {
                this._z = a,
                this._onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(a) {
                this._w = a,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign(d.prototype, {
        isQuaternion: !0,
        set: function(a, b, c, d) {
            return this._x = a,
            this._y = b,
            this._z = c,
            this._w = d,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(a) {
            return this._x = a.x,
            this._y = a.y,
            this._z = a.z,
            this._w = a.w,
            this._onChangeCallback(),
            this
        },
        setFromEuler: function(a, b) {
            if (!a || !a.isEuler)
                throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c = a._x
              , d = a._y
              , e = a._z;
            a = a.order;
            var f = Math.cos
              , g = Math.sin
              , h = f(c / 2)
              , i = f(d / 2);
            return f = f(e / 2),
            c = g(c / 2),
            d = g(d / 2),
            e = g(e / 2),
            "XYZ" === a ? (this._x = c * i * f + h * d * e,
            this._y = h * d * f - c * i * e,
            this._z = h * i * e + c * d * f,
            this._w = h * i * f - c * d * e) : "YXZ" === a ? (this._x = c * i * f + h * d * e,
            this._y = h * d * f - c * i * e,
            this._z = h * i * e - c * d * f,
            this._w = h * i * f + c * d * e) : "ZXY" === a ? (this._x = c * i * f - h * d * e,
            this._y = h * d * f + c * i * e,
            this._z = h * i * e + c * d * f,
            this._w = h * i * f - c * d * e) : "ZYX" === a ? (this._x = c * i * f - h * d * e,
            this._y = h * d * f + c * i * e,
            this._z = h * i * e - c * d * f,
            this._w = h * i * f + c * d * e) : "YZX" === a ? (this._x = c * i * f + h * d * e,
            this._y = h * d * f + c * i * e,
            this._z = h * i * e - c * d * f,
            this._w = h * i * f - c * d * e) : "XZY" === a && (this._x = c * i * f - h * d * e,
            this._y = h * d * f - c * i * e,
            this._z = h * i * e + c * d * f,
            this._w = h * i * f + c * d * e),
            !1 !== b && this._onChangeCallback(),
            this
        },
        setFromAxisAngle: function(a, b) {
            b /= 2;
            var c = Math.sin(b);
            return this._x = a.x * c,
            this._y = a.y * c,
            this._z = a.z * c,
            this._w = Math.cos(b),
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(a) {
            var b = a.elements
              , c = b[0];
            a = b[4];
            var d = b[8]
              , e = b[1]
              , f = b[5]
              , g = b[9]
              , h = b[2]
              , i = b[6];
            b = b[10];
            var j = c + f + b;
            return j > 0 ? (c = .5 / Math.sqrt(j + 1),
            this._w = .25 / c,
            this._x = (i - g) * c,
            this._y = (d - h) * c,
            this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b),
            this._w = (i - g) / c,
            this._x = .25 * c,
            this._y = (a + e) / c,
            this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b),
            this._w = (d - h) / c,
            this._x = (a + e) / c,
            this._y = .25 * c,
            this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f),
            this._w = (e - a) / c,
            this._x = (d + h) / c,
            this._y = (g + i) / c,
            this._z = .25 * c),
            this._onChangeCallback(),
            this
        },
        setFromUnitVectors: function(a, b) {
            var c = a.dot(b) + 1;
            return 1e-6 > c ? (c = 0,
            Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y,
            this._y = a.x,
            this._z = 0) : (this._x = 0,
            this._y = -a.z,
            this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y,
            this._y = a.z * b.x - a.x * b.z,
            this._z = a.x * b.y - a.y * b.x),
            this._w = c,
            this.normalize()
        },
        angleTo: function(a) {
            return 2 * Math.acos(Math.abs(Sg.clamp(this.dot(a), -1, 1)))
        },
        rotateTowards: function(a, b) {
            var c = this.angleTo(a);
            return 0 === c ? this : (this.slerp(a, Math.min(1, b / c)),
            this)
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        },
        dot: function(a) {
            return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var a = this.length();
            return 0 === a ? (this._z = this._y = this._x = 0,
            this._w = 1) : (a = 1 / a,
            this._x *= a,
            this._y *= a,
            this._z *= a,
            this._w *= a),
            this._onChangeCallback(),
            this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        },
        premultiply: function(a) {
            return this.multiplyQuaternions(a, this)
        },
        multiplyQuaternions: function(a, b) {
            var c = a._x
              , d = a._y
              , e = a._z;
            a = a._w;
            var f = b._x
              , g = b._y
              , h = b._z;
            return b = b._w,
            this._x = c * b + a * f + d * h - e * g,
            this._y = d * b + a * g + e * f - c * h,
            this._z = e * b + a * h + c * g - d * f,
            this._w = a * b - c * f - d * g - e * h,
            this._onChangeCallback(),
            this
        },
        slerp: function(a, b) {
            if (0 === b)
                return this;
            if (1 === b)
                return this.copy(a);
            var c = this._x
              , d = this._y
              , e = this._z
              , f = this._w
              , g = f * a._w + c * a._x + d * a._y + e * a._z;
            if (0 > g ? (this._w = -a._w,
            this._x = -a._x,
            this._y = -a._y,
            this._z = -a._z,
            g = -g) : this.copy(a),
            g >= 1)
                return this._w = f,
                this._x = c,
                this._y = d,
                this._z = e,
                this;
            if (a = 1 - g * g,
            a <= Number.EPSILON)
                return g = 1 - b,
                this._w = g * f + b * this._w,
                this._x = g * c + b * this._x,
                this._y = g * d + b * this._y,
                this._z = g * e + b * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this;
            a = Math.sqrt(a);
            var h = Math.atan2(a, g);
            return g = Math.sin((1 - b) * h) / a,
            b = Math.sin(b * h) / a,
            this._w = f * g + this._w * b,
            this._x = c * g + this._x * b,
            this._y = d * g + this._y * b,
            this._z = e * g + this._z * b,
            this._onChangeCallback(),
            this
        },
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0),
            this._x = a[b],
            this._y = a[b + 1],
            this._z = a[b + 2],
            this._w = a[b + 3],
            this._onChangeCallback(),
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this._x,
            a[b + 1] = this._y,
            a[b + 2] = this._z,
            a[b + 3] = this._w,
            a
        },
        _onChange: function(a) {
            return this._onChangeCallback = a,
            this
        },
        _onChangeCallback: function() {}
    });
    var Tg = new e
      , Ug = new d;
    Object.assign(e.prototype, {
        isVector3: !0,
        set: function(a, b, c) {
            return this.x = a,
            this.y = b,
            this.z = c,
            this
        },
        setScalar: function(a) {
            return this.z = this.y = this.x = a,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setZ: function(a) {
            return this.z = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            default:
                throw Error("index is out of range: " + a)
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this.z = a.z,
            this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b)) : (this.x += a.x,
            this.y += a.y,
            this.z += a.z,
            this)
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this.z += a,
            this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this.z = a.z + b.z,
            this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b,
            this.y += a.y * b,
            this.z += a.z * b,
            this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b)) : (this.x -= a.x,
            this.y -= a.y,
            this.z -= a.z,
            this)
        },
        subScalar: function(a) {
            return this.x -= a,
            this.y -= a,
            this.z -= a,
            this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this.z = a.z - b.z,
            this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(a, b)) : (this.x *= a.x,
            this.y *= a.y,
            this.z *= a.z,
            this)
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this.z *= a,
            this
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x,
            this.y = a.y * b.y,
            this.z = a.z * b.z,
            this
        },
        applyEuler: function(a) {
            return a && a.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(Ug.setFromEuler(a))
        },
        applyAxisAngle: function(a, b) {
            return this.applyQuaternion(Ug.setFromAxisAngle(a, b))
        },
        applyMatrix3: function(a) {
            var b = this.x
              , c = this.y
              , d = this.z;
            return a = a.elements,
            this.x = a[0] * b + a[3] * c + a[6] * d,
            this.y = a[1] * b + a[4] * c + a[7] * d,
            this.z = a[2] * b + a[5] * c + a[8] * d,
            this
        },
        applyNormalMatrix: function(a) {
            return this.applyMatrix3(a).normalize()
        },
        applyMatrix4: function(a) {
            var b = this.x
              , c = this.y
              , d = this.z;
            a = a.elements;
            var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
            return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e,
            this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e,
            this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e,
            this
        },
        applyQuaternion: function(a) {
            var b = this.x
              , c = this.y
              , d = this.z
              , e = a.x
              , f = a.y
              , g = a.z;
            a = a.w;
            var h = a * b + f * d - g * c
              , i = a * c + g * b - e * d
              , j = a * d + e * c - f * b;
            return b = -e * b - f * c - g * d,
            this.x = h * a + b * -e + i * -g - j * -f,
            this.y = i * a + b * -f + j * -e - h * -g,
            this.z = j * a + b * -g + h * -f - i * -e,
            this
        },
        project: function(a) {
            return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)
        },
        unproject: function(a) {
            return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld)
        },
        transformDirection: function(a) {
            var b = this.x
              , c = this.y
              , d = this.z;
            return a = a.elements,
            this.x = a[0] * b + a[4] * c + a[8] * d,
            this.y = a[1] * b + a[5] * c + a[9] * d,
            this.z = a[2] * b + a[6] * c + a[10] * d,
            this.normalize()
        },
        divide: function(a) {
            return this.x /= a.x,
            this.y /= a.y,
            this.z /= a.z,
            this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x),
            this.y = Math.min(this.y, a.y),
            this.z = Math.min(this.z, a.z),
            this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x),
            this.y = Math.max(this.y, a.y),
            this.z = Math.max(this.z, a.z),
            this
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)),
            this.y = Math.max(a.y, Math.min(b.y, this.y)),
            this.z = Math.max(a.z, Math.min(b.z, this.z)),
            this
        },
        clampScalar: function(a, b) {
            return this.x = Math.max(a, Math.min(b, this.x)),
            this.y = Math.max(a, Math.min(b, this.y)),
            this.z = Math.max(a, Math.min(b, this.z)),
            this
        },
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this.z += (a.z - this.z) * b,
            this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        cross: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(a, b)) : this.crossVectors(this, a)
        },
        crossVectors: function(a, b) {
            var c = a.x
              , d = a.y;
            a = a.z;
            var e = b.x
              , f = b.y;
            return b = b.z,
            this.x = d * b - a * f,
            this.y = a * e - c * b,
            this.z = c * f - d * e,
            this
        },
        projectOnVector: function(a) {
            var b = a.dot(this) / a.lengthSq();
            return this.copy(a).multiplyScalar(b)
        },
        projectOnPlane: function(a) {
            return Tg.copy(this).projectOnVector(a),
            this.sub(Tg)
        },
        reflect: function(a) {
            return this.sub(Tg.copy(a).multiplyScalar(2 * this.dot(a)))
        },
        angleTo: function(a) {
            var b = Math.sqrt(this.lengthSq() * a.lengthSq());
            return 0 === b && console.error("THREE.Vector3: angleTo() can't handle zero length vectors."),
            a = this.dot(a) / b,
            Math.acos(Sg.clamp(a, -1, 1))
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x
              , c = this.y - a.y;
            return a = this.z - a.z,
            b * b + c * c + a * a
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
        },
        setFromSpherical: function(a) {
            return this.setFromSphericalCoords(a.radius, a.phi, a.theta)
        },
        setFromSphericalCoords: function(a, b, c) {
            var d = Math.sin(b) * a;
            return this.x = d * Math.sin(c),
            this.y = Math.cos(b) * a,
            this.z = d * Math.cos(c),
            this
        },
        setFromCylindrical: function(a) {
            return this.setFromCylindricalCoords(a.radius, a.theta, a.y)
        },
        setFromCylindricalCoords: function(a, b, c) {
            return this.x = a * Math.sin(b),
            this.y = c,
            this.z = a * Math.cos(b),
            this
        },
        setFromMatrixPosition: function(a) {
            return a = a.elements,
            this.x = a[12],
            this.y = a[13],
            this.z = a[14],
            this
        },
        setFromMatrixScale: function(a) {
            var b = this.setFromMatrixColumn(a, 0).length()
              , c = this.setFromMatrixColumn(a, 1).length();
            return a = this.setFromMatrixColumn(a, 2).length(),
            this.x = b,
            this.y = c,
            this.z = a,
            this
        },
        setFromMatrixColumn: function(a, b) {
            return this.fromArray(a.elements, 4 * b)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0),
            this.x = a[b],
            this.y = a[b + 1],
            this.z = a[b + 2],
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this.x,
            a[b + 1] = this.y,
            a[b + 2] = this.z,
            a
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = a.getX(b),
            this.y = a.getY(b),
            this.z = a.getZ(b),
            this
        }
    });
    var Vg = new e;
    Object.assign(f.prototype, {
        isMatrix3: !0,
        set: function(a, b, c, d, e, f, g, h, i) {
            var j = this.elements;
            return j[0] = a,
            j[1] = d,
            j[2] = g,
            j[3] = b,
            j[4] = e,
            j[5] = h,
            j[6] = c,
            j[7] = f,
            j[8] = i,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(a) {
            var b = this.elements;
            return a = a.elements,
            b[0] = a[0],
            b[1] = a[1],
            b[2] = a[2],
            b[3] = a[3],
            b[4] = a[4],
            b[5] = a[5],
            b[6] = a[6],
            b[7] = a[7],
            b[8] = a[8],
            this
        },
        setFromMatrix4: function(a) {
            return a = a.elements,
            this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]),
            this
        },
        applyToBufferAttribute: function(a) {
            for (var b = 0, c = a.count; c > b; b++)
                Vg.x = a.getX(b),
                Vg.y = a.getY(b),
                Vg.z = a.getZ(b),
                Vg.applyMatrix3(this),
                a.setXYZ(b, Vg.x, Vg.y, Vg.z);
            return a
        },
        multiply: function(a) {
            return this.multiplyMatrices(this, a)
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a, this)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements
              , d = b.elements;
            b = this.elements,
            a = c[0];
            var e = c[3]
              , f = c[6]
              , g = c[1]
              , h = c[4]
              , i = c[7]
              , j = c[2]
              , k = c[5];
            c = c[8];
            var l = d[0]
              , m = d[3]
              , n = d[6]
              , o = d[1]
              , p = d[4]
              , q = d[7]
              , r = d[2]
              , s = d[5];
            return d = d[8],
            b[0] = a * l + e * o + f * r,
            b[3] = a * m + e * p + f * s,
            b[6] = a * n + e * q + f * d,
            b[1] = g * l + h * o + i * r,
            b[4] = g * m + h * p + i * s,
            b[7] = g * n + h * q + i * d,
            b[2] = j * l + k * o + c * r,
            b[5] = j * m + k * p + c * s,
            b[8] = j * n + k * q + c * d,
            this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a,
            b[3] *= a,
            b[6] *= a,
            b[1] *= a,
            b[4] *= a,
            b[7] *= a,
            b[2] *= a,
            b[5] *= a,
            b[8] *= a,
            this
        },
        determinant: function() {
            var a = this.elements
              , b = a[0]
              , c = a[1]
              , d = a[2]
              , e = a[3]
              , f = a[4]
              , g = a[5]
              , h = a[6]
              , i = a[7];
            return a = a[8],
            b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h
        },
        getInverse: function(a, b) {
            a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var c = a.elements;
            a = this.elements;
            var d = c[0]
              , e = c[1]
              , f = c[2]
              , g = c[3]
              , h = c[4]
              , i = c[5]
              , j = c[6]
              , k = c[7];
            c = c[8];
            var l = c * h - i * k
              , m = i * j - c * g
              , n = k * g - h * j
              , o = d * l + e * m + f * n;
            if (0 === o) {
                if (!0 === b)
                    throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"),
                this.identity()
            }
            return b = 1 / o,
            a[0] = l * b,
            a[1] = (f * k - c * e) * b,
            a[2] = (i * e - f * h) * b,
            a[3] = m * b,
            a[4] = (c * d - f * j) * b,
            a[5] = (f * g - i * d) * b,
            a[6] = n * b,
            a[7] = (e * j - k * d) * b,
            a[8] = (h * d - e * g) * b,
            this
        },
        transpose: function() {
            var a = this.elements
              , b = a[1];
            return a[1] = a[3],
            a[3] = b,
            b = a[2],
            a[2] = a[6],
            a[6] = b,
            b = a[5],
            a[5] = a[7],
            a[7] = b,
            this
        },
        getNormalMatrix: function(a) {
            return this.setFromMatrix4(a).getInverse(this).transpose()
        },
        transposeIntoArray: function(a) {
            var b = this.elements;
            return a[0] = b[0],
            a[1] = b[3],
            a[2] = b[6],
            a[3] = b[1],
            a[4] = b[4],
            a[5] = b[7],
            a[6] = b[2],
            a[7] = b[5],
            a[8] = b[8],
            this
        },
        setUvTransform: function(a, b, c, d, e, f, g) {
            var h = Math.cos(e);
            e = Math.sin(e),
            this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1)
        },
        scale: function(a, b) {
            var c = this.elements;
            return c[0] *= a,
            c[3] *= a,
            c[6] *= a,
            c[1] *= b,
            c[4] *= b,
            c[7] *= b,
            this
        },
        rotate: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            var c = this.elements
              , d = c[0]
              , e = c[3]
              , f = c[6]
              , g = c[1]
              , h = c[4]
              , i = c[7];
            return c[0] = b * d + a * g,
            c[3] = b * e + a * h,
            c[6] = b * f + a * i,
            c[1] = -a * d + b * g,
            c[4] = -a * e + b * h,
            c[7] = -a * f + b * i,
            this
        },
        translate: function(a, b) {
            var c = this.elements;
            return c[0] += a * c[2],
            c[3] += a * c[5],
            c[6] += a * c[8],
            c[1] += b * c[2],
            c[4] += b * c[5],
            c[7] += b * c[8],
            this
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 9 > c; c++)
                if (b[c] !== a[c])
                    return !1;
            return !0
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 9 > c; c++)
                this.elements[c] = a[c + b];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []),
            void 0 === b && (b = 0);
            var c = this.elements;
            return a[b] = c[0],
            a[b + 1] = c[1],
            a[b + 2] = c[2],
            a[b + 3] = c[3],
            a[b + 4] = c[4],
            a[b + 5] = c[5],
            a[b + 6] = c[6],
            a[b + 7] = c[7],
            a[b + 8] = c[8],
            a
        }
    });
    var Wg, Xg = {
        getDataURL: function(a) {
            if ("undefined" == typeof HTMLCanvasElement)
                return a.src;
            if (!(a instanceof HTMLCanvasElement)) {
                void 0 === Wg && (Wg = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                Wg.width = a.width,
                Wg.height = a.height;
                var b = Wg.getContext("2d");
                a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height),
                a = Wg
            }
            return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png")
        }
    }, Yg = 0;
    g.DEFAULT_IMAGE = void 0,
    g.DEFAULT_MAPPING = 300,
    g.prototype = Object.assign(Object.create(b.prototype), {
        constructor: g,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.name = a.name,
            this.image = a.image,
            this.mipmaps = a.mipmaps.slice(0),
            this.mapping = a.mapping,
            this.wrapS = a.wrapS,
            this.wrapT = a.wrapT,
            this.magFilter = a.magFilter,
            this.minFilter = a.minFilter,
            this.anisotropy = a.anisotropy,
            this.format = a.format,
            this.internalFormat = a.internalFormat,
            this.type = a.type,
            this.offset.copy(a.offset),
            this.repeat.copy(a.repeat),
            this.center.copy(a.center),
            this.rotation = a.rotation,
            this.matrixAutoUpdate = a.matrixAutoUpdate,
            this.matrix.copy(a.matrix),
            this.generateMipmaps = a.generateMipmaps,
            this.premultiplyAlpha = a.premultiplyAlpha,
            this.flipY = a.flipY,
            this.unpackAlignment = a.unpackAlignment,
            this.encoding = a.encoding,
            this
        },
        toJSON: function(a) {
            var b = void 0 === a || "string" == typeof a;
            if (!b && void 0 !== a.textures[this.uuid])
                return a.textures[this.uuid];
            var c = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var d = this.image;
                if (void 0 === d.uuid && (d.uuid = Sg.generateUUID()),
                !b && void 0 === a.images[d.uuid]) {
                    if (Array.isArray(d))
                        for (var e = [], f = 0, g = d.length; g > f; f++)
                            e.push(Xg.getDataURL(d[f]));
                    else
                        e = Xg.getDataURL(d);
                    a.images[d.uuid] = {
                        uuid: d.uuid,
                        url: e
                    }
                }
                c.image = d.uuid
            }
            return b || (a.textures[this.uuid] = c),
            c
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(a) {
            if (300 !== this.mapping)
                return a;
            if (a.applyMatrix3(this.matrix),
            0 > a.x || 1 < a.x)
                switch (this.wrapS) {
                case 1e3:
                    a.x -= Math.floor(a.x);
                    break;
                case 1001:
                    a.x = 0 > a.x ? 0 : 1;
                    break;
                case 1002:
                    a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                }
            if (0 > a.y || 1 < a.y)
                switch (this.wrapT) {
                case 1e3:
                    a.y -= Math.floor(a.y);
                    break;
                case 1001:
                    a.y = 0 > a.y ? 0 : 1;
                    break;
                case 1002:
                    a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                }
            return this.flipY && (a.y = 1 - a.y),
            a
        }
    }),
    Object.defineProperty(g.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    }),
    Object.defineProperties(h.prototype, {
        width: {
            get: function() {
                return this.z
            },
            set: function(a) {
                this.z = a
            }
        },
        height: {
            get: function() {
                return this.w
            },
            set: function(a) {
                this.w = a
            }
        }
    }),
    Object.assign(h.prototype, {
        isVector4: !0,
        set: function(a, b, c, d) {
            return this.x = a,
            this.y = b,
            this.z = c,
            this.w = d,
            this
        },
        setScalar: function(a) {
            return this.w = this.z = this.y = this.x = a,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setZ: function(a) {
            return this.z = a,
            this
        },
        setW: function(a) {
            return this.w = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            case 3:
                this.w = b;
                break;
            default:
                throw Error("index is out of range: " + a)
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this.z = a.z,
            this.w = void 0 !== a.w ? a.w : 1,
            this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b)) : (this.x += a.x,
            this.y += a.y,
            this.z += a.z,
            this.w += a.w,
            this)
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this.z += a,
            this.w += a,
            this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this.z = a.z + b.z,
            this.w = a.w + b.w,
            this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b,
            this.y += a.y * b,
            this.z += a.z * b,
            this.w += a.w * b,
            this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b)) : (this.x -= a.x,
            this.y -= a.y,
            this.z -= a.z,
            this.w -= a.w,
            this)
        },
        subScalar: function(a) {
            return this.x -= a,
            this.y -= a,
            this.z -= a,
            this.w -= a,
            this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this.z = a.z - b.z,
            this.w = a.w - b.w,
            this
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this.z *= a,
            this.w *= a,
            this
        },
        applyMatrix4: function(a) {
            var b = this.x
              , c = this.y
              , d = this.z
              , e = this.w;
            return a = a.elements,
            this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e,
            this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e,
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e,
            this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e,
            this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        setAxisAngleFromQuaternion: function(a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            return 1e-4 > b ? (this.x = 1,
            this.z = this.y = 0) : (this.x = a.x / b,
            this.y = a.y / b,
            this.z = a.z / b),
            this
        },
        setAxisAngleFromRotationMatrix: function(a) {
            a = a.elements;
            var b = a[0]
              , c = a[4]
              , d = a[8]
              , e = a[1]
              , f = a[5]
              , g = a[9]
              , h = a[2]
              , i = a[6]
              , j = a[10];
            return .01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - i) ? .1 > Math.abs(c + e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + i) && .1 > Math.abs(b + f + j - 3) ? (this.set(1, 0, 0, 0),
            this) : (a = Math.PI,
            b = (b + 1) / 2,
            f = (f + 1) / 2,
            j = (j + 1) / 2,
            c = (c + e) / 4,
            d = (d + h) / 4,
            g = (g + i) / 4,
            b > f && b > j ? .01 > b ? (i = 0,
            c = h = .707106781) : (i = Math.sqrt(b),
            h = c / i,
            c = d / i) : f > j ? .01 > f ? (i = .707106781,
            h = 0,
            c = .707106781) : (h = Math.sqrt(f),
            i = c / h,
            c = g / h) : .01 > j ? (h = i = .707106781,
            c = 0) : (c = Math.sqrt(j),
            i = d / c,
            h = g / c),
            this.set(i, h, c, a),
            this) : (a = Math.sqrt((i - g) * (i - g) + (d - h) * (d - h) + (e - c) * (e - c)),
            .001 > Math.abs(a) && (a = 1),
            this.x = (i - g) / a,
            this.y = (d - h) / a,
            this.z = (e - c) / a,
            this.w = Math.acos((b + f + j - 1) / 2),
            this)
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x),
            this.y = Math.min(this.y, a.y),
            this.z = Math.min(this.z, a.z),
            this.w = Math.min(this.w, a.w),
            this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x),
            this.y = Math.max(this.y, a.y),
            this.z = Math.max(this.z, a.z),
            this.w = Math.max(this.w, a.w),
            this
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)),
            this.y = Math.max(a.y, Math.min(b.y, this.y)),
            this.z = Math.max(a.z, Math.min(b.z, this.z)),
            this.w = Math.max(a.w, Math.min(b.w, this.w)),
            this
        },
        clampScalar: function(a, b) {
            return this.x = Math.max(a, Math.min(b, this.x)),
            this.y = Math.max(a, Math.min(b, this.y)),
            this.z = Math.max(a, Math.min(b, this.z)),
            this.w = Math.max(a, Math.min(b, this.w)),
            this
        },
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this.z += (a.z - this.z) * b,
            this.w += (a.w - this.w) * b,
            this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0),
            this.x = a[b],
            this.y = a[b + 1],
            this.z = a[b + 2],
            this.w = a[b + 3],
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this.x,
            a[b + 1] = this.y,
            a[b + 2] = this.z,
            a[b + 3] = this.w,
            a
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = a.getX(b),
            this.y = a.getY(b),
            this.z = a.getZ(b),
            this.w = a.getW(b),
            this
        }
    }),
    i.prototype = Object.assign(Object.create(b.prototype), {
        constructor: i,
        isWebGLRenderTarget: !0,
        setSize: function(a, b) {
            (this.width !== a || this.height !== b) && (this.width = a,
            this.height = b,
            this.texture.image.width = a,
            this.texture.image.height = b,
            this.dispose()),
            this.viewport.set(0, 0, a, b),
            this.scissor.set(0, 0, a, b)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.width = a.width,
            this.height = a.height,
            this.viewport.copy(a.viewport),
            this.texture = a.texture.clone(),
            this.depthBuffer = a.depthBuffer,
            this.stencilBuffer = a.stencilBuffer,
            this.depthTexture = a.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    j.prototype = Object.assign(Object.create(i.prototype), {
        constructor: j,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(a) {
            return i.prototype.copy.call(this, a),
            this.samples = a.samples,
            this
        }
    });
    var Zg = new e
      , $g = new k
      , _g = new e(0,0,0)
      , ah = new e(1,1,1)
      , bh = new e
      , ch = new e
      , dh = new e;
    Object.assign(k.prototype, {
        isMatrix4: !0,
        set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            var q = this.elements;
            return q[0] = a,
            q[4] = b,
            q[8] = c,
            q[12] = d,
            q[1] = e,
            q[5] = f,
            q[9] = g,
            q[13] = h,
            q[2] = i,
            q[6] = j,
            q[10] = k,
            q[14] = l,
            q[3] = m,
            q[7] = n,
            q[11] = o,
            q[15] = p,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new k).fromArray(this.elements)
        },
        copy: function(a) {
            var b = this.elements;
            return a = a.elements,
            b[0] = a[0],
            b[1] = a[1],
            b[2] = a[2],
            b[3] = a[3],
            b[4] = a[4],
            b[5] = a[5],
            b[6] = a[6],
            b[7] = a[7],
            b[8] = a[8],
            b[9] = a[9],
            b[10] = a[10],
            b[11] = a[11],
            b[12] = a[12],
            b[13] = a[13],
            b[14] = a[14],
            b[15] = a[15],
            this
        },
        copyPosition: function(a) {
            var b = this.elements;
            return a = a.elements,
            b[12] = a[12],
            b[13] = a[13],
            b[14] = a[14],
            this
        },
        extractBasis: function(a, b, c) {
            return a.setFromMatrixColumn(this, 0),
            b.setFromMatrixColumn(this, 1),
            c.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(a, b, c) {
            return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function(a) {
            var b = this.elements
              , c = a.elements
              , d = 1 / Zg.setFromMatrixColumn(a, 0).length()
              , e = 1 / Zg.setFromMatrixColumn(a, 1).length();
            return a = 1 / Zg.setFromMatrixColumn(a, 2).length(),
            b[0] = c[0] * d,
            b[1] = c[1] * d,
            b[2] = c[2] * d,
            b[3] = 0,
            b[4] = c[4] * e,
            b[5] = c[5] * e,
            b[6] = c[6] * e,
            b[7] = 0,
            b[8] = c[8] * a,
            b[9] = c[9] * a,
            b[10] = c[10] * a,
            b[11] = 0,
            b[12] = 0,
            b[13] = 0,
            b[14] = 0,
            b[15] = 1,
            this
        },
        makeRotationFromEuler: function(a) {
            a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements
              , c = a.x
              , d = a.y
              , e = a.z
              , f = Math.cos(c);
            c = Math.sin(c);
            var g = Math.cos(d);
            d = Math.sin(d);
            var h = Math.cos(e);
            if (e = Math.sin(e),
            "XYZ" === a.order) {
                a = f * h;
                var i = f * e
                  , j = c * h
                  , k = c * e;
                b[0] = g * h,
                b[4] = -g * e,
                b[8] = d,
                b[1] = i + j * d,
                b[5] = a - k * d,
                b[9] = -c * g,
                b[2] = k - a * d,
                b[6] = j + i * d,
                b[10] = f * g
            } else
                "YXZ" === a.order ? (a = g * h,
                i = g * e,
                j = d * h,
                k = d * e,
                b[0] = a + k * c,
                b[4] = j * c - i,
                b[8] = f * d,
                b[1] = f * e,
                b[5] = f * h,
                b[9] = -c,
                b[2] = i * c - j,
                b[6] = k + a * c,
                b[10] = f * g) : "ZXY" === a.order ? (a = g * h,
                i = g * e,
                j = d * h,
                k = d * e,
                b[0] = a - k * c,
                b[4] = -f * e,
                b[8] = j + i * c,
                b[1] = i + j * c,
                b[5] = f * h,
                b[9] = k - a * c,
                b[2] = -f * d,
                b[6] = c,
                b[10] = f * g) : "ZYX" === a.order ? (a = f * h,
                i = f * e,
                j = c * h,
                k = c * e,
                b[0] = g * h,
                b[4] = j * d - i,
                b[8] = a * d + k,
                b[1] = g * e,
                b[5] = k * d + a,
                b[9] = i * d - j,
                b[2] = -d,
                b[6] = c * g,
                b[10] = f * g) : "YZX" === a.order ? (a = f * g,
                i = f * d,
                j = c * g,
                k = c * d,
                b[0] = g * h,
                b[4] = k - a * e,
                b[8] = j * e + i,
                b[1] = e,
                b[5] = f * h,
                b[9] = -c * h,
                b[2] = -d * h,
                b[6] = i * e + j,
                b[10] = a - k * e) : "XZY" === a.order && (a = f * g,
                i = f * d,
                j = c * g,
                k = c * d,
                b[0] = g * h,
                b[4] = -e,
                b[8] = d * h,
                b[1] = a * e + k,
                b[5] = f * h,
                b[9] = i * e - j,
                b[2] = j * e - i,
                b[6] = c * h,
                b[10] = k * e + a);
            return b[3] = 0,
            b[7] = 0,
            b[11] = 0,
            b[12] = 0,
            b[13] = 0,
            b[14] = 0,
            b[15] = 1,
            this
        },
        makeRotationFromQuaternion: function(a) {
            return this.compose(_g, a, ah)
        },
        lookAt: function(a, b, c) {
            var d = this.elements;
            return dh.subVectors(a, b),
            0 === dh.lengthSq() && (dh.z = 1),
            dh.normalize(),
            bh.crossVectors(c, dh),
            0 === bh.lengthSq() && (1 === Math.abs(c.z) ? dh.x += 1e-4 : dh.z += 1e-4,
            dh.normalize(),
            bh.crossVectors(c, dh)),
            bh.normalize(),
            ch.crossVectors(dh, bh),
            d[0] = bh.x,
            d[4] = ch.x,
            d[8] = dh.x,
            d[1] = bh.y,
            d[5] = ch.y,
            d[9] = dh.y,
            d[2] = bh.z,
            d[6] = ch.z,
            d[10] = dh.z,
            this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a, this)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements
              , d = b.elements;
            b = this.elements,
            a = c[0];
            var e = c[4]
              , f = c[8]
              , g = c[12]
              , h = c[1]
              , i = c[5]
              , j = c[9]
              , k = c[13]
              , l = c[2]
              , m = c[6]
              , n = c[10]
              , o = c[14]
              , p = c[3]
              , q = c[7]
              , r = c[11];
            c = c[15];
            var s = d[0]
              , t = d[4]
              , u = d[8]
              , v = d[12]
              , w = d[1]
              , x = d[5]
              , y = d[9]
              , z = d[13]
              , A = d[2]
              , B = d[6]
              , C = d[10]
              , D = d[14]
              , E = d[3]
              , F = d[7]
              , G = d[11];
            return d = d[15],
            b[0] = a * s + e * w + f * A + g * E,
            b[4] = a * t + e * x + f * B + g * F,
            b[8] = a * u + e * y + f * C + g * G,
            b[12] = a * v + e * z + f * D + g * d,
            b[1] = h * s + i * w + j * A + k * E,
            b[5] = h * t + i * x + j * B + k * F,
            b[9] = h * u + i * y + j * C + k * G,
            b[13] = h * v + i * z + j * D + k * d,
            b[2] = l * s + m * w + n * A + o * E,
            b[6] = l * t + m * x + n * B + o * F,
            b[10] = l * u + m * y + n * C + o * G,
            b[14] = l * v + m * z + n * D + o * d,
            b[3] = p * s + q * w + r * A + c * E,
            b[7] = p * t + q * x + r * B + c * F,
            b[11] = p * u + q * y + r * C + c * G,
            b[15] = p * v + q * z + r * D + c * d,
            this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a,
            b[4] *= a,
            b[8] *= a,
            b[12] *= a,
            b[1] *= a,
            b[5] *= a,
            b[9] *= a,
            b[13] *= a,
            b[2] *= a,
            b[6] *= a,
            b[10] *= a,
            b[14] *= a,
            b[3] *= a,
            b[7] *= a,
            b[11] *= a,
            b[15] *= a,
            this
        },
        applyToBufferAttribute: function(a) {
            for (var b = 0, c = a.count; c > b; b++)
                Zg.x = a.getX(b),
                Zg.y = a.getY(b),
                Zg.z = a.getZ(b),
                Zg.applyMatrix4(this),
                a.setXYZ(b, Zg.x, Zg.y, Zg.z);
            return a
        },
        determinant: function() {
            var a = this.elements
              , b = a[0]
              , c = a[4]
              , d = a[8]
              , e = a[12]
              , f = a[1]
              , g = a[5]
              , h = a[9]
              , i = a[13]
              , j = a[2]
              , k = a[6]
              , l = a[10]
              , m = a[14];
            return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
        },
        transpose: function() {
            var a = this.elements
              , b = a[1];
            return a[1] = a[4],
            a[4] = b,
            b = a[2],
            a[2] = a[8],
            a[8] = b,
            b = a[6],
            a[6] = a[9],
            a[9] = b,
            b = a[3],
            a[3] = a[12],
            a[12] = b,
            b = a[7],
            a[7] = a[13],
            a[13] = b,
            b = a[11],
            a[11] = a[14],
            a[14] = b,
            this
        },
        setPosition: function(a, b, c) {
            var d = this.elements;
            return a.isVector3 ? (d[12] = a.x,
            d[13] = a.y,
            d[14] = a.z) : (d[12] = a,
            d[13] = b,
            d[14] = c),
            this
        },
        getInverse: function(a, b) {
            var c = this.elements
              , d = a.elements;
            a = d[0];
            var e = d[1]
              , f = d[2]
              , g = d[3]
              , h = d[4]
              , i = d[5]
              , j = d[6]
              , k = d[7]
              , l = d[8]
              , m = d[9]
              , n = d[10]
              , o = d[11]
              , p = d[12]
              , q = d[13]
              , r = d[14];
            d = d[15];
            var s = m * r * k - q * n * k + q * j * o - i * r * o - m * j * d + i * n * d
              , t = p * n * k - l * r * k - p * j * o + h * r * o + l * j * d - h * n * d
              , u = l * q * k - p * m * k + p * i * o - h * q * o - l * i * d + h * m * d
              , v = p * m * j - l * q * j - p * i * n + h * q * n + l * i * r - h * m * r
              , w = a * s + e * t + f * u + g * v;
            if (0 === w) {
                if (!0 === b)
                    throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"),
                this.identity()
            }
            return b = 1 / w,
            c[0] = s * b,
            c[1] = (q * n * g - m * r * g - q * f * o + e * r * o + m * f * d - e * n * d) * b,
            c[2] = (i * r * g - q * j * g + q * f * k - e * r * k - i * f * d + e * j * d) * b,
            c[3] = (m * j * g - i * n * g - m * f * k + e * n * k + i * f * o - e * j * o) * b,
            c[4] = t * b,
            c[5] = (l * r * g - p * n * g + p * f * o - a * r * o - l * f * d + a * n * d) * b,
            c[6] = (p * j * g - h * r * g - p * f * k + a * r * k + h * f * d - a * j * d) * b,
            c[7] = (h * n * g - l * j * g + l * f * k - a * n * k - h * f * o + a * j * o) * b,
            c[8] = u * b,
            c[9] = (p * m * g - l * q * g - p * e * o + a * q * o + l * e * d - a * m * d) * b,
            c[10] = (h * q * g - p * i * g + p * e * k - a * q * k - h * e * d + a * i * d) * b,
            c[11] = (l * i * g - h * m * g - l * e * k + a * m * k + h * e * o - a * i * o) * b,
            c[12] = v * b,
            c[13] = (l * q * f - p * m * f + p * e * n - a * q * n - l * e * r + a * m * r) * b,
            c[14] = (p * i * f - h * q * f - p * e * j + a * q * j + h * e * r - a * i * r) * b,
            c[15] = (h * m * f - l * i * f + l * e * j - a * m * j - h * e * n + a * i * n) * b,
            this
        },
        scale: function(a) {
            var b = this.elements
              , c = a.x
              , d = a.y;
            return a = a.z,
            b[0] *= c,
            b[4] *= d,
            b[8] *= a,
            b[1] *= c,
            b[5] *= d,
            b[9] *= a,
            b[2] *= c,
            b[6] *= d,
            b[10] *= a,
            b[3] *= c,
            b[7] *= d,
            b[11] *= a,
            this
        },
        getMaxScaleOnAxis: function() {
            var a = this.elements;
            return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
        },
        makeTranslation: function(a, b, c) {
            return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a),
            this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a),
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a),
            this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = 1 - c
              , e = a.x
              , f = a.y;
            a = a.z;
            var g = d * e
              , h = d * f;
            return this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(a, b, c) {
            return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(a, b, c) {
            return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(a, b, c) {
            var d = this.elements
              , e = b._x
              , f = b._y
              , g = b._z
              , h = b._w
              , i = e + e
              , j = f + f
              , k = g + g;
            b = e * i;
            var l = e * j;
            e *= k;
            var m = f * j;
            f *= k,
            g *= k,
            i *= h,
            j *= h,
            h *= k,
            k = c.x;
            var n = c.y;
            return c = c.z,
            d[0] = (1 - (m + g)) * k,
            d[1] = (l + h) * k,
            d[2] = (e - j) * k,
            d[3] = 0,
            d[4] = (l - h) * n,
            d[5] = (1 - (b + g)) * n,
            d[6] = (f + i) * n,
            d[7] = 0,
            d[8] = (e + j) * c,
            d[9] = (f - i) * c,
            d[10] = (1 - (b + m)) * c,
            d[11] = 0,
            d[12] = a.x,
            d[13] = a.y,
            d[14] = a.z,
            d[15] = 1,
            this
        },
        decompose: function(a, b, c) {
            var d = this.elements
              , e = Zg.set(d[0], d[1], d[2]).length()
              , f = Zg.set(d[4], d[5], d[6]).length()
              , g = Zg.set(d[8], d[9], d[10]).length();
            0 > this.determinant() && (e = -e),
            a.x = d[12],
            a.y = d[13],
            a.z = d[14],
            $g.copy(this),
            a = 1 / e,
            d = 1 / f;
            var h = 1 / g;
            return $g.elements[0] *= a,
            $g.elements[1] *= a,
            $g.elements[2] *= a,
            $g.elements[4] *= d,
            $g.elements[5] *= d,
            $g.elements[6] *= d,
            $g.elements[8] *= h,
            $g.elements[9] *= h,
            $g.elements[10] *= h,
            b.setFromRotationMatrix($g),
            c.x = e,
            c.y = f,
            c.z = g,
            this
        },
        makePerspective: function(a, b, c, d, e, f) {
            void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var g = this.elements;
            return g[0] = 2 * e / (b - a),
            g[4] = 0,
            g[8] = (b + a) / (b - a),
            g[12] = 0,
            g[1] = 0,
            g[5] = 2 * e / (c - d),
            g[9] = (c + d) / (c - d),
            g[13] = 0,
            g[2] = 0,
            g[6] = 0,
            g[10] = -(f + e) / (f - e),
            g[14] = -2 * f * e / (f - e),
            g[3] = 0,
            g[7] = 0,
            g[11] = -1,
            g[15] = 0,
            this
        },
        makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements
              , h = 1 / (b - a)
              , i = 1 / (c - d)
              , j = 1 / (f - e);
            return g[0] = 2 * h,
            g[4] = 0,
            g[8] = 0,
            g[12] = -((b + a) * h),
            g[1] = 0,
            g[5] = 2 * i,
            g[9] = 0,
            g[13] = -((c + d) * i),
            g[2] = 0,
            g[6] = 0,
            g[10] = -2 * j,
            g[14] = -((f + e) * j),
            g[3] = 0,
            g[7] = 0,
            g[11] = 0,
            g[15] = 1,
            this
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 16 > c; c++)
                if (b[c] !== a[c])
                    return !1;
            return !0
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 16 > c; c++)
                this.elements[c] = a[c + b];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []),
            void 0 === b && (b = 0);
            var c = this.elements;
            return a[b] = c[0],
            a[b + 1] = c[1],
            a[b + 2] = c[2],
            a[b + 3] = c[3],
            a[b + 4] = c[4],
            a[b + 5] = c[5],
            a[b + 6] = c[6],
            a[b + 7] = c[7],
            a[b + 8] = c[8],
            a[b + 9] = c[9],
            a[b + 10] = c[10],
            a[b + 11] = c[11],
            a[b + 12] = c[12],
            a[b + 13] = c[13],
            a[b + 14] = c[14],
            a[b + 15] = c[15],
            a
        }
    });
    var eh = new k
      , fh = new d;
    l.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "),
    l.DefaultOrder = "XYZ",
    Object.defineProperties(l.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(a) {
                this._x = a,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(a) {
                this._y = a,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(a) {
                this._z = a,
                this._onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(a) {
                this._order = a,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign(l.prototype, {
        isEuler: !0,
        set: function(a, b, c, d) {
            return this._x = a,
            this._y = b,
            this._z = c,
            this._order = d || this._order,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(a) {
            return this._x = a._x,
            this._y = a._y,
            this._z = a._z,
            this._order = a._order,
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(a, b, c) {
            var d = Sg.clamp
              , e = a.elements;
            a = e[0];
            var f = e[4]
              , g = e[8]
              , h = e[1]
              , i = e[5]
              , j = e[9]
              , k = e[2]
              , l = e[6];
            return e = e[10],
            b = b || this._order,
            "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)),
            .9999999 > Math.abs(g) ? (this._x = Math.atan2(-j, e),
            this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i),
            this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)),
            .9999999 > Math.abs(j) ? (this._y = Math.atan2(g, e),
            this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a),
            this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)),
            .9999999 > Math.abs(l) ? (this._y = Math.atan2(-k, e),
            this._z = Math.atan2(-f, i)) : (this._y = 0,
            this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)),
            .9999999 > Math.abs(k) ? (this._x = Math.atan2(l, e),
            this._z = Math.atan2(h, a)) : (this._x = 0,
            this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)),
            .9999999 > Math.abs(h) ? (this._x = Math.atan2(-j, i),
            this._y = Math.atan2(-k, a)) : (this._x = 0,
            this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)),
            .9999999 > Math.abs(f) ? (this._x = Math.atan2(l, i),
            this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b),
            this._order = b,
            !1 !== c && this._onChangeCallback(),
            this
        },
        setFromQuaternion: function(a, b, c) {
            return eh.makeRotationFromQuaternion(a),
            this.setFromRotationMatrix(eh, b, c)
        },
        setFromVector3: function(a, b) {
            return this.set(a.x, a.y, a.z, b || this._order)
        },
        reorder: function(a) {
            return fh.setFromEuler(this),
            this.setFromQuaternion(fh, a)
        },
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        },
        fromArray: function(a) {
            return this._x = a[0],
            this._y = a[1],
            this._z = a[2],
            void 0 !== a[3] && (this._order = a[3]),
            this._onChangeCallback(),
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this._x,
            a[b + 1] = this._y,
            a[b + 2] = this._z,
            a[b + 3] = this._order,
            a
        },
        toVector3: function(a) {
            return a ? a.set(this._x, this._y, this._z) : new e(this._x,this._y,this._z)
        },
        _onChange: function(a) {
            return this._onChangeCallback = a,
            this
        },
        _onChangeCallback: function() {}
    }),
    Object.assign(m.prototype, {
        set: function(a) {
            this.mask = 1 << a | 0
        },
        enable: function(a) {
            this.mask = this.mask | 1 << a | 0
        },
        enableAll: function() {
            this.mask = -1
        },
        toggle: function(a) {
            this.mask ^= 1 << a | 0
        },
        disable: function(a) {
            this.mask &= ~(1 << a | 0)
        },
        disableAll: function() {
            this.mask = 0
        },
        test: function(a) {
            return 0 !== (this.mask & a.mask)
        }
    });
    var gh = 0
      , hh = new e
      , ih = new d
      , jh = new k
      , kh = new e
      , lh = new e
      , mh = new e
      , nh = new d
      , oh = new e(1,0,0)
      , ph = new e(0,1,0)
      , qh = new e(0,0,1)
      , rh = {
        type: "added"
    }
      , sh = {
        type: "removed"
    };
    n.DefaultUp = new e(0,1,0),
    n.DefaultMatrixAutoUpdate = !0,
    n.prototype = Object.assign(Object.create(b.prototype), {
        constructor: n,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(a) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(a),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(a) {
            return this.quaternion.premultiply(a),
            this
        },
        setRotationFromAxisAngle: function(a, b) {
            this.quaternion.setFromAxisAngle(a, b)
        },
        setRotationFromEuler: function(a) {
            this.quaternion.setFromEuler(a, !0)
        },
        setRotationFromMatrix: function(a) {
            this.quaternion.setFromRotationMatrix(a)
        },
        setRotationFromQuaternion: function(a) {
            this.quaternion.copy(a)
        },
        rotateOnAxis: function(a, b) {
            return ih.setFromAxisAngle(a, b),
            this.quaternion.multiply(ih),
            this
        },
        rotateOnWorldAxis: function(a, b) {
            return ih.setFromAxisAngle(a, b),
            this.quaternion.premultiply(ih),
            this
        },
        rotateX: function(a) {
            return this.rotateOnAxis(oh, a)
        },
        rotateY: function(a) {
            return this.rotateOnAxis(ph, a)
        },
        rotateZ: function(a) {
            return this.rotateOnAxis(qh, a)
        },
        translateOnAxis: function(a, b) {
            return hh.copy(a).applyQuaternion(this.quaternion),
            this.position.add(hh.multiplyScalar(b)),
            this
        },
        translateX: function(a) {
            return this.translateOnAxis(oh, a)
        },
        translateY: function(a) {
            return this.translateOnAxis(ph, a)
        },
        translateZ: function(a) {
            return this.translateOnAxis(qh, a)
        },
        localToWorld: function(a) {
            return a.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(a) {
            return a.applyMatrix4(jh.getInverse(this.matrixWorld))
        },
        lookAt: function(a, b, c) {
            a.isVector3 ? kh.copy(a) : kh.set(a, b, c),
            a = this.parent,
            this.updateWorldMatrix(!0, !1),
            lh.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? jh.lookAt(lh, kh, this.up) : jh.lookAt(kh, lh, this.up),
            this.quaternion.setFromRotationMatrix(jh),
            a && (jh.extractRotation(a.matrixWorld),
            ih.setFromRotationMatrix(jh),
            this.quaternion.premultiply(ih.inverse()))
        },
        add: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++)
                    this.add(arguments[b]);
                return this
            }
            return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a),
            this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a),
            a.parent = this,
            this.children.push(a),
            a.dispatchEvent(rh)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a),
            this)
        },
        remove: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++)
                    this.remove(arguments[b]);
                return this
            }
            return b = this.children.indexOf(a),
            -1 !== b && (a.parent = null,
            this.children.splice(b, 1),
            a.dispatchEvent(sh)),
            this
        },
        attach: function(a) {
            return this.updateWorldMatrix(!0, !1),
            jh.getInverse(this.matrixWorld),
            null !== a.parent && (a.parent.updateWorldMatrix(!0, !1),
            jh.multiply(a.parent.matrixWorld)),
            a.applyMatrix(jh),
            a.updateWorldMatrix(!1, !1),
            this.add(a),
            this
        },
        getObjectById: function(a) {
            return this.getObjectByProperty("id", a)
        },
        getObjectByName: function(a) {
            return this.getObjectByProperty("name", a)
        },
        getObjectByProperty: function(a, b) {
            if (this[a] === b)
                return this;
            for (var c = 0, d = this.children.length; d > c; c++) {
                var e = this.children[c].getObjectByProperty(a, b);
                if (void 0 !== e)
                    return e
            }
        },
        getWorldPosition: function(a) {
            return void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            a = new e),
            this.updateMatrixWorld(!0),
            a.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(a) {
            return void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            a = new d),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(lh, a, mh),
            a
        },
        getWorldScale: function(a) {
            return void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            a = new e),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(lh, nh, a),
            a
        },
        getWorldDirection: function(a) {
            void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            a = new e),
            this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(b[8], b[9], b[10]).normalize()
        },
        raycast: function() {},
        traverse: function(a) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; d > c; c++)
                b[c].traverse(a)
        },
        traverseVisible: function(a) {
            if (!1 !== this.visible) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; d > c; c++)
                    b[c].traverseVisible(a)
            }
        },
        traverseAncestors: function(a) {
            var b = this.parent;
            null !== b && (a(b),
            b.traverseAncestors(a))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(a) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            a = !0);
            for (var b = this.children, c = 0, d = b.length; d > c; c++)
                b[c].updateMatrixWorld(a)
        },
        updateWorldMatrix: function(a, b) {
            var c = this.parent;
            if (!0 === a && null !== c && c.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === b)
                for (a = this.children,
                b = 0,
                c = a.length; c > b; b++)
                    a[b].updateWorldMatrix(!1, !0)
        },
        toJSON: function(a) {
            function b(b, c) {
                return void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)),
                c.uuid
            }
            function c(a) {
                var b, c = [];
                for (b in a) {
                    var d = a[b];
                    delete d.metadata,
                    c.push(d)
                }
                return c
            }
            var d = void 0 === a || "string" == typeof a
              , e = {};
            d && (a = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            e.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var f = {};
            if (f.uuid = this.uuid,
            f.type = this.type,
            "" !== this.name && (f.name = this.name),
            !0 === this.castShadow && (f.castShadow = !0),
            !0 === this.receiveShadow && (f.receiveShadow = !0),
            !1 === this.visible && (f.visible = !1),
            !1 === this.frustumCulled && (f.frustumCulled = !1),
            0 !== this.renderOrder && (f.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData),
            f.layers = this.layers.mask,
            f.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1),
            this.isInstancedMesh && (f.type = "InstancedMesh",
            f.count = this.count,
            f.instanceMatrix = this.instanceMatrix.toJSON()),
            this.isMesh || this.isLine || this.isPoints) {
                f.geometry = b(a.geometries, this.geometry);
                var g = this.geometry.parameters;
                if (void 0 !== g && void 0 !== g.shapes)
                    if (g = g.shapes,
                    Array.isArray(g))
                        for (var h = 0, i = g.length; i > h; h++)
                            b(a.shapes, g[h]);
                    else
                        b(a.shapes, g)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (g = [],
                    h = 0,
                    i = this.material.length; i > h; h++)
                        g.push(b(a.materials, this.material[h]));
                    f.material = g
                } else
                    f.material = b(a.materials, this.material);
            if (0 < this.children.length)
                for (f.children = [],
                h = 0; h < this.children.length; h++)
                    f.children.push(this.children[h].toJSON(a).object);
            if (d) {
                d = c(a.geometries),
                h = c(a.materials),
                i = c(a.textures);
                var j = c(a.images);
                g = c(a.shapes),
                0 < d.length && (e.geometries = d),
                0 < h.length && (e.materials = h),
                0 < i.length && (e.textures = i),
                0 < j.length && (e.images = j),
                0 < g.length && (e.shapes = g)
            }
            return e.object = f,
            e
        },
        clone: function(a) {
            return (new this.constructor).copy(this, a)
        },
        copy: function(a, b) {
            if (void 0 === b && (b = !0),
            this.name = a.name,
            this.up.copy(a.up),
            this.position.copy(a.position),
            this.quaternion.copy(a.quaternion),
            this.scale.copy(a.scale),
            this.matrix.copy(a.matrix),
            this.matrixWorld.copy(a.matrixWorld),
            this.matrixAutoUpdate = a.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate,
            this.layers.mask = a.layers.mask,
            this.visible = a.visible,
            this.castShadow = a.castShadow,
            this.receiveShadow = a.receiveShadow,
            this.frustumCulled = a.frustumCulled,
            this.renderOrder = a.renderOrder,
            this.userData = JSON.parse(JSON.stringify(a.userData)),
            !0 === b)
                for (b = 0; b < a.children.length; b++)
                    this.add(a.children[b].clone());
            return this
        }
    }),
    o.prototype = Object.assign(Object.create(n.prototype), {
        constructor: o,
        isScene: !0,
        copy: function(a, b) {
            return n.prototype.copy.call(this, a, b),
            null !== a.background && (this.background = a.background.clone()),
            null !== a.environment && (this.environment = a.environment.clone()),
            null !== a.fog && (this.fog = a.fog.clone()),
            null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()),
            this.autoUpdate = a.autoUpdate,
            this.matrixAutoUpdate = a.matrixAutoUpdate,
            this
        },
        toJSON: function(a) {
            var b = n.prototype.toJSON.call(this, a);
            return null !== this.background && (b.object.background = this.background.toJSON(a)),
            null !== this.environment && (b.object.environment = this.environment.toJSON(a)),
            null !== this.fog && (b.object.fog = this.fog.toJSON()),
            b
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var th = [new e, new e, new e, new e, new e, new e, new e, new e]
      , uh = new e
      , vh = new p
      , wh = new e
      , xh = new e
      , yh = new e
      , zh = new e
      , Ah = new e
      , Bh = new e
      , Ch = new e
      , Dh = new e
      , Eh = new e
      , Fh = new e;
    Object.assign(p.prototype, {
        isBox3: !0,
        set: function(a, b) {
            return this.min.copy(a),
            this.max.copy(b),
            this
        },
        setFromArray: function(a) {
            for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.length; i > h; h += 3) {
                var j = a[h]
                  , k = a[h + 1]
                  , l = a[h + 2];
                b > j && (b = j),
                c > k && (c = k),
                d > l && (d = l),
                j > e && (e = j),
                k > f && (f = k),
                l > g && (g = l)
            }
            return this.min.set(b, c, d),
            this.max.set(e, f, g),
            this
        },
        setFromBufferAttribute: function(a) {
            for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.count; i > h; h++) {
                var j = a.getX(h)
                  , k = a.getY(h)
                  , l = a.getZ(h);
                b > j && (b = j),
                c > k && (c = k),
                d > l && (d = l),
                j > e && (e = j),
                k > f && (f = k),
                l > g && (g = l)
            }
            return this.min.set(b, c, d),
            this.max.set(e, f, g),
            this
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; c > b; b++)
                this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function(a, b) {
            return b = uh.copy(b).multiplyScalar(.5),
            this.min.copy(a).sub(b),
            this.max.copy(a).add(b),
            this
        },
        setFromObject: function(a) {
            return this.makeEmpty(),
            this.expandByObject(a)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.min.copy(a.min),
            this.max.copy(a.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"),
            a = new e),
            this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(a) {
            return void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"),
            a = new e),
            this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a),
            this.max.max(a),
            this
        },
        expandByVector: function(a) {
            return this.min.sub(a),
            this.max.add(a),
            this
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a),
            this.max.addScalar(a),
            this
        },
        expandByObject: function(a) {
            a.updateWorldMatrix(!1, !1);
            var b = a.geometry;
            void 0 !== b && (null === b.boundingBox && b.computeBoundingBox(),
            vh.copy(b.boundingBox),
            vh.applyMatrix4(a.matrixWorld),
            this.expandByPoint(vh.min),
            this.expandByPoint(vh.max)),
            a = a.children,
            b = 0;
            for (var c = a.length; c > b; b++)
                this.expandByObject(a[b]);
            return this
        },
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
        },
        getParameter: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"),
            b = new e),
            b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
        },
        intersectsSphere: function(a) {
            return this.clampPoint(a.center, uh),
            uh.distanceToSquared(a.center) <= a.radius * a.radius
        },
        intersectsPlane: function(a) {
            if (0 < a.normal.x)
                var b = a.normal.x * this.min.x
                  , c = a.normal.x * this.max.x;
            else
                b = a.normal.x * this.max.x,
                c = a.normal.x * this.min.x;
            return 0 < a.normal.y ? (b += a.normal.y * this.min.y,
            c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y,
            c += a.normal.y * this.min.y),
            0 < a.normal.z ? (b += a.normal.z * this.min.z,
            c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z,
            c += a.normal.z * this.min.z),
            b <= -a.constant && c >= -a.constant
        },
        intersectsTriangle: function(a) {
            return this.isEmpty() ? !1 : (this.getCenter(Ch),
            Dh.subVectors(this.max, Ch),
            wh.subVectors(a.a, Ch),
            xh.subVectors(a.b, Ch),
            yh.subVectors(a.c, Ch),
            zh.subVectors(xh, wh),
            Ah.subVectors(yh, xh),
            Bh.subVectors(wh, yh),
            a = [0, -zh.z, zh.y, 0, -Ah.z, Ah.y, 0, -Bh.z, Bh.y, zh.z, 0, -zh.x, Ah.z, 0, -Ah.x, Bh.z, 0, -Bh.x, -zh.y, zh.x, 0, -Ah.y, Ah.x, 0, -Bh.y, Bh.x, 0],
            q(a, wh, xh, yh, Dh) ? (a = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            q(a, wh, xh, yh, Dh) ? (Eh.crossVectors(zh, Ah),
            a = [Eh.x, Eh.y, Eh.z],
            q(a, wh, xh, yh, Dh)) : !1) : !1)
        },
        clampPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            b = new e),
            b.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function(a) {
            return uh.copy(a).clamp(this.min, this.max).sub(a).length()
        },
        getBoundingSphere: function(a) {
            return void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
            this.getCenter(a.center),
            a.radius = .5 * this.getSize(uh).length(),
            a
        },
        intersect: function(a) {
            return this.min.max(a.min),
            this.max.min(a.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(a) {
            return this.min.min(a.min),
            this.max.max(a.max),
            this
        },
        applyMatrix4: function(a) {
            return this.isEmpty() ? this : (th[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a),
            th[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a),
            th[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a),
            th[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a),
            th[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a),
            th[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a),
            th[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a),
            th[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a),
            this.setFromPoints(th),
            this)
        },
        translate: function(a) {
            return this.min.add(a),
            this.max.add(a),
            this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    });
    var Gh = new p;
    Object.assign(r.prototype, {
        set: function(a, b) {
            return this.center.copy(a),
            this.radius = b,
            this
        },
        setFromPoints: function(a, b) {
            var c = this.center;
            void 0 !== b ? c.copy(b) : Gh.setFromPoints(a).getCenter(c);
            for (var d = b = 0, e = a.length; e > d; d++)
                b = Math.max(b, c.distanceToSquared(a[d]));
            return this.radius = Math.sqrt(b),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.center.copy(a.center),
            this.radius = a.radius,
            this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        },
        intersectsBox: function(a) {
            return a.intersectsSphere(this)
        },
        intersectsPlane: function(a) {
            return Math.abs(a.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a);
            return void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            b = new e),
            b.copy(a),
            c > this.radius * this.radius && (b.sub(this.center).normalize(),
            b.multiplyScalar(this.radius).add(this.center)),
            b
        },
        getBoundingBox: function(a) {
            return void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            a = new p),
            a.set(this.center, this.center),
            a.expandByScalar(this.radius),
            a
        },
        applyMatrix4: function(a) {
            return this.center.applyMatrix4(a),
            this.radius *= a.getMaxScaleOnAxis(),
            this
        },
        translate: function(a) {
            return this.center.add(a),
            this
        },
        equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius
        }
    });
    var Hh = new e
      , Ih = new e
      , Jh = new e
      , Kh = new e
      , Lh = new e
      , Mh = new e
      , Nh = new e;
    Object.assign(s.prototype, {
        set: function(a, b) {
            return this.origin.copy(a),
            this.direction.copy(b),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.origin.copy(a.origin),
            this.direction.copy(a.direction),
            this
        },
        at: function(a, b) {
            return void 0 === b && (console.warn("THREE.Ray: .at() target is now required"),
            b = new e),
            b.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        lookAt: function(a) {
            return this.direction.copy(a).sub(this.origin).normalize(),
            this
        },
        recast: function(a) {
            return this.origin.copy(this.at(a, Hh)),
            this
        },
        closestPointToPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            b = new e),
            b.subVectors(a, this.origin),
            a = b.dot(this.direction),
            0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        distanceToPoint: function(a) {
            return Math.sqrt(this.distanceSqToPoint(a))
        },
        distanceSqToPoint: function(a) {
            var b = Hh.subVectors(a, this.origin).dot(this.direction);
            return 0 > b ? this.origin.distanceToSquared(a) : (Hh.copy(this.direction).multiplyScalar(b).add(this.origin),
            Hh.distanceToSquared(a))
        },
        distanceSqToSegment: function(a, b, c, d) {
            Ih.copy(a).add(b).multiplyScalar(.5),
            Jh.copy(b).sub(a).normalize(),
            Kh.copy(this.origin).sub(Ih);
            var e = .5 * a.distanceTo(b)
              , f = -this.direction.dot(Jh)
              , g = Kh.dot(this.direction)
              , h = -Kh.dot(Jh)
              , i = Kh.lengthSq()
              , j = Math.abs(1 - f * f);
            if (j > 0) {
                a = f * h - g,
                b = f * g - h;
                var k = e * j;
                a >= 0 ? b >= -k ? k >= b ? (e = 1 / j,
                a *= e,
                b *= e,
                f = a * (a + f * b + 2 * g) + b * (f * a + b + 2 * h) + i) : (b = e,
                a = Math.max(0, -(f * b + g)),
                f = -a * a + b * (b + 2 * h) + i) : (b = -e,
                a = Math.max(0, -(f * b + g)),
                f = -a * a + b * (b + 2 * h) + i) : -k >= b ? (a = Math.max(0, -(-f * e + g)),
                b = a > 0 ? -e : Math.min(Math.max(-e, -h), e),
                f = -a * a + b * (b + 2 * h) + i) : k >= b ? (a = 0,
                b = Math.min(Math.max(-e, -h), e),
                f = b * (b + 2 * h) + i) : (a = Math.max(0, -(f * e + g)),
                b = a > 0 ? e : Math.min(Math.max(-e, -h), e),
                f = -a * a + b * (b + 2 * h) + i)
            } else
                b = f > 0 ? -e : e,
                a = Math.max(0, -(f * b + g)),
                f = -a * a + b * (b + 2 * h) + i;
            return c && c.copy(this.direction).multiplyScalar(a).add(this.origin),
            d && d.copy(Jh).multiplyScalar(b).add(Ih),
            f
        },
        intersectSphere: function(a, b) {
            Hh.subVectors(a.center, this.origin);
            var c = Hh.dot(this.direction)
              , d = Hh.dot(Hh) - c * c;
            return a = a.radius * a.radius,
            d > a ? null : (a = Math.sqrt(a - d),
            d = c - a,
            c += a,
            0 > d && 0 > c ? null : 0 > d ? this.at(c, b) : this.at(d, b))
        },
        intersectsSphere: function(a) {
            return this.distanceSqToPoint(a.center) <= a.radius * a.radius
        },
        distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b,
            a >= 0 ? a : null)
        },
        intersectPlane: function(a, b) {
            return a = this.distanceToPlane(a),
            null === a ? null : this.at(a, b)
        },
        intersectsPlane: function(a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
        },
        intersectBox: function(a, b) {
            var c = 1 / this.direction.x
              , d = 1 / this.direction.y
              , e = 1 / this.direction.z
              , f = this.origin;
            if (c >= 0) {
                var g = (a.min.x - f.x) * c;
                c *= a.max.x - f.x
            } else
                g = (a.max.x - f.x) * c,
                c *= a.min.x - f.x;
            if (d >= 0) {
                var h = (a.min.y - f.y) * d;
                d *= a.max.y - f.y
            } else
                h = (a.max.y - f.y) * d,
                d *= a.min.y - f.y;
            return g > d || h > c ? null : ((h > g || g !== g) && (g = h),
            (c > d || c !== c) && (c = d),
            e >= 0 ? (h = (a.min.z - f.z) * e,
            a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e,
            a = (a.min.z - f.z) * e),
            g > a || h > c ? null : ((h > g || g !== g) && (g = h),
            (c > a || c !== c) && (c = a),
            0 > c ? null : this.at(g >= 0 ? g : c, b)))
        },
        intersectsBox: function(a) {
            return null !== this.intersectBox(a, Hh)
        },
        intersectTriangle: function(a, b, c, d, e) {
            if (Lh.subVectors(b, a),
            Mh.subVectors(c, a),
            Nh.crossVectors(Lh, Mh),
            b = this.direction.dot(Nh),
            b > 0) {
                if (d)
                    return null;
                d = 1
            } else {
                if (!(0 > b))
                    return null;
                d = -1,
                b = -b
            }
            return Kh.subVectors(this.origin, a),
            a = d * this.direction.dot(Mh.crossVectors(Kh, Mh)),
            0 > a ? null : (c = d * this.direction.dot(Lh.cross(Kh)),
            0 > c || a + c > b ? null : (a = -d * Kh.dot(Nh),
            0 > a ? null : this.at(a / b, e)))
        },
        applyMatrix4: function(a) {
            return this.origin.applyMatrix4(a),
            this.direction.transformDirection(a),
            this
        },
        equals: function(a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        }
    });
    var Oh = new e
      , Ph = new e
      , Qh = new f;
    Object.assign(t.prototype, {
        isPlane: !0,
        set: function(a, b) {
            return this.normal.copy(a),
            this.constant = b,
            this
        },
        setComponents: function(a, b, c, d) {
            return this.normal.set(a, b, c),
            this.constant = d,
            this
        },
        setFromNormalAndCoplanarPoint: function(a, b) {
            return this.normal.copy(a),
            this.constant = -b.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function(a, b, c) {
            return b = Oh.subVectors(c, b).cross(Ph.subVectors(a, b)).normalize(),
            this.setFromNormalAndCoplanarPoint(b, a),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.normal.copy(a.normal),
            this.constant = a.constant,
            this
        },
        normalize: function() {
            var a = 1 / this.normal.length();
            return this.normal.multiplyScalar(a),
            this.constant *= a,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant
        },
        distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius
        },
        projectPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            b = new e),
            b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
        },
        intersectLine: function(a, b) {
            void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            b = new e);
            var c = a.delta(Oh)
              , d = this.normal.dot(c);
            if (0 === d) {
                if (0 === this.distanceToPoint(a.start))
                    return b.copy(a.start)
            } else if (d = -(a.start.dot(this.normal) + this.constant) / d,
            !(0 > d || d > 1))
                return b.copy(c).multiplyScalar(d).add(a.start)
        },
        intersectsLine: function(a) {
            var b = this.distanceToPoint(a.start);
            return a = this.distanceToPoint(a.end),
            0 > b && a > 0 || 0 > a && b > 0
        },
        intersectsBox: function(a) {
            return a.intersectsPlane(this)
        },
        intersectsSphere: function(a) {
            return a.intersectsPlane(this)
        },
        coplanarPoint: function(a) {
            return void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            a = new e),
            a.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function(a, b) {
            return b = b || Qh.getNormalMatrix(a),
            a = this.coplanarPoint(Oh).applyMatrix4(a),
            b = this.normal.applyMatrix3(b).normalize(),
            this.constant = -a.dot(b),
            this
        },
        translate: function(a) {
            return this.constant -= a.dot(this.normal),
            this
        },
        equals: function(a) {
            return a.normal.equals(this.normal) && a.constant === this.constant
        }
    });
    var Rh = new e
      , Sh = new e
      , Th = new e
      , Uh = new e
      , Vh = new e
      , Wh = new e
      , Xh = new e
      , Yh = new e
      , Zh = new e
      , $h = new e;
    Object.assign(u, {
        getNormal: function(a, b, c, d) {
            return void 0 === d && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            d = new e),
            d.subVectors(c, b),
            Rh.subVectors(a, b),
            d.cross(Rh),
            a = d.lengthSq(),
            a > 0 ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0)
        },
        getBarycoord: function(a, b, c, d, f) {
            Rh.subVectors(d, b),
            Sh.subVectors(c, b),
            Th.subVectors(a, b),
            a = Rh.dot(Rh),
            b = Rh.dot(Sh),
            c = Rh.dot(Th);
            var g = Sh.dot(Sh);
            d = Sh.dot(Th);
            var h = a * g - b * b;
            return void 0 === f && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            f = new e),
            0 === h ? f.set(-2, -1, -1) : (h = 1 / h,
            g = (g * c - b * d) * h,
            a = (a * d - b * c) * h,
            f.set(1 - g - a, a, g))
        },
        containsPoint: function(a, b, c, d) {
            return u.getBarycoord(a, b, c, d, Uh),
            0 <= Uh.x && 0 <= Uh.y && 1 >= Uh.x + Uh.y
        },
        getUV: function(a, b, c, d, e, f, g, h) {
            return this.getBarycoord(a, b, c, d, Uh),
            h.set(0, 0),
            h.addScaledVector(e, Uh.x),
            h.addScaledVector(f, Uh.y),
            h.addScaledVector(g, Uh.z),
            h
        },
        isFrontFacing: function(a, b, c, d) {
            return Rh.subVectors(c, b),
            Sh.subVectors(a, b),
            0 > Rh.cross(Sh).dot(d) ? !0 : !1
        }
    }),
    Object.assign(u.prototype, {
        set: function(a, b, c) {
            return this.a.copy(a),
            this.b.copy(b),
            this.c.copy(c),
            this
        },
        setFromPointsAndIndices: function(a, b, c, d) {
            return this.a.copy(a[b]),
            this.b.copy(a[c]),
            this.c.copy(a[d]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.a.copy(a.a),
            this.b.copy(a.b),
            this.c.copy(a.c),
            this
        },
        getArea: function() {
            return Rh.subVectors(this.c, this.b),
            Sh.subVectors(this.a, this.b),
            .5 * Rh.cross(Sh).length()
        },
        getMidpoint: function(a) {
            return void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            a = new e),
            a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(a) {
            return u.getNormal(this.a, this.b, this.c, a)
        },
        getPlane: function(a) {
            return void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            a = new t),
            a.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(a, b) {
            return u.getBarycoord(a, this.a, this.b, this.c, b)
        },
        getUV: function(a, b, c, d, e) {
            return u.getUV(a, this.a, this.b, this.c, b, c, d, e)
        },
        containsPoint: function(a) {
            return u.containsPoint(a, this.a, this.b, this.c)
        },
        isFrontFacing: function(a) {
            return u.isFrontFacing(this.a, this.b, this.c, a)
        },
        intersectsBox: function(a) {
            return a.intersectsTriangle(this)
        },
        closestPointToPoint: function(a, b) {
            void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            b = new e);
            var c = this.a
              , d = this.b
              , f = this.c;
            Vh.subVectors(d, c),
            Wh.subVectors(f, c),
            Yh.subVectors(a, c);
            var g = Vh.dot(Yh)
              , h = Wh.dot(Yh);
            if (0 >= g && 0 >= h)
                return b.copy(c);
            Zh.subVectors(a, d);
            var i = Vh.dot(Zh)
              , j = Wh.dot(Zh);
            if (i >= 0 && i >= j)
                return b.copy(d);
            var k = g * j - i * h;
            if (0 >= k && g >= 0 && 0 >= i)
                return d = g / (g - i),
                b.copy(c).addScaledVector(Vh, d);
            $h.subVectors(a, f),
            a = Vh.dot($h);
            var l = Wh.dot($h);
            return l >= 0 && l >= a ? b.copy(f) : (g = a * h - g * l,
            0 >= g && h >= 0 && 0 >= l ? (k = h / (h - l),
            b.copy(c).addScaledVector(Wh, k)) : (h = i * l - a * j,
            0 >= h && j - i >= 0 && a - l >= 0 ? (Xh.subVectors(f, d),
            k = (j - i) / (j - i + (a - l)),
            b.copy(d).addScaledVector(Xh, k)) : (f = 1 / (h + g + k),
            d = g * f,
            k *= f,
            b.copy(c).addScaledVector(Vh, d).addScaledVector(Wh, k))))
        },
        equals: function(a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
        }
    });
    var _h = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , ai = {
        h: 0,
        s: 0,
        l: 0
    }
      , bi = {
        h: 0,
        s: 0,
        l: 0
    };
    Object.assign(v.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(a) {
            return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a),
            this
        },
        setScalar: function(a) {
            return this.b = this.g = this.r = a,
            this
        },
        setHex: function(a) {
            return a = Math.floor(a),
            this.r = (a >> 16 & 255) / 255,
            this.g = (a >> 8 & 255) / 255,
            this.b = (255 & a) / 255,
            this
        },
        setRGB: function(a, b, c) {
            return this.r = a,
            this.g = b,
            this.b = c,
            this
        },
        setHSL: function(a, b, c) {
            return a = Sg.euclideanModulo(a, 1),
            b = Sg.clamp(b, 0, 1),
            c = Sg.clamp(c, 0, 1),
            0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b,
            c = 2 * c - b,
            this.r = w(c, b, a + 1 / 3),
            this.g = w(c, b, a),
            this.b = w(c, b, a - 1 / 3)),
            this
        },
        setStyle: function(a) {
            function b(b) {
                void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
            }
            var c;
            if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                var d = c[2];
                switch (c[1]) {
                case "rgb":
                case "rgba":
                    if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))
                        return this.r = Math.min(255, parseInt(c[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(c[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(c[3], 10)) / 255,
                        b(c[5]),
                        this;
                    if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))
                        return this.r = Math.min(100, parseInt(c[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(c[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(c[3], 10)) / 100,
                        b(c[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                        d = parseFloat(c[1]) / 360;
                        var e = parseInt(c[2], 10) / 100
                          , f = parseInt(c[3], 10) / 100;
                        return b(c[5]),
                        this.setHSL(d, e, f)
                    }
                }
            } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
                if (c = c[1],
                d = c.length,
                3 === d)
                    return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                    this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                    this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                    this;
                if (6 === d)
                    return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                    this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                    this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                    this
            }
            return a && 0 < a.length ? this.setColorName(a) : this
        },
        setColorName: function(a) {
            var b = _h[a];
            return void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + a),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(a) {
            return this.r = a.r,
            this.g = a.g,
            this.b = a.b,
            this
        },
        copyGammaToLinear: function(a, b) {
            return void 0 === b && (b = 2),
            this.r = Math.pow(a.r, b),
            this.g = Math.pow(a.g, b),
            this.b = Math.pow(a.b, b),
            this
        },
        copyLinearToGamma: function(a, b) {
            return void 0 === b && (b = 2),
            b = b > 0 ? 1 / b : 1,
            this.r = Math.pow(a.r, b),
            this.g = Math.pow(a.g, b),
            this.b = Math.pow(a.b, b),
            this
        },
        convertGammaToLinear: function(a) {
            return this.copyGammaToLinear(this, a),
            this
        },
        convertLinearToGamma: function(a) {
            return this.copyLinearToGamma(this, a),
            this
        },
        copySRGBToLinear: function(a) {
            return this.r = x(a.r),
            this.g = x(a.g),
            this.b = x(a.b),
            this
        },
        copyLinearToSRGB: function(a) {
            return this.r = y(a.r),
            this.g = y(a.g),
            this.b = y(a.b),
            this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(a) {
            void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"),
            a = {
                h: 0,
                s: 0,
                l: 0
            });
            var b, c = this.r, d = this.g, e = this.b, f = Math.max(c, d, e), g = Math.min(c, d, e), h = (g + f) / 2;
            if (g === f)
                g = b = 0;
            else {
                var i = f - g;
                switch (g = .5 >= h ? i / (f + g) : i / (2 - f - g),
                f) {
                case c:
                    b = (d - e) / i + (e > d ? 6 : 0);
                    break;
                case d:
                    b = (e - c) / i + 2;
                    break;
                case e:
                    b = (c - d) / i + 4
                }
                b /= 6
            }
            return a.h = b,
            a.s = g,
            a.l = h,
            a
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(a, b, c) {
            return this.getHSL(ai),
            ai.h += a,
            ai.s += b,
            ai.l += c,
            this.setHSL(ai.h, ai.s, ai.l),
            this
        },
        add: function(a) {
            return this.r += a.r,
            this.g += a.g,
            this.b += a.b,
            this
        },
        addColors: function(a, b) {
            return this.r = a.r + b.r,
            this.g = a.g + b.g,
            this.b = a.b + b.b,
            this
        },
        addScalar: function(a) {
            return this.r += a,
            this.g += a,
            this.b += a,
            this
        },
        sub: function(a) {
            return this.r = Math.max(0, this.r - a.r),
            this.g = Math.max(0, this.g - a.g),
            this.b = Math.max(0, this.b - a.b),
            this
        },
        multiply: function(a) {
            return this.r *= a.r,
            this.g *= a.g,
            this.b *= a.b,
            this
        },
        multiplyScalar: function(a) {
            return this.r *= a,
            this.g *= a,
            this.b *= a,
            this
        },
        lerp: function(a, b) {
            return this.r += (a.r - this.r) * b,
            this.g += (a.g - this.g) * b,
            this.b += (a.b - this.b) * b,
            this
        },
        lerpHSL: function(a, b) {
            this.getHSL(ai),
            a.getHSL(bi),
            a = Sg.lerp(ai.h, bi.h, b);
            var c = Sg.lerp(ai.s, bi.s, b);
            return b = Sg.lerp(ai.l, bi.l, b),
            this.setHSL(a, c, b),
            this
        },
        equals: function(a) {
            return a.r === this.r && a.g === this.g && a.b === this.b
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0),
            this.r = a[b],
            this.g = a[b + 1],
            this.b = a[b + 2],
            this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []),
            void 0 === b && (b = 0),
            a[b] = this.r,
            a[b + 1] = this.g,
            a[b + 2] = this.b,
            a
        },
        toJSON: function() {
            return this.getHex()
        }
    }),
    v.NAMES = _h,
    Object.assign(z.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.a = a.a,
            this.b = a.b,
            this.c = a.c,
            this.normal.copy(a.normal),
            this.color.copy(a.color),
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; c > b; b++)
                this.vertexNormals[b] = a.vertexNormals[b].clone();
            for (b = 0,
            c = a.vertexColors.length; c > b; b++)
                this.vertexColors[b] = a.vertexColors[b].clone();
            return this
        }
    });
    var ci = 0;
    A.prototype = Object.assign(Object.create(b.prototype), {
        constructor: A,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(a) {
            if (void 0 !== a)
                for (var b in a) {
                    var c = a[b];
                    if (void 0 === c)
                        console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                    else if ("shading" === b)
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = 1 === c ? !0 : !1;
                    else {
                        var d = this[b];
                        void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = c
                    }
                }
        },
        toJSON: function(a) {
            function b(a) {
                var b, c = [];
                for (b in a) {
                    var d = a[b];
                    delete d.metadata,
                    c.push(d)
                }
                return c
            }
            var c = void 0 === a || "string" == typeof a;
            c && (a = {
                textures: {},
                images: {}
            });
            var d = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return d.uuid = this.uuid,
            d.type = this.type,
            "" !== this.name && (d.name = this.name),
            this.color && this.color.isColor && (d.color = this.color.getHex()),
            void 0 !== this.roughness && (d.roughness = this.roughness),
            void 0 !== this.metalness && (d.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (d.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (d.specular = this.specular.getHex()),
            void 0 !== this.shininess && (d.shininess = this.shininess),
            void 0 !== this.clearcoat && (d.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (d.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (d.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid,
            d.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid),
            this.matcap && this.matcap.isTexture && (d.matcap = this.matcap.toJSON(a).uuid),
            this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid),
            this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid),
            this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid,
            d.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid,
            d.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid,
            d.normalMapType = this.normalMapType,
            d.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid,
            d.displacementScale = this.displacementScale,
            d.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid),
            this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid),
            this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid,
            d.reflectivity = this.reflectivity,
            d.refractionRatio = this.refractionRatio,
            void 0 !== this.combine && (d.combine = this.combine),
            void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid),
            void 0 !== this.size && (d.size = this.size),
            void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (d.blending = this.blending),
            !0 === this.flatShading && (d.flatShading = this.flatShading),
            0 !== this.side && (d.side = this.side),
            0 !== this.vertexColors && (d.vertexColors = this.vertexColors),
            1 > this.opacity && (d.opacity = this.opacity),
            !0 === this.transparent && (d.transparent = this.transparent),
            d.depthFunc = this.depthFunc,
            d.depthTest = this.depthTest,
            d.depthWrite = this.depthWrite,
            d.stencilWrite = this.stencilWrite,
            d.stencilWriteMask = this.stencilWriteMask,
            d.stencilFunc = this.stencilFunc,
            d.stencilRef = this.stencilRef,
            d.stencilFuncMask = this.stencilFuncMask,
            d.stencilFail = this.stencilFail,
            d.stencilZFail = this.stencilZFail,
            d.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (d.rotation = this.rotation),
            !0 === this.polygonOffset && (d.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (d.linewidth = this.linewidth),
            void 0 !== this.dashSize && (d.dashSize = this.dashSize),
            void 0 !== this.gapSize && (d.gapSize = this.gapSize),
            void 0 !== this.scale && (d.scale = this.scale),
            !0 === this.dithering && (d.dithering = !0),
            0 < this.alphaTest && (d.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (d.wireframe = this.wireframe),
            1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (d.morphTargets = !0),
            !0 === this.morphNormals && (d.morphNormals = !0),
            !0 === this.skinning && (d.skinning = !0),
            !1 === this.visible && (d.visible = !1),
            !1 === this.toneMapped && (d.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData),
            c && (c = b(a.textures),
            a = b(a.images),
            0 < c.length && (d.textures = c),
            0 < a.length && (d.images = a)),
            d
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.name = a.name,
            this.fog = a.fog,
            this.blending = a.blending,
            this.side = a.side,
            this.flatShading = a.flatShading,
            this.vertexTangents = a.vertexTangents,
            this.vertexColors = a.vertexColors,
            this.opacity = a.opacity,
            this.transparent = a.transparent,
            this.blendSrc = a.blendSrc,
            this.blendDst = a.blendDst,
            this.blendEquation = a.blendEquation,
            this.blendSrcAlpha = a.blendSrcAlpha,
            this.blendDstAlpha = a.blendDstAlpha,
            this.blendEquationAlpha = a.blendEquationAlpha,
            this.depthFunc = a.depthFunc,
            this.depthTest = a.depthTest,
            this.depthWrite = a.depthWrite,
            this.stencilWriteMask = a.stencilWriteMask,
            this.stencilFunc = a.stencilFunc,
            this.stencilRef = a.stencilRef,
            this.stencilFuncMask = a.stencilFuncMask,
            this.stencilFail = a.stencilFail,
            this.stencilZFail = a.stencilZFail,
            this.stencilZPass = a.stencilZPass,
            this.stencilWrite = a.stencilWrite;
            var b = a.clippingPlanes
              , c = null;
            if (null !== b) {
                var d = b.length;
                c = Array(d);
                for (var e = 0; e !== d; ++e)
                    c[e] = b[e].clone()
            }
            return this.clippingPlanes = c,
            this.clipIntersection = a.clipIntersection,
            this.clipShadows = a.clipShadows,
            this.shadowSide = a.shadowSide,
            this.colorWrite = a.colorWrite,
            this.precision = a.precision,
            this.polygonOffset = a.polygonOffset,
            this.polygonOffsetFactor = a.polygonOffsetFactor,
            this.polygonOffsetUnits = a.polygonOffsetUnits,
            this.dithering = a.dithering,
            this.alphaTest = a.alphaTest,
            this.premultipliedAlpha = a.premultipliedAlpha,
            this.visible = a.visible,
            this.toneMapped = a.toneMapped,
            this.userData = JSON.parse(JSON.stringify(a.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(A.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    }),
    B.prototype = Object.create(A.prototype),
    B.prototype.constructor = B,
    B.prototype.isMeshBasicMaterial = !0,
    B.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.map = a.map,
        this.lightMap = a.lightMap,
        this.lightMapIntensity = a.lightMapIntensity,
        this.aoMap = a.aoMap,
        this.aoMapIntensity = a.aoMapIntensity,
        this.specularMap = a.specularMap,
        this.alphaMap = a.alphaMap,
        this.envMap = a.envMap,
        this.combine = a.combine,
        this.reflectivity = a.reflectivity,
        this.refractionRatio = a.refractionRatio,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.wireframeLinecap = a.wireframeLinecap,
        this.wireframeLinejoin = a.wireframeLinejoin,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this
    }
    ;
    var di = new e;
    Object.defineProperty(C.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    }),
    Object.assign(C.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(a) {
            return this.usage = a,
            this
        },
        copy: function(a) {
            return this.name = a.name,
            this.array = new a.array.constructor(a.array),
            this.itemSize = a.itemSize,
            this.count = a.count,
            this.normalized = a.normalized,
            this.usage = a.usage,
            this
        },
        copyAt: function(a, b, c) {
            a *= this.itemSize,
            c *= b.itemSize;
            for (var d = 0, e = this.itemSize; e > d; d++)
                this.array[a + d] = b.array[c + d];
            return this
        },
        copyArray: function(a) {
            return this.array.set(a),
            this
        },
        copyColorsArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d),
                f = new v),
                b[c++] = f.r,
                b[c++] = f.g,
                b[c++] = f.b
            }
            return this
        },
        copyVector2sArray: function(a) {
            for (var b = this.array, d = 0, e = 0, f = a.length; f > e; e++) {
                var g = a[e];
                void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e),
                g = new c),
                b[d++] = g.x,
                b[d++] = g.y
            }
            return this
        },
        copyVector3sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, f = a.length; f > d; d++) {
                var g = a[d];
                void 0 === g && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d),
                g = new e),
                b[c++] = g.x,
                b[c++] = g.y,
                b[c++] = g.z
            }
            return this
        },
        copyVector4sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d),
                f = new h),
                b[c++] = f.x,
                b[c++] = f.y,
                b[c++] = f.z,
                b[c++] = f.w
            }
            return this
        },
        applyMatrix3: function(a) {
            for (var b = 0, c = this.count; c > b; b++)
                di.x = this.getX(b),
                di.y = this.getY(b),
                di.z = this.getZ(b),
                di.applyMatrix3(a),
                this.setXYZ(b, di.x, di.y, di.z);
            return this
        },
        applyMatrix4: function(a) {
            for (var b = 0, c = this.count; c > b; b++)
                di.x = this.getX(b),
                di.y = this.getY(b),
                di.z = this.getZ(b),
                di.applyMatrix4(a),
                this.setXYZ(b, di.x, di.y, di.z);
            return this
        },
        applyNormalMatrix: function(a) {
            for (var b = 0, c = this.count; c > b; b++)
                di.x = this.getX(b),
                di.y = this.getY(b),
                di.z = this.getZ(b),
                di.applyNormalMatrix(a),
                this.setXYZ(b, di.x, di.y, di.z);
            return this
        },
        transformDirection: function(a) {
            for (var b = 0, c = this.count; c > b; b++)
                di.x = this.getX(b),
                di.y = this.getY(b),
                di.z = this.getZ(b),
                di.transformDirection(a),
                this.setXYZ(b, di.x, di.y, di.z);
            return this
        },
        set: function(a, b) {
            return void 0 === b && (b = 0),
            this.array.set(a, b),
            this
        },
        getX: function(a) {
            return this.array[a * this.itemSize]
        },
        setX: function(a, b) {
            return this.array[a * this.itemSize] = b,
            this
        },
        getY: function(a) {
            return this.array[a * this.itemSize + 1]
        },
        setY: function(a, b) {
            return this.array[a * this.itemSize + 1] = b,
            this
        },
        getZ: function(a) {
            return this.array[a * this.itemSize + 2]
        },
        setZ: function(a, b) {
            return this.array[a * this.itemSize + 2] = b,
            this
        },
        getW: function(a) {
            return this.array[a * this.itemSize + 3]
        },
        setW: function(a, b) {
            return this.array[a * this.itemSize + 3] = b,
            this
        },
        setXY: function(a, b, c) {
            return a *= this.itemSize,
            this.array[a + 0] = b,
            this.array[a + 1] = c,
            this
        },
        setXYZ: function(a, b, c, d) {
            return a *= this.itemSize,
            this.array[a + 0] = b,
            this.array[a + 1] = c,
            this.array[a + 2] = d,
            this
        },
        setXYZW: function(a, b, c, d, e) {
            return a *= this.itemSize,
            this.array[a + 0] = b,
            this.array[a + 1] = c,
            this.array[a + 2] = d,
            this.array[a + 3] = e,
            this
        },
        onUpload: function(a) {
            return this.onUploadCallback = a,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }),
    D.prototype = Object.create(C.prototype),
    D.prototype.constructor = D,
    E.prototype = Object.create(C.prototype),
    E.prototype.constructor = E,
    F.prototype = Object.create(C.prototype),
    F.prototype.constructor = F,
    G.prototype = Object.create(C.prototype),
    G.prototype.constructor = G,
    H.prototype = Object.create(C.prototype),
    H.prototype.constructor = H,
    I.prototype = Object.create(C.prototype),
    I.prototype.constructor = I,
    J.prototype = Object.create(C.prototype),
    J.prototype.constructor = J,
    K.prototype = Object.create(C.prototype),
    K.prototype.constructor = K,
    L.prototype = Object.create(C.prototype),
    L.prototype.constructor = L,
    Object.assign(M.prototype, {
        computeGroups: function(a) {
            var b = []
              , c = void 0;
            a = a.faces;
            for (var d = 0; d < a.length; d++) {
                var e = a[d];
                if (e.materialIndex !== c) {
                    c = e.materialIndex,
                    void 0 !== f && (f.count = 3 * d - f.start,
                    b.push(f));
                    var f = {
                        start: 3 * d,
                        materialIndex: c
                    }
                }
            }
            void 0 !== f && (f.count = 3 * d - f.start,
            b.push(f)),
            this.groups = b
        },
        fromGeometry: function(a) {
            var b = a.faces
              , d = a.vertices
              , e = a.faceVertexUvs
              , f = e[0] && 0 < e[0].length
              , g = e[1] && 0 < e[1].length
              , h = a.morphTargets
              , i = h.length;
            if (i > 0) {
                for (var j = [], k = 0; i > k; k++)
                    j[k] = {
                        name: h[k].name,
                        data: []
                    };
                this.morphTargets.position = j
            }
            var l = a.morphNormals
              , m = l.length;
            if (m > 0) {
                var n = [];
                for (k = 0; m > k; k++)
                    n[k] = {
                        name: l[k].name,
                        data: []
                    };
                this.morphTargets.normal = n
            }
            var o = a.skinIndices
              , p = a.skinWeights
              , q = o.length === d.length
              , r = p.length === d.length;
            for (0 < d.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."),
            k = 0; k < b.length; k++) {
                var s = b[k];
                this.vertices.push(d[s.a], d[s.b], d[s.c]);
                var t = s.vertexNormals;
                for (3 === t.length ? this.normals.push(t[0], t[1], t[2]) : (t = s.normal,
                this.normals.push(t, t, t)),
                t = s.vertexColors,
                3 === t.length ? this.colors.push(t[0], t[1], t[2]) : (t = s.color,
                this.colors.push(t, t, t)),
                !0 === f && (t = e[0][k],
                void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k),
                this.uvs.push(new c, new c, new c))),
                !0 === g && (t = e[1][k],
                void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k),
                this.uvs2.push(new c, new c, new c))),
                t = 0; i > t; t++) {
                    var u = h[t].vertices;
                    j[t].data.push(u[s.a], u[s.b], u[s.c])
                }
                for (t = 0; m > t; t++)
                    u = l[t].vertexNormals[k],
                    n[t].data.push(u.a, u.b, u.c);
                q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]),
                r && this.skinWeights.push(p[s.a], p[s.b], p[s.c])
            }
            return this.computeGroups(a),
            this.verticesNeedUpdate = a.verticesNeedUpdate,
            this.normalsNeedUpdate = a.normalsNeedUpdate,
            this.colorsNeedUpdate = a.colorsNeedUpdate,
            this.uvsNeedUpdate = a.uvsNeedUpdate,
            this.groupsNeedUpdate = a.groupsNeedUpdate,
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()),
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()),
            this
        }
    });
    var ei = 1
      , fi = new k
      , gi = new n
      , hi = new e
      , ii = new p
      , ji = new p
      , ki = new e;
    O.prototype = Object.assign(Object.create(b.prototype), {
        constructor: O,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(a) {
            this.index = Array.isArray(a) ? new (65535 < N(a) ? J : H)(a,1) : a
        },
        getAttribute: function(a) {
            return this.attributes[a]
        },
        setAttribute: function(a, b) {
            return this.attributes[a] = b,
            this
        },
        deleteAttribute: function(a) {
            return delete this.attributes[a],
            this
        },
        addGroup: function(a, b, c) {
            this.groups.push({
                start: a,
                count: b,
                materialIndex: void 0 !== c ? c : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(a, b) {
            this.drawRange.start = a,
            this.drawRange.count = b
        },
        applyMatrix: function(a) {
            var b = this.attributes.position;
            if (void 0 !== b && (b.applyMatrix4(a),
            b.needsUpdate = !0),
            b = this.attributes.normal,
            void 0 !== b) {
                var c = (new f).getNormalMatrix(a);
                b.applyNormalMatrix(c),
                b.needsUpdate = !0
            }
            return b = this.attributes.tangent,
            void 0 !== b && (b.transformDirection(a),
            b.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function(a) {
            return fi.makeRotationX(a),
            this.applyMatrix(fi),
            this
        },
        rotateY: function(a) {
            return fi.makeRotationY(a),
            this.applyMatrix(fi),
            this
        },
        rotateZ: function(a) {
            return fi.makeRotationZ(a),
            this.applyMatrix(fi),
            this
        },
        translate: function(a, b, c) {
            return fi.makeTranslation(a, b, c),
            this.applyMatrix(fi),
            this
        },
        scale: function(a, b, c) {
            return fi.makeScale(a, b, c),
            this.applyMatrix(fi),
            this
        },
        lookAt: function(a) {
            return gi.lookAt(a),
            gi.updateMatrix(),
            this.applyMatrix(gi.matrix),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(hi).negate(),
            this.translate(hi.x, hi.y, hi.z),
            this
        },
        setFromObject: function(a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
                a = new K(3 * b.vertices.length,3);
                var c = new K(3 * b.colors.length,3);
                this.setAttribute("position", a.copyVector3sArray(b.vertices)),
                this.setAttribute("color", c.copyColorsArray(b.colors)),
                b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new K(b.lineDistances.length,1),
                this.setAttribute("lineDistance", a.copyArray(b.lineDistances))),
                null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()),
                null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
            } else
                a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this
        },
        setFromPoints: function(a) {
            for (var b = [], c = 0, d = a.length; d > c; c++) {
                var e = a[c];
                b.push(e.x, e.y, e.z || 0)
            }
            return this.setAttribute("position", new K(b,3)),
            this
        },
        updateFromObject: function(a) {
            var b = a.geometry;
            if (a.isMesh) {
                var c = b.__directGeometry;
                if (!0 === b.elementsNeedUpdate && (c = void 0,
                b.elementsNeedUpdate = !1),
                void 0 === c)
                    return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate,
                c.normalsNeedUpdate = b.normalsNeedUpdate,
                c.colorsNeedUpdate = b.colorsNeedUpdate,
                c.uvsNeedUpdate = b.uvsNeedUpdate,
                c.groupsNeedUpdate = b.groupsNeedUpdate,
                b.verticesNeedUpdate = !1,
                b.normalsNeedUpdate = !1,
                b.colorsNeedUpdate = !1,
                b.uvsNeedUpdate = !1,
                b.groupsNeedUpdate = !1,
                b = c
            }
            return !0 === b.verticesNeedUpdate && (c = this.attributes.position,
            void 0 !== c && (c.copyVector3sArray(b.vertices),
            c.needsUpdate = !0),
            b.verticesNeedUpdate = !1),
            !0 === b.normalsNeedUpdate && (c = this.attributes.normal,
            void 0 !== c && (c.copyVector3sArray(b.normals),
            c.needsUpdate = !0),
            b.normalsNeedUpdate = !1),
            !0 === b.colorsNeedUpdate && (c = this.attributes.color,
            void 0 !== c && (c.copyColorsArray(b.colors),
            c.needsUpdate = !0),
            b.colorsNeedUpdate = !1),
            b.uvsNeedUpdate && (c = this.attributes.uv,
            void 0 !== c && (c.copyVector2sArray(b.uvs),
            c.needsUpdate = !0),
            b.uvsNeedUpdate = !1),
            b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance,
            void 0 !== c && (c.copyArray(b.lineDistances),
            c.needsUpdate = !0),
            b.lineDistancesNeedUpdate = !1),
            b.groupsNeedUpdate && (b.computeGroups(a.geometry),
            this.groups = b.groups,
            b.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(a) {
            return a.__directGeometry = (new M).fromGeometry(a),
            this.fromDirectGeometry(a.__directGeometry)
        },
        fromDirectGeometry: function(a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.setAttribute("position", new C(b,3).copyVector3sArray(a.vertices)),
            0 < a.normals.length && (b = new Float32Array(3 * a.normals.length),
            this.setAttribute("normal", new C(b,3).copyVector3sArray(a.normals))),
            0 < a.colors.length && (b = new Float32Array(3 * a.colors.length),
            this.setAttribute("color", new C(b,3).copyColorsArray(a.colors))),
            0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length),
            this.setAttribute("uv", new C(b,2).copyVector2sArray(a.uvs))),
            0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length),
            this.setAttribute("uv2", new C(b,2).copyVector2sArray(a.uvs2))),
            this.groups = a.groups;
            for (var c in a.morphTargets) {
                b = [];
                for (var d = a.morphTargets[c], e = 0, f = d.length; f > e; e++) {
                    var g = d[e]
                      , h = new K(3 * g.data.length,3);
                    h.name = g.name,
                    b.push(h.copyVector3sArray(g.data))
                }
                this.morphAttributes[c] = b
            }
            return 0 < a.skinIndices.length && (c = new K(4 * a.skinIndices.length,4),
            this.setAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))),
            0 < a.skinWeights.length && (c = new K(4 * a.skinWeights.length,4),
            this.setAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))),
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()),
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new p);
            var a = this.attributes.position
              , b = this.morphAttributes.position;
            if (void 0 !== a) {
                if (this.boundingBox.setFromBufferAttribute(a),
                b) {
                    a = 0;
                    for (var c = b.length; c > a; a++)
                        ii.setFromBufferAttribute(b[a]),
                        this.morphTargetsRelative ? (ki.addVectors(this.boundingBox.min, ii.min),
                        this.boundingBox.expandByPoint(ki),
                        ki.addVectors(this.boundingBox.max, ii.max),
                        this.boundingBox.expandByPoint(ki)) : (this.boundingBox.expandByPoint(ii.min),
                        this.boundingBox.expandByPoint(ii.max))
                }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new r);
            var a = this.attributes.position
              , b = this.morphAttributes.position;
            if (a) {
                var c = this.boundingSphere.center;
                if (ii.setFromBufferAttribute(a),
                b)
                    for (var d = 0, e = b.length; e > d; d++) {
                        var f = b[d];
                        ji.setFromBufferAttribute(f),
                        this.morphTargetsRelative ? (ki.addVectors(ii.min, ji.min),
                        ii.expandByPoint(ki),
                        ki.addVectors(ii.max, ji.max),
                        ii.expandByPoint(ki)) : (ii.expandByPoint(ji.min),
                        ii.expandByPoint(ji.max))
                    }
                ii.getCenter(c);
                var g = 0;
                for (d = 0,
                e = a.count; e > d; d++)
                    ki.fromBufferAttribute(a, d),
                    g = Math.max(g, c.distanceToSquared(ki));
                if (b)
                    for (d = 0,
                    e = b.length; e > d; d++) {
                        f = b[d];
                        for (var h = this.morphTargetsRelative, i = 0, j = f.count; j > i; i++)
                            ki.fromBufferAttribute(f, i),
                            h && (hi.fromBufferAttribute(a, i),
                            ki.add(hi)),
                            g = Math.max(g, c.distanceToSquared(ki))
                    }
                this.boundingSphere.radius = Math.sqrt(g),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var a = this.index
              , b = this.attributes;
            if (b.position) {
                var c = b.position.array;
                if (void 0 === b.normal)
                    this.setAttribute("normal", new C(new Float32Array(c.length),3));
                else
                    for (var d = b.normal.array, f = 0, g = d.length; g > f; f++)
                        d[f] = 0;
                d = b.normal.array;
                var h = new e
                  , i = new e
                  , j = new e
                  , k = new e
                  , l = new e;
                if (a) {
                    var m = a.array;
                    for (f = 0,
                    g = a.count; g > f; f += 3) {
                        a = 3 * m[f + 0];
                        var n = 3 * m[f + 1]
                          , o = 3 * m[f + 2];
                        h.fromArray(c, a),
                        i.fromArray(c, n),
                        j.fromArray(c, o),
                        k.subVectors(j, i),
                        l.subVectors(h, i),
                        k.cross(l),
                        d[a] += k.x,
                        d[a + 1] += k.y,
                        d[a + 2] += k.z,
                        d[n] += k.x,
                        d[n + 1] += k.y,
                        d[n + 2] += k.z,
                        d[o] += k.x,
                        d[o + 1] += k.y,
                        d[o + 2] += k.z
                    }
                } else
                    for (f = 0,
                    g = c.length; g > f; f += 9)
                        h.fromArray(c, f),
                        i.fromArray(c, f + 3),
                        j.fromArray(c, f + 6),
                        k.subVectors(j, i),
                        l.subVectors(h, i),
                        k.cross(l),
                        d[f] = k.x,
                        d[f + 1] = k.y,
                        d[f + 2] = k.z,
                        d[f + 3] = k.x,
                        d[f + 4] = k.y,
                        d[f + 5] = k.z,
                        d[f + 6] = k.x,
                        d[f + 7] = k.y,
                        d[f + 8] = k.z;
                this.normalizeNormals(),
                b.normal.needsUpdate = !0
            }
        },
        merge: function(a, b) {
            if (a && a.isBufferGeometry) {
                void 0 === b && (b = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var c, d = this.attributes;
                for (c in d)
                    if (void 0 !== a.attributes[c]) {
                        var e = d[c].array
                          , f = a.attributes[c]
                          , g = f.array
                          , h = f.itemSize * b;
                        f = Math.min(g.length, e.length - h);
                        for (var i = 0; f > i; i++,
                        h++)
                            e[h] = g[i]
                    }
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
        },
        normalizeNormals: function() {
            for (var a = this.attributes.normal, b = 0, c = a.count; c > b; b++)
                ki.x = a.getX(b),
                ki.y = a.getY(b),
                ki.z = a.getZ(b),
                ki.normalize(),
                a.setXYZ(b, ki.x, ki.y, ki.z)
        },
        toNonIndexed: function() {
            function a(a, b) {
                var c = a.array;
                a = a.itemSize;
                for (var d, e = new c.constructor(b.length * a), f = 0, g = 0, h = b.length; h > g; g++) {
                    d = b[g] * a;
                    for (var i = 0; a > i; i++)
                        e[f++] = c[d++]
                }
                return new C(e,a)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var b, c = new O, d = this.index.array, e = this.attributes;
            for (b in e) {
                var f = e[b];
                f = a(f, d),
                c.setAttribute(b, f)
            }
            var g = this.morphAttributes;
            for (b in g) {
                var h = []
                  , i = g[b];
                e = 0;
                for (var j = i.length; j > e; e++)
                    f = i[e],
                    f = a(f, d),
                    h.push(f);
                c.morphAttributes[b] = h
            }
            for (c.morphTargetsRelative = this.morphTargetsRelative,
            d = this.groups,
            e = 0,
            b = d.length; b > e; e++)
                f = d[e],
                c.addGroup(f.start, f.count, f.materialIndex);
            return c
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (a.uuid = this.uuid,
            a.type = this.type,
            "" !== this.name && (a.name = this.name),
            0 < Object.keys(this.userData).length && (a.userData = this.userData),
            void 0 !== this.parameters) {
                var b = this.parameters;
                for (j in b)
                    void 0 !== b[j] && (a[j] = b[j]);
                return a
            }
            a.data = {
                attributes: {}
            },
            b = this.index,
            null !== b && (a.data.index = {
                type: b.array.constructor.name,
                array: Array.prototype.slice.call(b.array)
            });
            var c = this.attributes;
            for (j in c) {
                b = c[j];
                var d = b.toJSON();
                "" !== b.name && (d.name = b.name),
                a.data.attributes[j] = d
            }
            c = {};
            var e = !1;
            for (j in this.morphAttributes) {
                for (var f = this.morphAttributes[j], g = [], h = 0, i = f.length; i > h; h++)
                    b = f[h],
                    d = b.toJSON(),
                    "" !== b.name && (d.name = b.name),
                    g.push(d);
                0 < g.length && (c[j] = g,
                e = !0)
            }
            e && (a.data.morphAttributes = c,
            a.data.morphTargetsRelative = this.morphTargetsRelative);
            var j = this.groups;
            return 0 < j.length && (a.data.groups = JSON.parse(JSON.stringify(j))),
            j = this.boundingSphere,
            null !== j && (a.data.boundingSphere = {
                center: j.center.toArray(),
                radius: j.radius
            }),
            a
        },
        clone: function() {
            return (new O).copy(this)
        },
        copy: function(a) {
            var b;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = a.name;
            var c = a.index;
            null !== c && this.setIndex(c.clone()),
            c = a.attributes;
            for (g in c)
                this.setAttribute(g, c[g].clone());
            var d = a.morphAttributes;
            for (g in d) {
                var e = []
                  , f = d[g];
                for (c = 0,
                b = f.length; b > c; c++)
                    e.push(f[c].clone());
                this.morphAttributes[g] = e
            }
            this.morphTargetsRelative = a.morphTargetsRelative;
            var g = a.groups;
            for (c = 0,
            b = g.length; b > c; c++)
                d = g[c],
                this.addGroup(d.start, d.count, d.materialIndex);
            return g = a.boundingBox,
            null !== g && (this.boundingBox = g.clone()),
            g = a.boundingSphere,
            null !== g && (this.boundingSphere = g.clone()),
            this.drawRange.start = a.drawRange.start,
            this.drawRange.count = a.drawRange.count,
            this.userData = a.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var li = new k
      , mi = new s
      , ni = new r
      , oi = new e
      , pi = new e
      , qi = new e
      , ri = new e
      , si = new e
      , ti = new e
      , ui = new e
      , vi = new e
      , wi = new e
      , xi = new c
      , yi = new c
      , zi = new c
      , Ai = new e
      , Bi = new e;
    P.prototype = Object.assign(Object.create(n.prototype), {
        constructor: P,
        isMesh: !0,
        copy: function(a) {
            return n.prototype.copy.call(this, a),
            void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()),
            void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
                a = a.morphAttributes;
                var b = Object.keys(a);
                if (0 < b.length) {
                    var c = a[b[0]];
                    if (void 0 !== c)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        a = 0,
                        b = c.length; b > a; a++) {
                            var d = c[a].name || String(a);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[d] = a
                        }
                }
            } else
                a = a.morphTargets,
                void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        raycast: function(a, b) {
            var d = this.geometry
              , e = this.material
              , f = this.matrixWorld;
            if (void 0 !== e && (null === d.boundingSphere && d.computeBoundingSphere(),
            ni.copy(d.boundingSphere),
            ni.applyMatrix4(f),
            !1 !== a.ray.intersectsSphere(ni) && (li.getInverse(f),
            mi.copy(a.ray).applyMatrix4(li),
            null === d.boundingBox || !1 !== mi.intersectsBox(d.boundingBox))))
                if (d.isBufferGeometry) {
                    var g = d.index;
                    f = d.attributes.position;
                    var h, i, j = d.morphAttributes.position, k = d.morphTargetsRelative, l = d.attributes.uv, m = d.attributes.uv2, n = d.groups, o = d.drawRange;
                    if (null !== g)
                        if (Array.isArray(e)) {
                            var p = 0;
                            for (h = n.length; h > p; p++) {
                                var q = n[p]
                                  , r = e[q.materialIndex]
                                  , s = Math.max(q.start, o.start);
                                for (i = d = Math.min(q.start + q.count, o.start + o.count); i > s; s += 3) {
                                    d = g.getX(s);
                                    var t = g.getX(s + 1)
                                      , v = g.getX(s + 2);
                                    (d = R(this, r, a, mi, f, j, k, l, m, d, t, v)) && (d.faceIndex = Math.floor(s / 3),
                                    d.face.materialIndex = q.materialIndex,
                                    b.push(d))
                                }
                            }
                        } else
                            for (s = Math.max(0, o.start),
                            d = Math.min(g.count, o.start + o.count),
                            p = s,
                            h = d; h > p; p += 3)
                                d = g.getX(p),
                                t = g.getX(p + 1),
                                v = g.getX(p + 2),
                                (d = R(this, e, a, mi, f, j, k, l, m, d, t, v)) && (d.faceIndex = Math.floor(p / 3),
                                b.push(d));
                    else if (void 0 !== f)
                        if (Array.isArray(e))
                            for (p = 0,
                            h = n.length; h > p; p++)
                                for (q = n[p],
                                r = e[q.materialIndex],
                                s = Math.max(q.start, o.start),
                                i = d = Math.min(q.start + q.count, o.start + o.count); i > s; s += 3)
                                    d = s,
                                    t = s + 1,
                                    v = s + 2,
                                    (d = R(this, r, a, mi, f, j, k, l, m, d, t, v)) && (d.faceIndex = Math.floor(s / 3),
                                    d.face.materialIndex = q.materialIndex,
                                    b.push(d));
                        else
                            for (s = Math.max(0, o.start),
                            d = Math.min(f.count, o.start + o.count),
                            p = s,
                            h = d; h > p; p += 3)
                                d = p,
                                t = p + 1,
                                v = p + 2,
                                (d = R(this, e, a, mi, f, j, k, l, m, d, t, v)) && (d.faceIndex = Math.floor(p / 3),
                                b.push(d))
                } else if (d.isGeometry)
                    for (f = Array.isArray(e),
                    j = d.vertices,
                    k = d.faces,
                    d = d.faceVertexUvs[0],
                    0 < d.length && (g = d),
                    o = 0,
                    p = k.length; p > o; o++)
                        h = k[o],
                        d = f ? e[h.materialIndex] : e,
                        void 0 !== d && (l = j[h.a],
                        m = j[h.b],
                        n = j[h.c],
                        d = Q(this, d, a, mi, l, m, n, Ai)) && (g && g[o] && (q = g[o],
                        xi.copy(q[0]),
                        yi.copy(q[1]),
                        zi.copy(q[2]),
                        d.uv = u.getUV(Ai, l, m, n, xi, yi, zi, new c)),
                        d.face = h,
                        d.faceIndex = o,
                        b.push(d))
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var Ci = 0
      , Di = new k
      , Ei = new n
      , Fi = new e;
    S.prototype = Object.assign(Object.create(b.prototype), {
        constructor: S,
        isGeometry: !0,
        applyMatrix: function(a) {
            for (var b = (new f).getNormalMatrix(a), c = 0, d = this.vertices.length; d > c; c++)
                this.vertices[c].applyMatrix4(a);
            for (c = 0,
            d = this.faces.length; d > c; c++) {
                a = this.faces[c],
                a.normal.applyMatrix3(b).normalize();
                for (var e = 0, g = a.vertexNormals.length; g > e; e++)
                    a.vertexNormals[e].applyMatrix3(b).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0,
            this
        },
        rotateX: function(a) {
            return Di.makeRotationX(a),
            this.applyMatrix(Di),
            this
        },
        rotateY: function(a) {
            return Di.makeRotationY(a),
            this.applyMatrix(Di),
            this
        },
        rotateZ: function(a) {
            return Di.makeRotationZ(a),
            this.applyMatrix(Di),
            this
        },
        translate: function(a, b, c) {
            return Di.makeTranslation(a, b, c),
            this.applyMatrix(Di),
            this
        },
        scale: function(a, b, c) {
            return Di.makeScale(a, b, c),
            this.applyMatrix(Di),
            this
        },
        lookAt: function(a) {
            return Ei.lookAt(a),
            Ei.updateMatrix(),
            this.applyMatrix(Ei.matrix),
            this
        },
        fromBufferGeometry: function(a) {
            function b(a, b, f, g) {
                var h = void 0 === j ? [] : [d.colors[a].clone(), d.colors[b].clone(), d.colors[f].clone()]
                  , m = void 0 === i ? [] : [(new e).fromArray(i, 3 * a), (new e).fromArray(i, 3 * b), (new e).fromArray(i, 3 * f)];
                g = new z(a,b,f,m,h,g),
                d.faces.push(g),
                void 0 !== k && d.faceVertexUvs[0].push([(new c).fromArray(k, 2 * a), (new c).fromArray(k, 2 * b), (new c).fromArray(k, 2 * f)]),
                void 0 !== l && d.faceVertexUvs[1].push([(new c).fromArray(l, 2 * a), (new c).fromArray(l, 2 * b), (new c).fromArray(l, 2 * f)])
            }
            var d = this
              , f = null !== a.index ? a.index.array : void 0
              , g = a.attributes;
            if (void 0 === g.position)
                return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),
                this;
            var h = g.position.array
              , i = void 0 !== g.normal ? g.normal.array : void 0
              , j = void 0 !== g.color ? g.color.array : void 0
              , k = void 0 !== g.uv ? g.uv.array : void 0
              , l = void 0 !== g.uv2 ? g.uv2.array : void 0;
            for (void 0 !== l && (this.faceVertexUvs[1] = []),
            g = 0; g < h.length; g += 3)
                d.vertices.push((new e).fromArray(h, g)),
                void 0 !== j && d.colors.push((new v).fromArray(j, g));
            var m = a.groups;
            if (0 < m.length)
                for (g = 0; g < m.length; g++) {
                    h = m[g];
                    var n = h.start
                      , o = n;
                    for (n += h.count; n > o; o += 3)
                        void 0 !== f ? b(f[o], f[o + 1], f[o + 2], h.materialIndex) : b(o, o + 1, o + 2, h.materialIndex)
                }
            else if (void 0 !== f)
                for (g = 0; g < f.length; g += 3)
                    b(f[g], f[g + 1], f[g + 2]);
            else
                for (g = 0; g < h.length / 3; g += 3)
                    b(g, g + 1, g + 2);
            return this.computeFaceNormals(),
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()),
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Fi).negate(),
            this.translate(Fi.x, Fi.y, Fi.z),
            this
        },
        normalize: function() {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center
              , b = this.boundingSphere.radius;
            b = 0 === b ? 1 : 1 / b;
            var c = new k;
            return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1),
            this.applyMatrix(c),
            this
        },
        computeFaceNormals: function() {
            for (var a = new e, b = new e, c = 0, d = this.faces.length; d > c; c++) {
                var f = this.faces[c]
                  , g = this.vertices[f.a]
                  , h = this.vertices[f.b];
                a.subVectors(this.vertices[f.c], h),
                b.subVectors(g, h),
                a.cross(b),
                a.normalize(),
                f.normal.copy(a)
            }
        },
        computeVertexNormals: function(a) {
            void 0 === a && (a = !0);
            var b, c = Array(this.vertices.length), d = 0;
            for (b = this.vertices.length; b > d; d++)
                c[d] = new e;
            if (a) {
                var f = new e
                  , g = new e;
                for (a = 0,
                d = this.faces.length; d > a; a++) {
                    b = this.faces[a];
                    var h = this.vertices[b.a]
                      , i = this.vertices[b.b]
                      , j = this.vertices[b.c];
                    f.subVectors(j, i),
                    g.subVectors(h, i),
                    f.cross(g),
                    c[b.a].add(f),
                    c[b.b].add(f),
                    c[b.c].add(f)
                }
            } else
                for (this.computeFaceNormals(),
                a = 0,
                d = this.faces.length; d > a; a++)
                    b = this.faces[a],
                    c[b.a].add(b.normal),
                    c[b.b].add(b.normal),
                    c[b.c].add(b.normal);
            for (d = 0,
            b = this.vertices.length; b > d; d++)
                c[d].normalize();
            for (a = 0,
            d = this.faces.length; d > a; a++)
                b = this.faces[a],
                h = b.vertexNormals,
                3 === h.length ? (h[0].copy(c[b.a]),
                h[1].copy(c[b.b]),
                h[2].copy(c[b.c])) : (h[0] = c[b.a].clone(),
                h[1] = c[b.b].clone(),
                h[2] = c[b.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var a;
            this.computeFaceNormals();
            var b = 0;
            for (a = this.faces.length; a > b; b++) {
                var c = this.faces[b]
                  , d = c.vertexNormals;
                3 === d.length ? (d[0].copy(c.normal),
                d[1].copy(c.normal),
                d[2].copy(c.normal)) : (d[0] = c.normal.clone(),
                d[1] = c.normal.clone(),
                d[2] = c.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var a, b, c = 0;
            for (b = this.faces.length; b > c; c++) {
                var d = this.faces[c];
                d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone(),
                d.__originalVertexNormals || (d.__originalVertexNormals = []);
                var f = 0;
                for (a = d.vertexNormals.length; a > f; f++)
                    d.__originalVertexNormals[f] ? d.__originalVertexNormals[f].copy(d.vertexNormals[f]) : d.__originalVertexNormals[f] = d.vertexNormals[f].clone()
            }
            var g = new S;
            for (g.faces = this.faces,
            f = 0,
            a = this.morphTargets.length; a > f; f++) {
                if (!this.morphNormals[f]) {
                    this.morphNormals[f] = {},
                    this.morphNormals[f].faceNormals = [],
                    this.morphNormals[f].vertexNormals = [],
                    d = this.morphNormals[f].faceNormals;
                    var h = this.morphNormals[f].vertexNormals;
                    for (c = 0,
                    b = this.faces.length; b > c; c++) {
                        var i = new e
                          , j = {
                            a: new e,
                            b: new e,
                            c: new e
                        };
                        d.push(i),
                        h.push(j)
                    }
                }
                for (h = this.morphNormals[f],
                g.vertices = this.morphTargets[f].vertices,
                g.computeFaceNormals(),
                g.computeVertexNormals(),
                c = 0,
                b = this.faces.length; b > c; c++)
                    d = this.faces[c],
                    i = h.faceNormals[c],
                    j = h.vertexNormals[c],
                    i.copy(d.normal),
                    j.a.copy(d.vertexNormals[0]),
                    j.b.copy(d.vertexNormals[1]),
                    j.c.copy(d.vertexNormals[2])
            }
            for (c = 0,
            b = this.faces.length; b > c; c++)
                d = this.faces[c],
                d.normal = d.__originalFaceNormal,
                d.vertexNormals = d.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new p),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new r),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(a, b, c) {
            if (a && a.isGeometry) {
                var d, e = this.vertices.length, g = this.vertices, h = a.vertices, i = this.faces, j = a.faces, k = this.colors, l = a.colors;
                void 0 === c && (c = 0),
                void 0 !== b && (d = (new f).getNormalMatrix(b));
                for (var m = 0, n = h.length; n > m; m++) {
                    var o = h[m].clone();
                    void 0 !== b && o.applyMatrix4(b),
                    g.push(o)
                }
                for (m = 0,
                n = l.length; n > m; m++)
                    k.push(l[m].clone());
                for (m = 0,
                n = j.length; n > m; m++) {
                    h = j[m];
                    var p = h.vertexNormals;
                    for (l = h.vertexColors,
                    k = new z(h.a + e,h.b + e,h.c + e),
                    k.normal.copy(h.normal),
                    void 0 !== d && k.normal.applyMatrix3(d).normalize(),
                    b = 0,
                    g = p.length; g > b; b++)
                        o = p[b].clone(),
                        void 0 !== d && o.applyMatrix3(d).normalize(),
                        k.vertexNormals.push(o);
                    for (k.color.copy(h.color),
                    b = 0,
                    g = l.length; g > b; b++)
                        o = l[b],
                        k.vertexColors.push(o.clone());
                    k.materialIndex = h.materialIndex + c,
                    i.push(k)
                }
                for (m = 0,
                n = a.faceVertexUvs.length; n > m; m++)
                    for (c = a.faceVertexUvs[m],
                    void 0 === this.faceVertexUvs[m] && (this.faceVertexUvs[m] = []),
                    b = 0,
                    g = c.length; g > b; b++) {
                        for (d = c[b],
                        e = [],
                        i = 0,
                        j = d.length; j > i; i++)
                            e.push(d[i].clone());
                        this.faceVertexUvs[m].push(e)
                    }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
        },
        mergeMesh: function(a) {
            a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(),
            this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a)
        },
        mergeVertices: function() {
            var a, b = {}, c = [], d = [], e = Math.pow(10, 4), f = 0;
            for (a = this.vertices.length; a > f; f++) {
                var g = this.vertices[f];
                g = Math.round(g.x * e) + "_" + Math.round(g.y * e) + "_" + Math.round(g.z * e),
                void 0 === b[g] ? (b[g] = f,
                c.push(this.vertices[f]),
                d[f] = c.length - 1) : d[f] = d[b[g]]
            }
            for (b = [],
            f = 0,
            a = this.faces.length; a > f; f++)
                for (e = this.faces[f],
                e.a = d[e.a],
                e.b = d[e.b],
                e.c = d[e.c],
                e = [e.a, e.b, e.c],
                g = 0; 3 > g; g++)
                    if (e[g] === e[(g + 1) % 3]) {
                        b.push(f);
                        break
                    }
            for (f = b.length - 1; f >= 0; f--)
                for (e = b[f],
                this.faces.splice(e, 1),
                d = 0,
                a = this.faceVertexUvs.length; a > d; d++)
                    this.faceVertexUvs[d].splice(e, 1);
            return f = this.vertices.length - c.length,
            this.vertices = c,
            f
        },
        setFromPoints: function(a) {
            this.vertices = [];
            for (var b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                this.vertices.push(new e(d.x,d.y,d.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var a = this.faces, b = a.length, c = 0; b > c; c++)
                a[c]._id = c;
            a.sort(function(a, b) {
                return a.materialIndex - b.materialIndex
            });
            var d, e, f = this.faceVertexUvs[0], g = this.faceVertexUvs[1];
            for (f && f.length === b && (d = []),
            g && g.length === b && (e = []),
            c = 0; b > c; c++) {
                var h = a[c]._id;
                d && d.push(f[h]),
                e && e.push(g[h])
            }
            d && (this.faceVertexUvs[0] = d),
            e && (this.faceVertexUvs[1] = e)
        },
        toJSON: function() {
            function a(a, b, c) {
                return c ? a | 1 << b : a & ~(1 << b)
            }
            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3,
                i.push(a.x, a.y, a.z),
                j[b])
            }
            function c(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                return void 0 !== l[b] ? l[b] : (l[b] = k.length,
                k.push(a.getHex()),
                l[b])
            }
            function d(a) {
                var b = a.x.toString() + a.y.toString();
                return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2,
                m.push(a.x, a.y),
                n[b])
            }
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters) {
                var f, g = this.parameters;
                for (f in g)
                    void 0 !== g[f] && (e[f] = g[f]);
                return e
            }
            for (g = [],
            f = 0; f < this.vertices.length; f++) {
                var h = this.vertices[f];
                g.push(h.x, h.y, h.z)
            }
            h = [];
            var i = []
              , j = {}
              , k = []
              , l = {}
              , m = []
              , n = {};
            for (f = 0; f < this.faces.length; f++) {
                var o = this.faces[f]
                  , p = void 0 !== this.faceVertexUvs[0][f]
                  , q = 0 < o.normal.length()
                  , r = 0 < o.vertexNormals.length
                  , s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b
                  , t = 0 < o.vertexColors.length
                  , u = 0;
                u = a(u, 0, 0),
                u = a(u, 1, !0),
                u = a(u, 2, !1),
                u = a(u, 3, p),
                u = a(u, 4, q),
                u = a(u, 5, r),
                u = a(u, 6, s),
                u = a(u, 7, t),
                h.push(u),
                h.push(o.a, o.b, o.c),
                h.push(o.materialIndex),
                p && (p = this.faceVertexUvs[0][f],
                h.push(d(p[0]), d(p[1]), d(p[2]))),
                q && h.push(b(o.normal)),
                r && (q = o.vertexNormals,
                h.push(b(q[0]), b(q[1]), b(q[2]))),
                s && h.push(c(o.color)),
                t && (o = o.vertexColors,
                h.push(c(o[0]), c(o[1]), c(o[2])))
            }
            return e.data = {},
            e.data.vertices = g,
            e.data.normals = i,
            0 < k.length && (e.data.colors = k),
            0 < m.length && (e.data.uvs = [m]),
            e.data.faces = h,
            e
        },
        clone: function() {
            return (new S).copy(this)
        },
        copy: function(a) {
            var b, c, d;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = a.name;
            var e = a.vertices
              , f = 0;
            for (b = e.length; b > f; f++)
                this.vertices.push(e[f].clone());
            for (e = a.colors,
            f = 0,
            b = e.length; b > f; f++)
                this.colors.push(e[f].clone());
            for (e = a.faces,
            f = 0,
            b = e.length; b > f; f++)
                this.faces.push(e[f].clone());
            for (f = 0,
            b = a.faceVertexUvs.length; b > f; f++) {
                var g = a.faceVertexUvs[f];
                for (void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []),
                e = 0,
                c = g.length; c > e; e++) {
                    var h = g[e]
                      , i = []
                      , j = 0;
                    for (d = h.length; d > j; j++)
                        i.push(h[j].clone());
                    this.faceVertexUvs[f].push(i)
                }
            }
            for (j = a.morphTargets,
            f = 0,
            b = j.length; b > f; f++) {
                if (d = {},
                d.name = j[f].name,
                void 0 !== j[f].vertices)
                    for (d.vertices = [],
                    e = 0,
                    c = j[f].vertices.length; c > e; e++)
                        d.vertices.push(j[f].vertices[e].clone());
                if (void 0 !== j[f].normals)
                    for (d.normals = [],
                    e = 0,
                    c = j[f].normals.length; c > e; e++)
                        d.normals.push(j[f].normals[e].clone());
                this.morphTargets.push(d)
            }
            for (j = a.morphNormals,
            f = 0,
            b = j.length; b > f; f++) {
                if (d = {},
                void 0 !== j[f].vertexNormals)
                    for (d.vertexNormals = [],
                    e = 0,
                    c = j[f].vertexNormals.length; c > e; e++)
                        g = j[f].vertexNormals[e],
                        h = {},
                        h.a = g.a.clone(),
                        h.b = g.b.clone(),
                        h.c = g.c.clone(),
                        d.vertexNormals.push(h);
                if (void 0 !== j[f].faceNormals)
                    for (d.faceNormals = [],
                    e = 0,
                    c = j[f].faceNormals.length; c > e; e++)
                        d.faceNormals.push(j[f].faceNormals[e].clone());
                this.morphNormals.push(d)
            }
            for (e = a.skinWeights,
            f = 0,
            b = e.length; b > f; f++)
                this.skinWeights.push(e[f].clone());
            for (e = a.skinIndices,
            f = 0,
            b = e.length; b > f; f++)
                this.skinIndices.push(e[f].clone());
            for (e = a.lineDistances,
            f = 0,
            b = e.length; b > f; f++)
                this.lineDistances.push(e[f]);
            return f = a.boundingBox,
            null !== f && (this.boundingBox = f.clone()),
            f = a.boundingSphere,
            null !== f && (this.boundingSphere = f.clone()),
            this.elementsNeedUpdate = a.elementsNeedUpdate,
            this.verticesNeedUpdate = a.verticesNeedUpdate,
            this.uvsNeedUpdate = a.uvsNeedUpdate,
            this.normalsNeedUpdate = a.normalsNeedUpdate,
            this.colorsNeedUpdate = a.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = a.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Gi = function(a) {
        function b(b, c, d, e, f, g) {
            a.call(this),
            this.type = "BoxGeometry",
            this.parameters = {
                width: b,
                height: c,
                depth: d,
                widthSegments: e,
                heightSegments: f,
                depthSegments: g
            },
            this.fromBufferGeometry(new Hi(b,c,d,e,f,g)),
            this.mergeVertices()
        }
        return a && (b.__proto__ = a),
        b.prototype = Object.create(a && a.prototype),
        b.prototype.constructor = b
    }(S)
      , Hi = function(a) {
        function b(b, c, d, f, g, h) {
            function i(a, b, c, d, f, g, h, i, q, r, s) {
                var t = g / q
                  , u = h / r
                  , v = g / 2
                  , w = h / 2
                  , x = i / 2;
                h = q + 1;
                var y, z, A = r + 1, B = g = 0, C = new e;
                for (z = 0; A > z; z++) {
                    var D = z * u - w;
                    for (y = 0; h > y; y++)
                        C[a] = (y * t - v) * d,
                        C[b] = D * f,
                        C[c] = x,
                        l.push(C.x, C.y, C.z),
                        C[a] = 0,
                        C[b] = 0,
                        C[c] = i > 0 ? 1 : -1,
                        m.push(C.x, C.y, C.z),
                        n.push(y / q),
                        n.push(1 - z / r),
                        g += 1
                }
                for (z = 0; r > z; z++)
                    for (y = 0; q > y; y++)
                        a = o + y + h * (z + 1),
                        b = o + (y + 1) + h * (z + 1),
                        c = o + (y + 1) + h * z,
                        k.push(o + y + h * z, a, c),
                        k.push(a, b, c),
                        B += 6;
                j.addGroup(p, B, s),
                p += B,
                o += g
            }
            a.call(this),
            this.type = "BoxBufferGeometry",
            this.parameters = {
                width: b,
                height: c,
                depth: d,
                widthSegments: f,
                heightSegments: g,
                depthSegments: h
            };
            var j = this;
            b = b || 1,
            c = c || 1,
            d = d || 1,
            f = Math.floor(f) || 1,
            g = Math.floor(g) || 1,
            h = Math.floor(h) || 1;
            var k = []
              , l = []
              , m = []
              , n = []
              , o = 0
              , p = 0;
            i("z", "y", "x", -1, -1, d, c, b, h, g, 0),
            i("z", "y", "x", 1, -1, d, c, -b, h, g, 1),
            i("x", "z", "y", 1, 1, b, d, c, f, h, 2),
            i("x", "z", "y", 1, -1, b, d, -c, f, h, 3),
            i("x", "y", "z", 1, -1, b, c, d, f, g, 4),
            i("x", "y", "z", -1, -1, b, c, -d, f, g, 5),
            this.setIndex(k),
            this.setAttribute("position", new K(l,3)),
            this.setAttribute("normal", new K(m,3)),
            this.setAttribute("uv", new K(n,2))
        }
        return a && (b.__proto__ = a),
        b.prototype = Object.create(a && a.prototype),
        b.prototype.constructor = b
    }(O)
      , Ii = {
        clone: T,
        merge: U
    };
    V.prototype = Object.create(A.prototype),
    V.prototype.constructor = V,
    V.prototype.isShaderMaterial = !0,
    V.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.fragmentShader = a.fragmentShader,
        this.vertexShader = a.vertexShader,
        this.uniforms = T(a.uniforms),
        this.defines = Object.assign({}, a.defines),
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.lights = a.lights,
        this.clipping = a.clipping,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this.extensions = a.extensions,
        this
    }
    ,
    V.prototype.toJSON = function(a) {
        var b = A.prototype.toJSON.call(this, a);
        b.uniforms = {};
        for (var c in this.uniforms) {
            var d = this.uniforms[c].value;
            b.uniforms[c] = d && d.isTexture ? {
                type: "t",
                value: d.toJSON(a).uuid
            } : d && d.isColor ? {
                type: "c",
                value: d.getHex()
            } : d && d.isVector2 ? {
                type: "v2",
                value: d.toArray()
            } : d && d.isVector3 ? {
                type: "v3",
                value: d.toArray()
            } : d && d.isVector4 ? {
                type: "v4",
                value: d.toArray()
            } : d && d.isMatrix3 ? {
                type: "m3",
                value: d.toArray()
            } : d && d.isMatrix4 ? {
                type: "m4",
                value: d.toArray()
            } : {
                value: d
            }
        }
        0 < Object.keys(this.defines).length && (b.defines = this.defines),
        b.vertexShader = this.vertexShader,
        b.fragmentShader = this.fragmentShader,
        a = {};
        for (var e in this.extensions)
            !0 === this.extensions[e] && (a[e] = !0);
        return 0 < Object.keys(a).length && (b.extensions = a),
        b
    }
    ,
    W.prototype = Object.assign(Object.create(n.prototype), {
        constructor: W,
        isCamera: !0,
        copy: function(a, b) {
            return n.prototype.copy.call(this, a, b),
            this.matrixWorldInverse.copy(a.matrixWorldInverse),
            this.projectionMatrix.copy(a.projectionMatrix),
            this.projectionMatrixInverse.copy(a.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(a) {
            void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            a = new e),
            this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(-b[8], -b[9], -b[10]).normalize()
        },
        updateMatrixWorld: function(a) {
            n.prototype.updateMatrixWorld.call(this, a),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    X.prototype = Object.assign(Object.create(W.prototype), {
        constructor: X,
        isPerspectiveCamera: !0,
        copy: function(a, b) {
            return W.prototype.copy.call(this, a, b),
            this.fov = a.fov,
            this.zoom = a.zoom,
            this.near = a.near,
            this.far = a.far,
            this.focus = a.focus,
            this.aspect = a.aspect,
            this.view = null === a.view ? null : Object.assign({}, a.view),
            this.filmGauge = a.filmGauge,
            this.filmOffset = a.filmOffset,
            this
        },
        setFocalLength: function(a) {
            a = .5 * this.getFilmHeight() / a,
            this.fov = 2 * Sg.RAD2DEG * Math.atan(a),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var a = Math.tan(.5 * Sg.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / a
        },
        getEffectiveFOV: function() {
            return 2 * Sg.RAD2DEG * Math.atan(Math.tan(.5 * Sg.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(a, b, c, d, e, f) {
            this.aspect = a / b,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = a,
            this.view.fullHeight = b,
            this.view.offsetX = c,
            this.view.offsetY = d,
            this.view.width = e,
            this.view.height = f,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var a = this.near
              , b = a * Math.tan(.5 * Sg.DEG2RAD * this.fov) / this.zoom
              , c = 2 * b
              , d = this.aspect * c
              , e = -.5 * d
              , f = this.view;
            if (null !== this.view && this.view.enabled) {
                var g = f.fullWidth
                  , h = f.fullHeight;
                e += f.offsetX * d / g,
                b -= f.offsetY * c / h,
                d *= f.width / g,
                c *= f.height / h
            }
            f = this.filmOffset,
            0 !== f && (e += a * f / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(a) {
            return a = n.prototype.toJSON.call(this, a),
            a.object.fov = this.fov,
            a.object.zoom = this.zoom,
            a.object.near = this.near,
            a.object.far = this.far,
            a.object.focus = this.focus,
            a.object.aspect = this.aspect,
            null !== this.view && (a.object.view = Object.assign({}, this.view)),
            a.object.filmGauge = this.filmGauge,
            a.object.filmOffset = this.filmOffset,
            a
        }
    }),
    Y.prototype = Object.create(n.prototype),
    Y.prototype.constructor = Y,
    Z.prototype = Object.create(i.prototype),
    Z.prototype.constructor = Z,
    Z.prototype.isWebGLRenderTargetCube = !0,
    Z.prototype.fromEquirectangularTexture = function(a, b) {
        this.texture.type = b.type,
        this.texture.format = b.format,
        this.texture.encoding = b.encoding;
        var c = new o
          , d = new V({
            type: "CubemapFromEquirect",
            uniforms: T({
                tEquirect: {
                    value: null
                }
            }),
            vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
            fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}",
            side: 1,
            blending: 0
        });
        return d.uniforms.tEquirect.value = b,
        b = new P(new Hi(5,5,5),d),
        c.add(b),
        d = new Y(1,10,1),
        d.renderTarget = this,
        d.renderTarget.texture.name = "CubeCameraTexture",
        d.update(a, c),
        b.geometry.dispose(),
        b.material.dispose(),
        this
    }
    ,
    $.prototype = Object.create(g.prototype),
    $.prototype.constructor = $,
    $.prototype.isDataTexture = !0;
    var Ji = new r
      , Ki = new e;
    Object.assign(_.prototype, {
        set: function(a, b, c, d, e, f) {
            var g = this.planes;
            return g[0].copy(a),
            g[1].copy(b),
            g[2].copy(c),
            g[3].copy(d),
            g[4].copy(e),
            g[5].copy(f),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++)
                b[c].copy(a.planes[c]);
            return this
        },
        setFromMatrix: function(a) {
            var b = this.planes
              , c = a.elements;
            a = c[0];
            var d = c[1]
              , e = c[2]
              , f = c[3]
              , g = c[4]
              , h = c[5]
              , i = c[6]
              , j = c[7]
              , k = c[8]
              , l = c[9]
              , m = c[10]
              , n = c[11]
              , o = c[12]
              , p = c[13]
              , q = c[14];
            return c = c[15],
            b[0].setComponents(f - a, j - g, n - k, c - o).normalize(),
            b[1].setComponents(f + a, j + g, n + k, c + o).normalize(),
            b[2].setComponents(f + d, j + h, n + l, c + p).normalize(),
            b[3].setComponents(f - d, j - h, n - l, c - p).normalize(),
            b[4].setComponents(f - e, j - i, n - m, c - q).normalize(),
            b[5].setComponents(f + e, j + i, n + m, c + q).normalize(),
            this
        },
        intersectsObject: function(a) {
            var b = a.geometry;
            return null === b.boundingSphere && b.computeBoundingSphere(),
            Ji.copy(b.boundingSphere).applyMatrix4(a.matrixWorld),
            this.intersectsSphere(Ji)
        },
        intersectsSprite: function(a) {
            return Ji.center.set(0, 0, 0),
            Ji.radius = .7071067811865476,
            Ji.applyMatrix4(a.matrixWorld),
            this.intersectsSphere(Ji)
        },
        intersectsSphere: function(a) {
            var b = this.planes
              , c = a.center;
            a = -a.radius;
            for (var d = 0; 6 > d; d++)
                if (b[d].distanceToPoint(c) < a)
                    return !1;
            return !0
        },
        intersectsBox: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) {
                var d = b[c];
                if (Ki.x = 0 < d.normal.x ? a.max.x : a.min.x,
                Ki.y = 0 < d.normal.y ? a.max.y : a.min.y,
                Ki.z = 0 < d.normal.z ? a.max.z : a.min.z,
                0 > d.distanceToPoint(Ki))
                    return !1
            }
            return !0
        },
        containsPoint: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++)
                if (0 > b[c].distanceToPoint(a))
                    return !1;
            return !0
        }
    });
    var Li = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha  = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	transformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		}  else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), 0.0 );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n		  vec3 reflectVec = reflect( -viewDir, normal );\n		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) { \n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = saturate( clearcoat );	material.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n	transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n	transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n	transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif",
        clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n	uniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSPARENCY\n		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"
    }
      , Mi = {
        common: {
            diffuse: {
                value: new v(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new f
            },
            uv2Transform: {
                value: new f
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new c(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new v(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new v(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new f
            }
        },
        sprite: {
            diffuse: {
                value: new v(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new c(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new f
            }
        }
    }
      , Ni = {
        basic: {
            uniforms: U([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.fog]),
            vertexShader: Li.meshbasic_vert,
            fragmentShader: Li.meshbasic_frag
        },
        lambert: {
            uniforms: U([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.fog, Mi.lights, {
                emissive: {
                    value: new v(0)
                }
            }]),
            vertexShader: Li.meshlambert_vert,
            fragmentShader: Li.meshlambert_frag
        },
        phong: {
            uniforms: U([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.fog, Mi.lights, {
                emissive: {
                    value: new v(0)
                },
                specular: {
                    value: new v(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Li.meshphong_vert,
            fragmentShader: Li.meshphong_frag
        },
        standard: {
            uniforms: U([Mi.common, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.roughnessmap, Mi.metalnessmap, Mi.fog, Mi.lights, {
                emissive: {
                    value: new v(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Li.meshphysical_vert,
            fragmentShader: Li.meshphysical_frag
        },
        toon: {
            uniforms: U([Mi.common, Mi.specularmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.gradientmap, Mi.fog, Mi.lights, {
                emissive: {
                    value: new v(0)
                },
                specular: {
                    value: new v(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Li.meshtoon_vert,
            fragmentShader: Li.meshtoon_frag
        },
        matcap: {
            uniforms: U([Mi.common, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Li.meshmatcap_vert,
            fragmentShader: Li.meshmatcap_frag
        },
        points: {
            uniforms: U([Mi.points, Mi.fog]),
            vertexShader: Li.points_vert,
            fragmentShader: Li.points_frag
        },
        dashed: {
            uniforms: U([Mi.common, Mi.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Li.linedashed_vert,
            fragmentShader: Li.linedashed_frag
        },
        depth: {
            uniforms: U([Mi.common, Mi.displacementmap]),
            vertexShader: Li.depth_vert,
            fragmentShader: Li.depth_frag
        },
        normal: {
            uniforms: U([Mi.common, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Li.normal_vert,
            fragmentShader: Li.normal_frag
        },
        sprite: {
            uniforms: U([Mi.sprite, Mi.fog]),
            vertexShader: Li.sprite_vert,
            fragmentShader: Li.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new f
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Li.background_vert,
            fragmentShader: Li.background_frag
        },
        cube: {
            uniforms: U([Mi.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Li.cube_vert,
            fragmentShader: Li.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Li.equirect_vert,
            fragmentShader: Li.equirect_frag
        },
        distanceRGBA: {
            uniforms: U([Mi.common, Mi.displacementmap, {
                referencePosition: {
                    value: new e
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Li.distanceRGBA_vert,
            fragmentShader: Li.distanceRGBA_frag
        },
        shadow: {
            uniforms: U([Mi.lights, Mi.fog, {
                color: {
                    value: new v(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Li.shadow_vert,
            fragmentShader: Li.shadow_frag
        }
    };
    Ni.physical = {
        uniforms: U([Ni.standard.uniforms, {
            transparency: {
                value: 0
            },
            clearcoat: {
                value: 0
            },
            clearcoatRoughness: {
                value: 0
            },
            sheen: {
                value: new v(0)
            },
            clearcoatNormalScale: {
                value: new c(1,1)
            },
            clearcoatNormalMap: {
                value: null
            }
        }]),
        vertexShader: Li.meshphysical_vert,
        fragmentShader: Li.meshphysical_frag
    },
    cb.prototype = Object.create(S.prototype),
    cb.prototype.constructor = cb,
    db.prototype = Object.create(O.prototype),
    db.prototype.constructor = db,
    pb.prototype = Object.create(g.prototype),
    pb.prototype.constructor = pb,
    pb.prototype.isCubeTexture = !0,
    Object.defineProperty(pb.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(a) {
            this.image = a
        }
    }),
    qb.prototype = Object.create(g.prototype),
    qb.prototype.constructor = qb,
    qb.prototype.isDataTexture2DArray = !0,
    rb.prototype = Object.create(g.prototype),
    rb.prototype.constructor = rb,
    rb.prototype.isDataTexture3D = !0;
    var Oi = new g
      , Pi = new qb
      , Qi = new rb
      , Ri = new pb
      , Si = []
      , Ti = []
      , Ui = new Float32Array(16)
      , Vi = new Float32Array(9)
      , Wi = new Float32Array(4);
    _b.prototype.updateCache = function(a) {
        var b = this.cache;
        a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length)),
        ub(b, a)
    }
    ,
    ac.prototype.setValue = function(a, b, c) {
        for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) {
            var g = d[e];
            g.setValue(a, b[g.id], c)
        }
    }
    ;
    var Xi = /([\w\d_]+)(\])?(\[|\.)?/g;
    bc.prototype.setValue = function(a, b, c, d) {
        b = this.map[b],
        void 0 !== b && b.setValue(a, c, d)
    }
    ,
    bc.prototype.setOptional = function(a, b, c) {
        b = b[c],
        void 0 !== b && this.setValue(a, c, b)
    }
    ,
    bc.upload = function(a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e]
              , h = c[g.id];
            !1 !== h.needsUpdate && g.setValue(a, h.value, d)
        }
    }
    ,
    bc.seqWithValue = function(a, b) {
        for (var c = [], d = 0, e = a.length; d !== e; ++d) {
            var f = a[d];
            f.id in b && c.push(f)
        }
        return c
    }
    ;
    var Yi = 0
      , Zi = /^[ \t]*#include +<([\w\d./]+)>/gm
      , $i = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , _i = 0;
    Gc.prototype = Object.create(A.prototype),
    Gc.prototype.constructor = Gc,
    Gc.prototype.isMeshDepthMaterial = !0,
    Gc.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.depthPacking = a.depthPacking,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.map = a.map,
        this.alphaMap = a.alphaMap,
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this
    }
    ,
    Hc.prototype = Object.create(A.prototype),
    Hc.prototype.constructor = Hc,
    Hc.prototype.isMeshDistanceMaterial = !0,
    Hc.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.referencePosition.copy(a.referencePosition),
        this.nearDistance = a.nearDistance,
        this.farDistance = a.farDistance,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.map = a.map,
        this.alphaMap = a.alphaMap,
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this
    }
    ,
    Mc.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Mc,
        isWebGLMultiviewRenderTarget: !0,
        copy: function(a) {
            return i.prototype.copy.call(this, a),
            this.numViews = a.numViews,
            this
        },
        setNumViews: function(a) {
            return this.numViews !== a && (this.numViews = a,
            this.dispose()),
            this
        }
    }),
    Oc.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Oc,
        isArrayCamera: !0
    }),
    Pc.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Pc,
        isGroup: !0
    }),
    Object.assign(Qc.prototype, b.prototype),
    Object.assign(Sc.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new Sc(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(Tc.prototype, {
        isFog: !0,
        clone: function() {
            return new Tc(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    Object.defineProperty(Uc.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    }),
    Object.assign(Uc.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(a) {
            return this.usage = a,
            this
        },
        copy: function(a) {
            return this.array = new a.array.constructor(a.array),
            this.count = a.count,
            this.stride = a.stride,
            this.usage = a.usage,
            this
        },
        copyAt: function(a, b, c) {
            a *= this.stride,
            c *= b.stride;
            for (var d = 0, e = this.stride; e > d; d++)
                this.array[a + d] = b.array[c + d];
            return this
        },
        set: function(a, b) {
            return void 0 === b && (b = 0),
            this.array.set(a, b),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(a) {
            return this.onUploadCallback = a,
            this
        }
    });
    var aj = new e;
    Object.defineProperties(Vc.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(Vc.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(a) {
            for (var b = 0, c = this.data.count; c > b; b++)
                aj.x = this.getX(b),
                aj.y = this.getY(b),
                aj.z = this.getZ(b),
                aj.applyMatrix4(a),
                this.setXYZ(b, aj.x, aj.y, aj.z);
            return this
        },
        setX: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset] = b,
            this
        },
        setY: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 1] = b,
            this
        },
        setZ: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 2] = b,
            this
        },
        setW: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 3] = b,
            this
        },
        getX: function(a) {
            return this.data.array[a * this.data.stride + this.offset]
        },
        getY: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 1]
        },
        getZ: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 2]
        },
        getW: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 3]
        },
        setXY: function(a, b, c) {
            return a = a * this.data.stride + this.offset,
            this.data.array[a + 0] = b,
            this.data.array[a + 1] = c,
            this
        },
        setXYZ: function(a, b, c, d) {
            return a = a * this.data.stride + this.offset,
            this.data.array[a + 0] = b,
            this.data.array[a + 1] = c,
            this.data.array[a + 2] = d,
            this
        },
        setXYZW: function(a, b, c, d, e) {
            return a = a * this.data.stride + this.offset,
            this.data.array[a + 0] = b,
            this.data.array[a + 1] = c,
            this.data.array[a + 2] = d,
            this.data.array[a + 3] = e,
            this
        }
    }),
    Wc.prototype = Object.create(A.prototype),
    Wc.prototype.constructor = Wc,
    Wc.prototype.isSpriteMaterial = !0,
    Wc.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.map = a.map,
        this.alphaMap = a.alphaMap,
        this.rotation = a.rotation,
        this.sizeAttenuation = a.sizeAttenuation,
        this
    }
    ;
    var bj, cj = new e, dj = new e, ej = new e, fj = new c, gj = new c, hj = new k, ij = new e, jj = new e, kj = new e, lj = new c, mj = new c, nj = new c;
    Xc.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Xc,
        isSprite: !0,
        raycast: function(a, b) {
            null === a.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            dj.setFromMatrixScale(this.matrixWorld),
            hj.copy(a.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse, this.matrixWorld),
            ej.setFromMatrixPosition(this.modelViewMatrix),
            a.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && dj.multiplyScalar(-ej.z);
            var d = this.material.rotation;
            if (0 !== d)
                var e = Math.cos(d)
                  , f = Math.sin(d);
            d = this.center,
            Yc(ij.set(-.5, -.5, 0), ej, d, dj, f, e),
            Yc(jj.set(.5, -.5, 0), ej, d, dj, f, e),
            Yc(kj.set(.5, .5, 0), ej, d, dj, f, e),
            lj.set(0, 0),
            mj.set(1, 0),
            nj.set(1, 1);
            var g = a.ray.intersectTriangle(ij, jj, kj, !1, cj);
            (null !== g || (Yc(jj.set(-.5, .5, 0), ej, d, dj, f, e),
            mj.set(0, 1),
            g = a.ray.intersectTriangle(ij, kj, jj, !1, cj),
            null !== g)) && (f = a.ray.origin.distanceTo(cj),
            f < a.near || f > a.far || b.push({
                distance: f,
                point: cj.clone(),
                uv: u.getUV(cj, ij, jj, kj, lj, mj, nj, new c),
                face: null,
                object: this
            }))
        },
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(a) {
            return n.prototype.copy.call(this, a),
            void 0 !== a.center && this.center.copy(a.center),
            this
        }
    });
    var oj = new e
      , pj = new e;
    Zc.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Zc,
        isLOD: !0,
        copy: function(a) {
            n.prototype.copy.call(this, a, !1);
            for (var b = a.levels, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                this.addLevel(e.object.clone(), e.distance)
            }
            return this.autoUpdate = a.autoUpdate,
            this
        },
        addLevel: function(a, b) {
            void 0 === b && (b = 0),
            b = Math.abs(b);
            for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++)
                ;
            return c.splice(d, 0, {
                distance: b,
                object: a
            }),
            this.add(a),
            this
        },
        getObjectForDistance: function(a) {
            var b = this.levels;
            if (0 < b.length) {
                for (var c = 1, d = b.length; d > c && !(a < b[c].distance); c++)
                    ;
                return b[c - 1].object
            }
            return null
        },
        raycast: function(a, b) {
            if (0 < this.levels.length) {
                oj.setFromMatrixPosition(this.matrixWorld);
                var c = a.ray.origin.distanceTo(oj);
                this.getObjectForDistance(c).raycast(a, b)
            }
        },
        update: function(a) {
            var b = this.levels;
            if (1 < b.length) {
                oj.setFromMatrixPosition(a.matrixWorld),
                pj.setFromMatrixPosition(this.matrixWorld),
                a = oj.distanceTo(pj),
                b[0].object.visible = !0;
                for (var c = 1, d = b.length; d > c && a >= b[c].distance; c++)
                    b[c - 1].object.visible = !1,
                    b[c].object.visible = !0;
                for (; d > c; c++)
                    b[c].object.visible = !1
            }
        },
        toJSON: function(a) {
            a = n.prototype.toJSON.call(this, a),
            !1 === this.autoUpdate && (a.object.autoUpdate = !1),
            a.object.levels = [];
            for (var b = this.levels, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                a.object.levels.push({
                    object: e.object.uuid,
                    distance: e.distance
                })
            }
            return a
        }
    }),
    $c.prototype = Object.assign(Object.create(P.prototype), {
        constructor: $c,
        isSkinnedMesh: !0,
        bind: function(a, b) {
            this.skeleton = a,
            void 0 === b && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            b = this.matrixWorld),
            this.bindMatrix.copy(b),
            this.bindMatrixInverse.getInverse(b)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var a = new h, b = this.geometry.attributes.skinWeight, c = 0, d = b.count; d > c; c++) {
                a.x = b.getX(c),
                a.y = b.getY(c),
                a.z = b.getZ(c),
                a.w = b.getW(c);
                var e = 1 / a.manhattanLength();
                1 / 0 !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0),
                b.setXYZW(c, a.x, a.y, a.z, a.w)
            }
        },
        updateMatrixWorld: function(a) {
            P.prototype.updateMatrixWorld.call(this, a),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var qj = new k
      , rj = new k;
    Object.assign(_c.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; b > a; a++) {
                var c = new k;
                this.bones[a] && c.getInverse(this.bones[a].matrixWorld),
                this.boneInverses.push(c)
            }
        },
        pose: function() {
            var a, b, c = 0;
            for (b = this.bones.length; b > c; c++)
                (a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
            for (c = 0,
            b = this.bones.length; b > c; c++)
                (a = this.bones[c]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld),
                a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld),
                a.matrix.decompose(a.position, a.quaternion, a.scale))
        },
        update: function() {
            for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, d = this.boneTexture, e = 0, f = a.length; f > e; e++)
                qj.multiplyMatrices(a[e] ? a[e].matrixWorld : rj, b[e]),
                qj.toArray(c, 16 * e);
            void 0 !== d && (d.needsUpdate = !0)
        },
        clone: function() {
            return new _c(this.bones,this.boneInverses)
        },
        getBoneByName: function(a) {
            for (var b = 0, c = this.bones.length; c > b; b++) {
                var d = this.bones[b];
                if (d.name === a)
                    return d
            }
        }
    }),
    ad.prototype = Object.assign(Object.create(n.prototype), {
        constructor: ad,
        isBone: !0
    });
    var sj = new k
      , tj = new k
      , uj = []
      , vj = new P;
    bd.prototype = Object.assign(Object.create(P.prototype), {
        constructor: bd,
        isInstancedMesh: !0,
        getMatrixAt: function(a, b) {
            b.fromArray(this.instanceMatrix.array, 16 * a)
        },
        raycast: function(a, b) {
            var c = this.matrixWorld
              , d = this.count;
            if (vj.geometry = this.geometry,
            vj.material = this.material,
            void 0 !== vj.material)
                for (var e = 0; d > e; e++)
                    this.getMatrixAt(e, sj),
                    tj.multiplyMatrices(c, sj),
                    vj.matrixWorld = tj,
                    vj.raycast(a, uj),
                    0 < uj.length && (uj[0].instanceId = e,
                    uj[0].object = this,
                    b.push(uj[0]),
                    uj.length = 0)
        },
        setMatrixAt: function(a, b) {
            b.toArray(this.instanceMatrix.array, 16 * a)
        },
        updateMorphTargets: function() {}
    }),
    cd.prototype = Object.create(A.prototype),
    cd.prototype.constructor = cd,
    cd.prototype.isLineBasicMaterial = !0,
    cd.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.linewidth = a.linewidth,
        this.linecap = a.linecap,
        this.linejoin = a.linejoin,
        this
    }
    ;
    var wj = new e
      , xj = new e
      , yj = new k
      , zj = new s
      , Aj = new r;
    dd.prototype = Object.assign(Object.create(n.prototype), {
        constructor: dd,
        isLine: !0,
        computeLineDistances: function() {
            var a = this.geometry;
            if (a.isBufferGeometry)
                if (null === a.index) {
                    for (var b = a.attributes.position, c = [0], d = 1, e = b.count; e > d; d++)
                        wj.fromBufferAttribute(b, d - 1),
                        xj.fromBufferAttribute(b, d),
                        c[d] = c[d - 1],
                        c[d] += wj.distanceTo(xj);
                    a.setAttribute("lineDistance", new K(c,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (a.isGeometry)
                for (b = a.vertices,
                c = a.lineDistances,
                c[0] = 0,
                d = 1,
                e = b.length; e > d; d++)
                    c[d] = c[d - 1],
                    c[d] += b[d - 1].distanceTo(b[d]);
            return this
        },
        raycast: function(a, b) {
            var c = a.linePrecision
              , d = this.geometry
              , f = this.matrixWorld;
            if (null === d.boundingSphere && d.computeBoundingSphere(),
            Aj.copy(d.boundingSphere),
            Aj.applyMatrix4(f),
            Aj.radius += c,
            !1 !== a.ray.intersectsSphere(Aj)) {
                yj.getInverse(f),
                zj.copy(a.ray).applyMatrix4(yj),
                c /= (this.scale.x + this.scale.y + this.scale.z) / 3,
                c *= c;
                var g = new e
                  , h = new e;
                f = new e;
                var i = new e
                  , j = this && this.isLineSegments ? 2 : 1;
                if (d.isBufferGeometry) {
                    var k = d.index
                      , l = d.attributes.position.array;
                    if (null !== k) {
                        k = k.array,
                        d = 0;
                        for (var m = k.length - 1; m > d; d += j) {
                            var n = k[d + 1];
                            g.fromArray(l, 3 * k[d]),
                            h.fromArray(l, 3 * n),
                            n = zj.distanceSqToSegment(g, h, i, f),
                            n > c || (i.applyMatrix4(this.matrixWorld),
                            n = a.ray.origin.distanceTo(i),
                            n < a.near || n > a.far || b.push({
                                distance: n,
                                point: f.clone().applyMatrix4(this.matrixWorld),
                                index: d,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        }
                    } else
                        for (d = 0,
                        m = l.length / 3 - 1; m > d; d += j)
                            g.fromArray(l, 3 * d),
                            h.fromArray(l, 3 * d + 3),
                            n = zj.distanceSqToSegment(g, h, i, f),
                            n > c || (i.applyMatrix4(this.matrixWorld),
                            n = a.ray.origin.distanceTo(i),
                            n < a.near || n > a.far || b.push({
                                distance: n,
                                point: f.clone().applyMatrix4(this.matrixWorld),
                                index: d,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                } else if (d.isGeometry)
                    for (g = d.vertices,
                    h = g.length,
                    d = 0; h - 1 > d; d += j)
                        n = zj.distanceSqToSegment(g[d], g[d + 1], i, f),
                        n > c || (i.applyMatrix4(this.matrixWorld),
                        n = a.ray.origin.distanceTo(i),
                        n < a.near || n > a.far || b.push({
                            distance: n,
                            point: f.clone().applyMatrix4(this.matrixWorld),
                            index: d,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
            }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var Bj = new e
      , Cj = new e;
    ed.prototype = Object.assign(Object.create(dd.prototype), {
        constructor: ed,
        isLineSegments: !0,
        computeLineDistances: function() {
            var a = this.geometry;
            if (a.isBufferGeometry)
                if (null === a.index) {
                    for (var b = a.attributes.position, c = [], d = 0, e = b.count; e > d; d += 2)
                        Bj.fromBufferAttribute(b, d),
                        Cj.fromBufferAttribute(b, d + 1),
                        c[d] = 0 === d ? 0 : c[d - 1],
                        c[d + 1] = c[d] + Bj.distanceTo(Cj);
                    a.setAttribute("lineDistance", new K(c,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (a.isGeometry)
                for (b = a.vertices,
                c = a.lineDistances,
                d = 0,
                e = b.length; e > d; d += 2)
                    Bj.copy(b[d]),
                    Cj.copy(b[d + 1]),
                    c[d] = 0 === d ? 0 : c[d - 1],
                    c[d + 1] = c[d] + Bj.distanceTo(Cj);
            return this
        }
    }),
    fd.prototype = Object.assign(Object.create(dd.prototype), {
        constructor: fd,
        isLineLoop: !0
    }),
    gd.prototype = Object.create(A.prototype),
    gd.prototype.constructor = gd,
    gd.prototype.isPointsMaterial = !0,
    gd.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.map = a.map,
        this.alphaMap = a.alphaMap,
        this.size = a.size,
        this.sizeAttenuation = a.sizeAttenuation,
        this.morphTargets = a.morphTargets,
        this
    }
    ;
    var Dj = new k
      , Ej = new s
      , Fj = new r
      , Gj = new e;
    hd.prototype = Object.assign(Object.create(n.prototype), {
        constructor: hd,
        isPoints: !0,
        raycast: function(a, b) {
            var c = this.geometry
              , d = this.matrixWorld
              , e = a.params.Points.threshold;
            if (null === c.boundingSphere && c.computeBoundingSphere(),
            Fj.copy(c.boundingSphere),
            Fj.applyMatrix4(d),
            Fj.radius += e,
            !1 !== a.ray.intersectsSphere(Fj))
                if (Dj.getInverse(d),
                Ej.copy(a.ray).applyMatrix4(Dj),
                e /= (this.scale.x + this.scale.y + this.scale.z) / 3,
                e *= e,
                c.isBufferGeometry) {
                    var f = c.index;
                    if (c = c.attributes.position.array,
                    null !== f) {
                        var g = f.array;
                        f = 0;
                        for (var h = g.length; h > f; f++) {
                            var i = g[f];
                            Gj.fromArray(c, 3 * i),
                            id(Gj, i, e, d, a, b, this)
                        }
                    } else
                        for (f = 0,
                        g = c.length / 3; g > f; f++)
                            Gj.fromArray(c, 3 * f),
                            id(Gj, f, e, d, a, b, this)
                } else
                    for (c = c.vertices,
                    f = 0,
                    g = c.length; g > f; f++)
                        id(c[f], f, e, d, a, b, this)
        },
        updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
                a = a.morphAttributes;
                var b = Object.keys(a);
                if (0 < b.length) {
                    var c = a[b[0]];
                    if (void 0 !== c)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        a = 0,
                        b = c.length; b > a; a++) {
                            var d = c[a].name || String(a);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[d] = a
                        }
                }
            } else
                a = a.morphTargets,
                void 0 !== a && 0 < a.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    jd.prototype = Object.assign(Object.create(g.prototype), {
        constructor: jd,
        isVideoTexture: !0,
        update: function() {
            var a = this.image;
            a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    kd.prototype = Object.create(g.prototype),
    kd.prototype.constructor = kd,
    kd.prototype.isCompressedTexture = !0,
    ld.prototype = Object.create(g.prototype),
    ld.prototype.constructor = ld,
    ld.prototype.isCanvasTexture = !0,
    md.prototype = Object.create(g.prototype),
    md.prototype.constructor = md,
    md.prototype.isDepthTexture = !0,
    nd.prototype = Object.create(O.prototype),
    nd.prototype.constructor = nd,
    od.prototype = Object.create(S.prototype),
    od.prototype.constructor = od,
    pd.prototype = Object.create(O.prototype),
    pd.prototype.constructor = pd,
    qd.prototype = Object.create(S.prototype),
    qd.prototype.constructor = qd,
    rd.prototype = Object.create(O.prototype),
    rd.prototype.constructor = rd,
    sd.prototype = Object.create(S.prototype),
    sd.prototype.constructor = sd,
    td.prototype = Object.create(rd.prototype),
    td.prototype.constructor = td,
    ud.prototype = Object.create(S.prototype),
    ud.prototype.constructor = ud,
    vd.prototype = Object.create(rd.prototype),
    vd.prototype.constructor = vd,
    wd.prototype = Object.create(S.prototype),
    wd.prototype.constructor = wd,
    xd.prototype = Object.create(rd.prototype),
    xd.prototype.constructor = xd,
    yd.prototype = Object.create(S.prototype),
    yd.prototype.constructor = yd,
    zd.prototype = Object.create(rd.prototype),
    zd.prototype.constructor = zd,
    Ad.prototype = Object.create(S.prototype),
    Ad.prototype.constructor = Ad,
    Bd.prototype = Object.create(O.prototype),
    Bd.prototype.constructor = Bd,
    Bd.prototype.toJSON = function() {
        var a = O.prototype.toJSON.call(this);
        return a.path = this.parameters.path.toJSON(),
        a
    }
    ,
    Cd.prototype = Object.create(S.prototype),
    Cd.prototype.constructor = Cd,
    Dd.prototype = Object.create(O.prototype),
    Dd.prototype.constructor = Dd,
    Ed.prototype = Object.create(S.prototype),
    Ed.prototype.constructor = Ed,
    Fd.prototype = Object.create(O.prototype),
    Fd.prototype.constructor = Fd;
    var Hj = {
        triangulate: function(a, b, c) {
            c = c || 2;
            var d = b && b.length
              , e = d ? b[0] * c : a.length
              , f = Gd(a, 0, e, c, !0)
              , g = [];
            if (!f || f.next === f.prev)
                return g;
            var h;
            if (d) {
                var i = c;
                d = [];
                var j, k = 0;
                for (j = b.length; j > k; k++) {
                    var l = b[k] * i
                      , m = j - 1 > k ? b[k + 1] * i : a.length;
                    l = Gd(a, l, m, i, !1),
                    l === l.next && (l.steiner = !0),
                    d.push(Nd(l))
                }
                for (d.sort(Kd),
                k = 0; k < d.length; k++)
                    b = d[k],
                    i = f,
                    (i = Ld(b, i)) && (b = Td(i, b),
                    Hd(b, b.next)),
                    f = Hd(f, f.next)
            }
            if (a.length > 80 * c) {
                var n = h = a[0]
                  , o = d = a[1];
                for (i = c; e > i; i += c)
                    k = a[i],
                    b = a[i + 1],
                    n > k && (n = k),
                    o > b && (o = b),
                    k > h && (h = k),
                    b > d && (d = b);
                h = Math.max(h - n, d - o),
                h = 0 !== h ? 1 / h : 0
            }
            return Id(f, g, c, n, o, h),
            g
        }
    }
      , Ij = {
        area: function(a) {
            for (var b = a.length, c = 0, d = b - 1, e = 0; b > e; d = e++)
                c += a[d].x * a[e].y - a[e].x * a[d].y;
            return .5 * c
        },
        isClockWise: function(a) {
            return 0 > Ij.area(a)
        },
        triangulateShape: function(a, b) {
            var c = []
              , d = []
              , e = [];
            Xd(a),
            Yd(c, a);
            var f = a.length;
            for (b.forEach(Xd),
            a = 0; a < b.length; a++)
                d.push(f),
                f += b[a].length,
                Yd(c, b[a]);
            for (b = Hj.triangulate(c, d),
            a = 0; a < b.length; a += 3)
                e.push(b.slice(a, a + 3));
            return e
        }
    };
    Zd.prototype = Object.create(S.prototype),
    Zd.prototype.constructor = Zd,
    Zd.prototype.toJSON = function() {
        var a = S.prototype.toJSON.call(this);
        return _d(this.parameters.shapes, this.parameters.options, a)
    }
    ,
    $d.prototype = Object.create(O.prototype),
    $d.prototype.constructor = $d,
    $d.prototype.toJSON = function() {
        var a = O.prototype.toJSON.call(this);
        return _d(this.parameters.shapes, this.parameters.options, a)
    }
    ;
    var Jj = {
        generateTopUV: function(a, b, d, e, f) {
            a = b[3 * e],
            e = b[3 * e + 1];
            var g = b[3 * f];
            return f = b[3 * f + 1],
            [new c(b[3 * d],b[3 * d + 1]), new c(a,e), new c(g,f)]
        },
        generateSideWallUV: function(a, b, d, e, f, g) {
            a = b[3 * d];
            var h = b[3 * d + 1];
            d = b[3 * d + 2];
            var i = b[3 * e]
              , j = b[3 * e + 1];
            e = b[3 * e + 2];
            var k = b[3 * f]
              , l = b[3 * f + 1];
            f = b[3 * f + 2];
            var m = b[3 * g]
              , n = b[3 * g + 1];
            return b = b[3 * g + 2],
            .01 > Math.abs(h - j) ? [new c(a,1 - d), new c(i,1 - e), new c(k,1 - f), new c(m,1 - b)] : [new c(h,1 - d), new c(j,1 - e), new c(l,1 - f), new c(n,1 - b)]
        }
    };
    ae.prototype = Object.create(S.prototype),
    ae.prototype.constructor = ae,
    be.prototype = Object.create($d.prototype),
    be.prototype.constructor = be,
    ce.prototype = Object.create(S.prototype),
    ce.prototype.constructor = ce,
    de.prototype = Object.create(O.prototype),
    de.prototype.constructor = de,
    ee.prototype = Object.create(S.prototype),
    ee.prototype.constructor = ee,
    fe.prototype = Object.create(O.prototype),
    fe.prototype.constructor = fe,
    ge.prototype = Object.create(S.prototype),
    ge.prototype.constructor = ge,
    he.prototype = Object.create(O.prototype),
    he.prototype.constructor = he,
    ie.prototype = Object.create(S.prototype),
    ie.prototype.constructor = ie,
    ie.prototype.toJSON = function() {
        var a = S.prototype.toJSON.call(this);
        return ke(this.parameters.shapes, a)
    }
    ,
    je.prototype = Object.create(O.prototype),
    je.prototype.constructor = je,
    je.prototype.toJSON = function() {
        var a = O.prototype.toJSON.call(this);
        return ke(this.parameters.shapes, a)
    }
    ,
    le.prototype = Object.create(O.prototype),
    le.prototype.constructor = le,
    me.prototype = Object.create(S.prototype),
    me.prototype.constructor = me,
    ne.prototype = Object.create(O.prototype),
    ne.prototype.constructor = ne,
    oe.prototype = Object.create(me.prototype),
    oe.prototype.constructor = oe,
    pe.prototype = Object.create(ne.prototype),
    pe.prototype.constructor = pe,
    qe.prototype = Object.create(S.prototype),
    qe.prototype.constructor = qe,
    re.prototype = Object.create(O.prototype),
    re.prototype.constructor = re;
    var Kj = Object.freeze({
        __proto__: null,
        WireframeGeometry: nd,
        ParametricGeometry: od,
        ParametricBufferGeometry: pd,
        TetrahedronGeometry: sd,
        TetrahedronBufferGeometry: td,
        OctahedronGeometry: ud,
        OctahedronBufferGeometry: vd,
        IcosahedronGeometry: wd,
        IcosahedronBufferGeometry: xd,
        DodecahedronGeometry: yd,
        DodecahedronBufferGeometry: zd,
        PolyhedronGeometry: qd,
        PolyhedronBufferGeometry: rd,
        TubeGeometry: Ad,
        TubeBufferGeometry: Bd,
        TorusKnotGeometry: Cd,
        TorusKnotBufferGeometry: Dd,
        TorusGeometry: Ed,
        TorusBufferGeometry: Fd,
        TextGeometry: ae,
        TextBufferGeometry: be,
        SphereGeometry: ce,
        SphereBufferGeometry: de,
        RingGeometry: ee,
        RingBufferGeometry: fe,
        PlaneGeometry: cb,
        PlaneBufferGeometry: db,
        LatheGeometry: ge,
        LatheBufferGeometry: he,
        ShapeGeometry: ie,
        ShapeBufferGeometry: je,
        ExtrudeGeometry: Zd,
        ExtrudeBufferGeometry: $d,
        EdgesGeometry: le,
        ConeGeometry: oe,
        ConeBufferGeometry: pe,
        CylinderGeometry: me,
        CylinderBufferGeometry: ne,
        CircleGeometry: qe,
        CircleBufferGeometry: re,
        BoxGeometry: Gi,
        BoxBufferGeometry: Hi
    });
    se.prototype = Object.create(A.prototype),
    se.prototype.constructor = se,
    se.prototype.isShadowMaterial = !0,
    se.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this
    }
    ,
    te.prototype = Object.create(V.prototype),
    te.prototype.constructor = te,
    te.prototype.isRawShaderMaterial = !0,
    ue.prototype = Object.create(A.prototype),
    ue.prototype.constructor = ue,
    ue.prototype.isMeshStandardMaterial = !0,
    ue.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(a.color),
        this.roughness = a.roughness,
        this.metalness = a.metalness,
        this.map = a.map,
        this.lightMap = a.lightMap,
        this.lightMapIntensity = a.lightMapIntensity,
        this.aoMap = a.aoMap,
        this.aoMapIntensity = a.aoMapIntensity,
        this.emissive.copy(a.emissive),
        this.emissiveMap = a.emissiveMap,
        this.emissiveIntensity = a.emissiveIntensity,
        this.bumpMap = a.bumpMap,
        this.bumpScale = a.bumpScale,
        this.normalMap = a.normalMap,
        this.normalMapType = a.normalMapType,
        this.normalScale.copy(a.normalScale),
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.roughnessMap = a.roughnessMap,
        this.metalnessMap = a.metalnessMap,
        this.alphaMap = a.alphaMap,
        this.envMap = a.envMap,
        this.envMapIntensity = a.envMapIntensity,
        this.refractionRatio = a.refractionRatio,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.wireframeLinecap = a.wireframeLinecap,
        this.wireframeLinejoin = a.wireframeLinejoin,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    ve.prototype = Object.create(ue.prototype),
    ve.prototype.constructor = ve,
    ve.prototype.isMeshPhysicalMaterial = !0,
    ve.prototype.copy = function(a) {
        return ue.prototype.copy.call(this, a),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.reflectivity = a.reflectivity,
        this.clearcoat = a.clearcoat,
        this.clearcoatRoughness = a.clearcoatRoughness,
        this.sheen = a.sheen ? (this.sheen || new v).copy(a.sheen) : null,
        this.clearcoatNormalMap = a.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(a.clearcoatNormalScale),
        this.transparency = a.transparency,
        this
    }
    ,
    we.prototype = Object.create(A.prototype),
    we.prototype.constructor = we,
    we.prototype.isMeshPhongMaterial = !0,
    we.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.specular.copy(a.specular),
        this.shininess = a.shininess,
        this.map = a.map,
        this.lightMap = a.lightMap,
        this.lightMapIntensity = a.lightMapIntensity,
        this.aoMap = a.aoMap,
        this.aoMapIntensity = a.aoMapIntensity,
        this.emissive.copy(a.emissive),
        this.emissiveMap = a.emissiveMap,
        this.emissiveIntensity = a.emissiveIntensity,
        this.bumpMap = a.bumpMap,
        this.bumpScale = a.bumpScale,
        this.normalMap = a.normalMap,
        this.normalMapType = a.normalMapType,
        this.normalScale.copy(a.normalScale),
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.specularMap = a.specularMap,
        this.alphaMap = a.alphaMap,
        this.envMap = a.envMap,
        this.combine = a.combine,
        this.reflectivity = a.reflectivity,
        this.refractionRatio = a.refractionRatio,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.wireframeLinecap = a.wireframeLinecap,
        this.wireframeLinejoin = a.wireframeLinejoin,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    xe.prototype = Object.create(A.prototype),
    xe.prototype.constructor = xe,
    xe.prototype.isMeshToonMaterial = !0,
    xe.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.specular.copy(a.specular),
        this.shininess = a.shininess,
        this.map = a.map,
        this.gradientMap = a.gradientMap,
        this.lightMap = a.lightMap,
        this.lightMapIntensity = a.lightMapIntensity,
        this.aoMap = a.aoMap,
        this.aoMapIntensity = a.aoMapIntensity,
        this.emissive.copy(a.emissive),
        this.emissiveMap = a.emissiveMap,
        this.emissiveIntensity = a.emissiveIntensity,
        this.bumpMap = a.bumpMap,
        this.bumpScale = a.bumpScale,
        this.normalMap = a.normalMap,
        this.normalMapType = a.normalMapType,
        this.normalScale.copy(a.normalScale),
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.specularMap = a.specularMap,
        this.alphaMap = a.alphaMap,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.wireframeLinecap = a.wireframeLinecap,
        this.wireframeLinejoin = a.wireframeLinejoin,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    ye.prototype = Object.create(A.prototype),
    ye.prototype.constructor = ye,
    ye.prototype.isMeshNormalMaterial = !0,
    ye.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.bumpMap = a.bumpMap,
        this.bumpScale = a.bumpScale,
        this.normalMap = a.normalMap,
        this.normalMapType = a.normalMapType,
        this.normalScale.copy(a.normalScale),
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    ze.prototype = Object.create(A.prototype),
    ze.prototype.constructor = ze,
    ze.prototype.isMeshLambertMaterial = !0,
    ze.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.color.copy(a.color),
        this.map = a.map,
        this.lightMap = a.lightMap,
        this.lightMapIntensity = a.lightMapIntensity,
        this.aoMap = a.aoMap,
        this.aoMapIntensity = a.aoMapIntensity,
        this.emissive.copy(a.emissive),
        this.emissiveMap = a.emissiveMap,
        this.emissiveIntensity = a.emissiveIntensity,
        this.specularMap = a.specularMap,
        this.alphaMap = a.alphaMap,
        this.envMap = a.envMap,
        this.combine = a.combine,
        this.reflectivity = a.reflectivity,
        this.refractionRatio = a.refractionRatio,
        this.wireframe = a.wireframe,
        this.wireframeLinewidth = a.wireframeLinewidth,
        this.wireframeLinecap = a.wireframeLinecap,
        this.wireframeLinejoin = a.wireframeLinejoin,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    Ae.prototype = Object.create(A.prototype),
    Ae.prototype.constructor = Ae,
    Ae.prototype.isMeshMatcapMaterial = !0,
    Ae.prototype.copy = function(a) {
        return A.prototype.copy.call(this, a),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(a.color),
        this.matcap = a.matcap,
        this.map = a.map,
        this.bumpMap = a.bumpMap,
        this.bumpScale = a.bumpScale,
        this.normalMap = a.normalMap,
        this.normalMapType = a.normalMapType,
        this.normalScale.copy(a.normalScale),
        this.displacementMap = a.displacementMap,
        this.displacementScale = a.displacementScale,
        this.displacementBias = a.displacementBias,
        this.alphaMap = a.alphaMap,
        this.skinning = a.skinning,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this
    }
    ,
    Be.prototype = Object.create(cd.prototype),
    Be.prototype.constructor = Be,
    Be.prototype.isLineDashedMaterial = !0,
    Be.prototype.copy = function(a) {
        return cd.prototype.copy.call(this, a),
        this.scale = a.scale,
        this.dashSize = a.dashSize,
        this.gapSize = a.gapSize,
        this
    }
    ;
    var Lj = Object.freeze({
        __proto__: null,
        ShadowMaterial: se,
        SpriteMaterial: Wc,
        RawShaderMaterial: te,
        ShaderMaterial: V,
        PointsMaterial: gd,
        MeshPhysicalMaterial: ve,
        MeshStandardMaterial: ue,
        MeshPhongMaterial: we,
        MeshToonMaterial: xe,
        MeshNormalMaterial: ye,
        MeshLambertMaterial: ze,
        MeshDepthMaterial: Gc,
        MeshDistanceMaterial: Hc,
        MeshBasicMaterial: B,
        MeshMatcapMaterial: Ae,
        LineDashedMaterial: Be,
        LineBasicMaterial: cd,
        Material: A
    })
      , Mj = {
        arraySlice: function(a, b, c) {
            return Mj.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
        },
        convertArray: function(a, b, c) {
            return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
        },
        isTypedArray: function(a) {
            return ArrayBuffer.isView(a) && !(a instanceof DataView)
        },
        getKeyframeOrder: function(a) {
            for (var b = a.length, c = Array(b), d = 0; d !== b; ++d)
                c[d] = d;
            return c.sort(function(b, c) {
                return a[b] - a[c]
            }),
            c
        },
        sortedArray: function(a, b, c) {
            for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
                for (var h = c[f] * b, i = 0; i !== b; ++i)
                    e[g++] = a[h + i];
            return e
        },
        flattenJSON: function(a, b, c, d) {
            for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; )
                f = a[e++];
            if (void 0 !== f) {
                var g = f[d];
                if (void 0 !== g)
                    if (Array.isArray(g)) {
                        do
                            g = f[d],
                            void 0 !== g && (b.push(f.time),
                            c.push.apply(c, g)),
                            f = a[e++];
                        while (void 0 !== f)
                    } else if (void 0 !== g.toArray) {
                        do
                            g = f[d],
                            void 0 !== g && (b.push(f.time),
                            g.toArray(c, c.length)),
                            f = a[e++];
                        while (void 0 !== f)
                    } else
                        do
                            g = f[d],
                            void 0 !== g && (b.push(f.time),
                            c.push(g)),
                            f = a[e++];
                        while (void 0 !== f)
            }
        },
        subclip: function(a, b, c, d, e) {
            e = e || 30,
            a = a.clone(),
            a.name = b;
            var f = [];
            for (b = 0; b < a.tracks.length; ++b) {
                for (var g = a.tracks[b], h = g.getValueSize(), i = [], j = [], k = 0; k < g.times.length; ++k) {
                    var l = g.times[k] * e;
                    if (!(c > l || l >= d))
                        for (i.push(g.times[k]),
                        l = 0; h > l; ++l)
                            j.push(g.values[k * h + l])
                }
                0 !== i.length && (g.times = Mj.convertArray(i, g.times.constructor),
                g.values = Mj.convertArray(j, g.values.constructor),
                f.push(g))
            }
            for (a.tracks = f,
            c = 1 / 0,
            b = 0; b < a.tracks.length; ++b)
                c > a.tracks[b].times[0] && (c = a.tracks[b].times[0]);
            for (b = 0; b < a.tracks.length; ++b)
                a.tracks[b].shift(-1 * c);
            return a.resetDuration(),
            a
        }
    };
    Object.assign(Ce.prototype, {
        evaluate: function(a) {
            var b = this.parameterPositions
              , c = this._cachedIndex
              , d = b[c]
              , e = b[c - 1];
            a: {
                b: {
                    c: {
                        d: if (!(d > a)) {
                            for (var f = c + 2; ; ) {
                                if (void 0 === d) {
                                    if (e > a)
                                        break d;
                                    return this._cachedIndex = c = b.length,
                                    this.afterEnd_(c - 1, a, e)
                                }
                                if (c === f)
                                    break;
                                if (e = d,
                                d = b[++c],
                                d > a)
                                    break b
                            }
                            d = b.length;
                            break c
                        }
                        if (a >= e)
                            break a;
                        for (f = b[1],
                        f > a && (c = 2,
                        e = f),
                        f = c - 2; ; ) {
                            if (void 0 === e)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, a, d);
                            if (c === f)
                                break;
                            if (d = e,
                            e = b[--c - 1],
                            a >= e)
                                break b
                        }
                        d = c,
                        c = 0
                    }
                    for (; d > c; )
                        e = c + d >>> 1,
                        a < b[e] ? d = e : c = e + 1;
                    if (d = b[c],
                    e = b[c - 1],
                    void 0 === e)
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, a, d);
                    if (void 0 === d)
                        return this._cachedIndex = c = b.length,
                        this.afterEnd_(c - 1, e, a)
                }
                this._cachedIndex = c,
                this.intervalChanged_(c, e, d)
            }
            return this.interpolate_(c, e, a, d)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(a) {
            var b = this.resultBuffer
              , c = this.sampleValues
              , d = this.valueSize;
            a *= d;
            for (var e = 0; e !== d; ++e)
                b[e] = c[a + e];
            return b
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Ce.prototype, {
        beforeStart_: Ce.prototype.copySampleValue_,
        afterEnd_: Ce.prototype.copySampleValue_
    }),
    De.prototype = Object.assign(Object.create(Ce.prototype), {
        constructor: De,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(a, b, c) {
            var d = this.parameterPositions
              , e = a - 2
              , f = a + 1
              , g = d[e]
              , h = d[f];
            if (void 0 === g)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    e = a,
                    g = 2 * b - c;
                    break;
                case 2402:
                    e = d.length - 2,
                    g = b + d[e] - d[e + 1];
                    break;
                default:
                    e = a,
                    g = c
                }
            if (void 0 === h)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    f = a,
                    h = 2 * c - b;
                    break;
                case 2402:
                    f = 1,
                    h = c + d[1] - d[0];
                    break;
                default:
                    f = a - 1,
                    h = b
                }
            a = .5 * (c - b),
            d = this.valueSize,
            this._weightPrev = a / (b - g),
            this._weightNext = a / (h - c),
            this._offsetPrev = e * d,
            this._offsetNext = f * d
        },
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer
              , f = this.sampleValues
              , g = this.valueSize;
            a *= g;
            var h = a - g
              , i = this._offsetPrev
              , j = this._offsetNext
              , k = this._weightPrev
              , l = this._weightNext
              , m = (c - b) / (d - b);
            for (c = m * m,
            d = c * m,
            b = -k * d + 2 * k * c - k * m,
            k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1,
            m = (-1 - l) * d + (1.5 + l) * c + .5 * m,
            l = l * d - l * c,
            c = 0; c !== g; ++c)
                e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
            return e
        }
    }),
    Ee.prototype = Object.assign(Object.create(Ce.prototype), {
        constructor: Ee,
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer
              , f = this.sampleValues
              , g = this.valueSize;
            a *= g;
            var h = a - g;
            for (b = (c - b) / (d - b),
            c = 1 - b,
            d = 0; d !== g; ++d)
                e[d] = f[h + d] * c + f[a + d] * b;
            return e
        }
    }),
    Fe.prototype = Object.assign(Object.create(Ce.prototype), {
        constructor: Fe,
        interpolate_: function(a) {
            return this.copySampleValue_(a - 1)
        }
    }),
    Object.assign(Ge, {
        toJSON: function(a) {
            var b = a.constructor;
            if (void 0 !== b.toJSON)
                b = b.toJSON(a);
            else {
                b = {
                    name: a.name,
                    times: Mj.convertArray(a.times, Array),
                    values: Mj.convertArray(a.values, Array)
                };
                var c = a.getInterpolation();
                c !== a.DefaultInterpolation && (b.interpolation = c)
            }
            return b.type = a.ValueTypeName,
            b
        }
    }),
    Object.assign(Ge.prototype, {
        constructor: Ge,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(a) {
            return new Fe(this.times,this.values,this.getValueSize(),a)
        },
        InterpolantFactoryMethodLinear: function(a) {
            return new Ee(this.times,this.values,this.getValueSize(),a)
        },
        InterpolantFactoryMethodSmooth: function(a) {
            return new De(this.times,this.values,this.getValueSize(),a)
        },
        setInterpolation: function(a) {
            switch (a) {
            case 2300:
                var b = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                b = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                b = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === b) {
                if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name,
                void 0 === this.createInterpolant) {
                    if (a === this.DefaultInterpolation)
                        throw Error(b);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", b),
                this
            }
            return this.createInterpolant = b,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(a) {
            if (0 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c)
                    b[c] += a;
            return this
        },
        scale: function(a) {
            if (1 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c)
                    b[c] *= a;
            return this
        },
        trim: function(a, b) {
            for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a; )
                ++e;
            for (; -1 !== f && c[f] > b; )
                --f;
            return ++f,
            (0 !== e || f !== d) && (e >= f && (f = Math.max(f, 1),
            e = f - 1),
            a = this.getValueSize(),
            this.times = Mj.arraySlice(c, e, f),
            this.values = Mj.arraySlice(this.values, e * a, f * a)),
            this
        },
        validate: function() {
            var a = !0
              , b = this.getValueSize();
            0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            a = !1);
            var c = this.times;
            b = this.values;
            var d = c.length;
            0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            a = !1);
            for (var e = null, f = 0; f !== d; f++) {
                var g = c[f];
                if ("number" == typeof g && isNaN(g)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g),
                    a = !1;
                    break
                }
                if (null !== e && e > g) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e),
                    a = !1;
                    break
                }
                e = g
            }
            if (void 0 !== b && Mj.isTypedArray(b))
                for (f = 0,
                c = b.length; f !== c; ++f)
                    if (d = b[f],
                    isNaN(d)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d),
                        a = !1;
                        break
                    }
            return a
        },
        optimize: function() {
            for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; f > g; ++g) {
                var h = !1
                  , i = a[g];
                if (i !== a[g + 1] && (1 !== g || i !== i[0]))
                    if (d)
                        h = !0;
                    else {
                        var j = g * c
                          , k = j - c
                          , l = j + c;
                        for (i = 0; i !== c; ++i) {
                            var m = b[j + i];
                            if (m !== b[k + i] || m !== b[l + i]) {
                                h = !0;
                                break
                            }
                        }
                    }
                if (h) {
                    if (g !== e)
                        for (a[e] = a[g],
                        h = g * c,
                        j = e * c,
                        i = 0; i !== c; ++i)
                            b[j + i] = b[h + i];
                    ++e
                }
            }
            if (f > 0) {
                for (a[e] = a[f],
                h = f * c,
                j = e * c,
                i = 0; i !== c; ++i)
                    b[j + i] = b[h + i];
                ++e
            }
            return e !== a.length && (this.times = Mj.arraySlice(a, 0, e),
            this.values = Mj.arraySlice(b, 0, e * c)),
            this
        },
        clone: function() {
            var a = Mj.arraySlice(this.times, 0)
              , b = Mj.arraySlice(this.values, 0);
            return a = new this.constructor(this.name,a,b),
            a.createInterpolant = this.createInterpolant,
            a
        }
    }),
    He.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: He,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Ie.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Ie,
        ValueTypeName: "color"
    }),
    Je.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Je,
        ValueTypeName: "number"
    }),
    Ke.prototype = Object.assign(Object.create(Ce.prototype), {
        constructor: Ke,
        interpolate_: function(a, b, c, e) {
            var f = this.resultBuffer
              , g = this.sampleValues
              , h = this.valueSize;
            for (a *= h,
            b = (c - b) / (e - b),
            c = a + h; a !== c; a += 4)
                d.slerpFlat(f, 0, g, a - h, g, a, b);
            return f
        }
    }),
    Le.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Le,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(a) {
            return new Ke(this.times,this.values,this.getValueSize(),a)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Me.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Me,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Ne.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Ne,
        ValueTypeName: "vector"
    }),
    Object.assign(Oe, {
        parse: function(a) {
            for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e)
                b.push(Qe(c[e]).scale(d));
            return new Oe(a.name,a.duration,b)
        },
        toJSON: function(a) {
            var b = []
              , c = a.tracks;
            a = {
                name: a.name,
                duration: a.duration,
                tracks: b,
                uuid: a.uuid
            };
            for (var d = 0, e = c.length; d !== e; ++d)
                b.push(Ge.toJSON(c[d]));
            return a
        },
        CreateFromMorphTargetSequence: function(a, b, c, d) {
            for (var e = b.length, f = [], g = 0; e > g; g++) {
                var h = []
                  , i = [];
                h.push((g + e - 1) % e, g, (g + 1) % e),
                i.push(0, 1, 0);
                var j = Mj.getKeyframeOrder(h);
                h = Mj.sortedArray(h, 1, j),
                i = Mj.sortedArray(i, 1, j),
                d || 0 !== h[0] || (h.push(e),
                i.push(i[0])),
                f.push(new Je(".morphTargetInfluences[" + b[g].name + "]",h,i).scale(1 / c))
            }
            return new Oe(a,-1,f)
        },
        findByName: function(a, b) {
            var c = a;
            for (Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations),
            a = 0; a < c.length; a++)
                if (c[a].name === b)
                    return c[a];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(a, b, c) {
            for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; g > f; f++) {
                var h = a[f]
                  , i = h.name.match(e);
                if (i && 1 < i.length) {
                    var j = i[1];
                    (i = d[j]) || (d[j] = i = []),
                    i.push(h)
                }
            }
            a = [];
            for (j in d)
                a.push(Oe.CreateFromMorphTargetSequence(j, d[j], b, c));
            return a
        },
        parseAnimation: function(a, b) {
            if (!a)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            var c = function(a, b, c, d, e) {
                if (0 !== c.length) {
                    var f = []
                      , g = [];
                    Mj.flattenJSON(c, f, g, d),
                    0 !== f.length && e.push(new a(b,f,g))
                }
            }
              , d = []
              , e = a.name || "default"
              , f = a.length || -1
              , g = a.fps || 30;
            a = a.hierarchy || [];
            for (var h = 0; h < a.length; h++) {
                var i = a[h].keys;
                if (i && 0 !== i.length)
                    if (i[0].morphTargets) {
                        f = {};
                        for (var j = 0; j < i.length; j++)
                            if (i[j].morphTargets)
                                for (var k = 0; k < i[j].morphTargets.length; k++)
                                    f[i[j].morphTargets[k]] = -1;
                        for (var l in f) {
                            var m = []
                              , n = [];
                            for (k = 0; k !== i[j].morphTargets.length; ++k) {
                                var o = i[j];
                                m.push(o.time),
                                n.push(o.morphTarget === l ? 1 : 0)
                            }
                            d.push(new Je(".morphTargetInfluence[" + l + "]",m,n))
                        }
                        f = f.length * (g || 1)
                    } else
                        j = ".bones[" + b[h].name + "]",
                        c(Ne, j + ".position", i, "pos", d),
                        c(Le, j + ".quaternion", i, "rot", d),
                        c(Ne, j + ".scale", i, "scl", d)
            }
            return 0 === d.length ? null : new Oe(e,f,d)
        }
    }),
    Object.assign(Oe.prototype, {
        resetDuration: function() {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
                var d = this.tracks[b];
                a = Math.max(a, d.times[d.times.length - 1])
            }
            return this.duration = a,
            this
        },
        trim: function() {
            for (var a = 0; a < this.tracks.length; a++)
                this.tracks[a].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var a = !0, b = 0; b < this.tracks.length; b++)
                a = a && this.tracks[b].validate();
            return a
        },
        optimize: function() {
            for (var a = 0; a < this.tracks.length; a++)
                this.tracks[a].optimize();
            return this
        },
        clone: function() {
            for (var a = [], b = 0; b < this.tracks.length; b++)
                a.push(this.tracks[b].clone());
            return new Oe(this.name,this.duration,a)
        }
    });
    var Nj = {
        enabled: !1,
        files: {},
        add: function(a, b) {
            !1 !== this.enabled && (this.files[a] = b)
        },
        get: function(a) {
            return !1 !== this.enabled ? this.files[a] : void 0
        },
        remove: function(a) {
            delete this.files[a]
        },
        clear: function() {
            this.files = {}
        }
    }
      , Oj = new Re;
    Object.assign(Se.prototype, {
        load: function() {},
        parse: function() {},
        setCrossOrigin: function(a) {
            return this.crossOrigin = a,
            this
        },
        setPath: function(a) {
            return this.path = a,
            this
        },
        setResourcePath: function(a) {
            return this.resourcePath = a,
            this
        }
    });
    var Pj = {};
    Te.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Te,
        load: function(a, b, c, d) {
            void 0 === a && (a = ""),
            void 0 !== this.path && (a = this.path + a),
            a = this.manager.resolveURL(a);
            var e = this
              , f = Nj.get(a);
            if (void 0 !== f)
                return e.manager.itemStart(a),
                setTimeout(function() {
                    b && b(f),
                    e.manager.itemEnd(a)
                }, 0),
                f;
            if (void 0 === Pj[a]) {
                var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (g) {
                    c = g[1];
                    var h = !!g[2];
                    g = g[3],
                    g = decodeURIComponent(g),
                    h && (g = atob(g));
                    try {
                        var i = (this.responseType || "").toLowerCase();
                        switch (i) {
                        case "arraybuffer":
                        case "blob":
                            var j = new Uint8Array(g.length);
                            for (h = 0; h < g.length; h++)
                                j[h] = g.charCodeAt(h);
                            var k = "blob" === i ? new Blob([j.buffer],{
                                type: c
                            }) : j.buffer;
                            break;
                        case "document":
                            k = (new DOMParser).parseFromString(g, c);
                            break;
                        case "json":
                            k = JSON.parse(g);
                            break;
                        default:
                            k = g
                        }
                        setTimeout(function() {
                            b && b(k),
                            e.manager.itemEnd(a)
                        }, 0)
                    } catch (l) {
                        setTimeout(function() {
                            d && d(l),
                            e.manager.itemError(a),
                            e.manager.itemEnd(a)
                        }, 0)
                    }
                } else {
                    Pj[a] = [],
                    Pj[a].push({
                        onLoad: b,
                        onProgress: c,
                        onError: d
                    });
                    var m = new XMLHttpRequest;
                    m.open("GET", a, !0),
                    m.addEventListener("load", function(b) {
                        var c = this.response
                          , d = Pj[a];
                        if (delete Pj[a],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            Nj.add(a, c);
                            for (var f = 0, g = d.length; g > f; f++) {
                                var h = d[f];
                                h.onLoad && h.onLoad(c)
                            }
                        } else {
                            for (f = 0,
                            g = d.length; g > f; f++)
                                h = d[f],
                                h.onError && h.onError(b);
                            e.manager.itemError(a)
                        }
                        e.manager.itemEnd(a)
                    }, !1),
                    m.addEventListener("progress", function(b) {
                        for (var c = Pj[a], d = 0, e = c.length; e > d; d++) {
                            var f = c[d];
                            f.onProgress && f.onProgress(b)
                        }
                    }, !1),
                    m.addEventListener("error", function(b) {
                        var c = Pj[a];
                        delete Pj[a];
                        for (var d = 0, f = c.length; f > d; d++) {
                            var g = c[d];
                            g.onError && g.onError(b)
                        }
                        e.manager.itemError(a),
                        e.manager.itemEnd(a)
                    }, !1),
                    m.addEventListener("abort", function(b) {
                        var c = Pj[a];
                        delete Pj[a];
                        for (var d = 0, f = c.length; f > d; d++) {
                            var g = c[d];
                            g.onError && g.onError(b)
                        }
                        e.manager.itemError(a),
                        e.manager.itemEnd(a)
                    }, !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (h in this.requestHeader)
                        m.setRequestHeader(h, this.requestHeader[h]);
                    m.send(null)
                }
                return e.manager.itemStart(a),
                m
            }
            Pj[a].push({
                onLoad: b,
                onProgress: c,
                onError: d
            })
        },
        setResponseType: function(a) {
            return this.responseType = a,
            this
        },
        setWithCredentials: function(a) {
            return this.withCredentials = a,
            this
        },
        setMimeType: function(a) {
            return this.mimeType = a,
            this
        },
        setRequestHeader: function(a) {
            return this.requestHeader = a,
            this
        }
    }),
    Ue.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Ue,
        load: function(a, b, c, d) {
            var e = this
              , f = new Te(e.manager);
            f.setPath(e.path),
            f.load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        parse: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = Oe.parse(a[c]);
                b.push(d)
            }
            return b
        }
    }),
    Ve.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Ve,
        load: function(a, b, c, d) {
            function e(e) {
                i.load(a[e], function(a) {
                    a = f.parse(a, !0),
                    g[e] = {
                        width: a.width,
                        height: a.height,
                        format: a.format,
                        mipmaps: a.mipmaps
                    },
                    j += 1,
                    6 === j && (1 === a.mipmapCount && (h.minFilter = 1006),
                    h.format = a.format,
                    h.needsUpdate = !0,
                    b && b(h))
                }, c, d)
            }
            var f = this
              , g = []
              , h = new kd;
            h.image = g;
            var i = new Te(this.manager);
            if (i.setPath(this.path),
            i.setResponseType("arraybuffer"),
            Array.isArray(a))
                for (var j = 0, k = 0, l = a.length; l > k; ++k)
                    e(k);
            else
                i.load(a, function(a) {
                    if (a = f.parse(a, !0),
                    a.isCubemap)
                        for (var c = a.mipmaps.length / a.mipmapCount, d = 0; c > d; d++) {
                            g[d] = {
                                mipmaps: []
                            };
                            for (var e = 0; e < a.mipmapCount; e++)
                                g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]),
                                g[d].format = a.format,
                                g[d].width = a.width,
                                g[d].height = a.height
                        }
                    else
                        h.image.width = a.width,
                        h.image.height = a.height,
                        h.mipmaps = a.mipmaps;
                    1 === a.mipmapCount && (h.minFilter = 1006),
                    h.format = a.format,
                    h.needsUpdate = !0,
                    b && b(h)
                }, c, d);
            return h
        }
    }),
    We.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: We,
        load: function(a, b, c, d) {
            var e = this
              , f = new $
              , g = new Te(this.manager);
            return g.setResponseType("arraybuffer"),
            g.setPath(this.path),
            g.load(a, function(a) {
                (a = e.parse(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width,
                f.image.height = a.height,
                f.image.data = a.data),
                f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001,
                f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001,
                f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006,
                f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1006,
                f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1,
                void 0 !== a.format && (f.format = a.format),
                void 0 !== a.type && (f.type = a.type),
                void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps,
                f.minFilter = 1008),
                1 === a.mipmapCount && (f.minFilter = 1006),
                f.needsUpdate = !0,
                b && b(f, a))
            }, c, d),
            f
        }
    }),
    Xe.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Xe,
        load: function(a, b, c, d) {
            function e() {
                i.removeEventListener("load", e, !1),
                i.removeEventListener("error", f, !1),
                Nj.add(a, this),
                b && b(this),
                g.manager.itemEnd(a)
            }
            function f(b) {
                i.removeEventListener("load", e, !1),
                i.removeEventListener("error", f, !1),
                d && d(b),
                g.manager.itemError(a),
                g.manager.itemEnd(a)
            }
            void 0 !== this.path && (a = this.path + a),
            a = this.manager.resolveURL(a);
            var g = this
              , h = Nj.get(a);
            if (void 0 !== h)
                return g.manager.itemStart(a),
                setTimeout(function() {
                    b && b(h),
                    g.manager.itemEnd(a)
                }, 0),
                h;
            var i = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return i.addEventListener("load", e, !1),
            i.addEventListener("error", f, !1),
            "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (i.crossOrigin = this.crossOrigin),
            g.manager.itemStart(a),
            i.src = a,
            i
        }
    }),
    Ye.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Ye,
        load: function(a, b, c, d) {
            function e(c) {
                g.load(a[c], function(a) {
                    f.images[c] = a,
                    h++,
                    6 === h && (f.needsUpdate = !0,
                    b && b(f))
                }, void 0, d)
            }
            var f = new pb
              , g = new Xe(this.manager);
            g.setCrossOrigin(this.crossOrigin),
            g.setPath(this.path);
            var h = 0;
            for (c = 0; c < a.length; ++c)
                e(c);
            return f
        }
    }),
    Ze.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Ze,
        load: function(a, b, c, d) {
            var e = new g
              , f = new Xe(this.manager);
            return f.setCrossOrigin(this.crossOrigin),
            f.setPath(this.path),
            f.load(a, function(c) {
                e.image = c,
                c = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/),
                e.format = c ? 1022 : 1023,
                e.needsUpdate = !0,
                void 0 !== b && b(e)
            }, c, d),
            e
        }
    }),
    Object.assign($e.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(a, b) {
            return a = this.getUtoTmapping(a),
            this.getPoint(a, b)
        },
        getPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; a >= c; c++)
                b.push(this.getPoint(c / a));
            return b
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; a >= c; c++)
                b.push(this.getPointAt(c / a));
            return b
        },
        getLength: function() {
            var a = this.getLengths();
            return a[a.length - 1]
        },
        getLengths: function(a) {
            if (void 0 === a && (a = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b, c = [], d = this.getPoint(0), e = 0;
            for (c.push(0),
            b = 1; a >= b; b++) {
                var f = this.getPoint(b / a);
                e += f.distanceTo(d),
                c.push(e),
                d = f
            }
            return this.cacheArcLengths = c
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(a, b) {
            var c = this.getLengths()
              , d = c.length;
            b = b ? b : a * c[d - 1];
            for (var e, f = 0, g = d - 1; g >= f; )
                if (a = Math.floor(f + (g - f) / 2),
                e = c[a] - b,
                0 > e)
                    f = a + 1;
                else {
                    if (!(e > 0)) {
                        g = a;
                        break
                    }
                    g = a - 1
                }
            return a = g,
            c[a] === b ? a / (d - 1) : (f = c[a],
            (a + (b - f) / (c[a + 1] - f)) / (d - 1))
        },
        getTangent: function(a) {
            var b = a - 1e-4;
            return a += 1e-4,
            0 > b && (b = 0),
            a > 1 && (a = 1),
            b = this.getPoint(b),
            this.getPoint(a).clone().sub(b).normalize()
        },
        getTangentAt: function(a) {
            return a = this.getUtoTmapping(a),
            this.getTangent(a)
        },
        computeFrenetFrames: function(a, b) {
            var c, d = new e, f = [], g = [], h = [], i = new e, j = new k;
            for (c = 0; a >= c; c++) {
                var l = c / a;
                f[c] = this.getTangentAt(l),
                f[c].normalize()
            }
            g[0] = new e,
            h[0] = new e,
            c = Number.MAX_VALUE,
            l = Math.abs(f[0].x);
            var m = Math.abs(f[0].y)
              , n = Math.abs(f[0].z);
            for (c >= l && (c = l,
            d.set(1, 0, 0)),
            c >= m && (c = m,
            d.set(0, 1, 0)),
            c >= n && d.set(0, 0, 1),
            i.crossVectors(f[0], d).normalize(),
            g[0].crossVectors(f[0], i),
            h[0].crossVectors(f[0], g[0]),
            c = 1; a >= c; c++)
                g[c] = g[c - 1].clone(),
                h[c] = h[c - 1].clone(),
                i.crossVectors(f[c - 1], f[c]),
                i.length() > Number.EPSILON && (i.normalize(),
                d = Math.acos(Sg.clamp(f[c - 1].dot(f[c]), -1, 1)),
                g[c].applyMatrix4(j.makeRotationAxis(i, d))),
                h[c].crossVectors(f[c], g[c]);
            if (!0 === b)
                for (d = Math.acos(Sg.clamp(g[0].dot(g[a]), -1, 1)),
                d /= a,
                0 < f[0].dot(i.crossVectors(g[0], g[a])) && (d = -d),
                c = 1; a >= c; c++)
                    g[c].applyMatrix4(j.makeRotationAxis(f[c], d * c)),
                    h[c].crossVectors(f[c], g[c]);
            return {
                tangents: f,
                normals: g,
                binormals: h
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.arcLengthDivisions = a.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return a.arcLengthDivisions = this.arcLengthDivisions,
            a.type = this.type,
            a
        },
        fromJSON: function(a) {
            return this.arcLengthDivisions = a.arcLengthDivisions,
            this
        }
    }),
    _e.prototype = Object.create($e.prototype),
    _e.prototype.constructor = _e,
    _e.prototype.isEllipseCurve = !0,
    _e.prototype.getPoint = function(a, b) {
        b = b || new c;
        for (var d = 2 * Math.PI, e = this.aEndAngle - this.aStartAngle, f = Math.abs(e) < Number.EPSILON; 0 > e; )
            e += d;
        for (; e > d; )
            e -= d;
        e < Number.EPSILON && (e = f ? 0 : d),
        !0 !== this.aClockwise || f || (e = e === d ? -d : e - d),
        d = this.aStartAngle + a * e,
        a = this.aX + this.xRadius * Math.cos(d);
        var g = this.aY + this.yRadius * Math.sin(d);
        return 0 !== this.aRotation && (d = Math.cos(this.aRotation),
        e = Math.sin(this.aRotation),
        f = a - this.aX,
        g -= this.aY,
        a = f * d - g * e + this.aX,
        g = f * e + g * d + this.aY),
        b.set(a, g)
    }
    ,
    _e.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.aX = a.aX,
        this.aY = a.aY,
        this.xRadius = a.xRadius,
        this.yRadius = a.yRadius,
        this.aStartAngle = a.aStartAngle,
        this.aEndAngle = a.aEndAngle,
        this.aClockwise = a.aClockwise,
        this.aRotation = a.aRotation,
        this
    }
    ,
    _e.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.aX = this.aX,
        a.aY = this.aY,
        a.xRadius = this.xRadius,
        a.yRadius = this.yRadius,
        a.aStartAngle = this.aStartAngle,
        a.aEndAngle = this.aEndAngle,
        a.aClockwise = this.aClockwise,
        a.aRotation = this.aRotation,
        a
    }
    ,
    _e.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.aX = a.aX,
        this.aY = a.aY,
        this.xRadius = a.xRadius,
        this.yRadius = a.yRadius,
        this.aStartAngle = a.aStartAngle,
        this.aEndAngle = a.aEndAngle,
        this.aClockwise = a.aClockwise,
        this.aRotation = a.aRotation,
        this
    }
    ,
    af.prototype = Object.create(_e.prototype),
    af.prototype.constructor = af,
    af.prototype.isArcCurve = !0;
    var Qj = new e
      , Rj = new bf
      , Sj = new bf
      , Tj = new bf;
    cf.prototype = Object.create($e.prototype),
    cf.prototype.constructor = cf,
    cf.prototype.isCatmullRomCurve3 = !0,
    cf.prototype.getPoint = function(a, b) {
        b = b || new e;
        var c = this.points
          , d = c.length;
        a *= d - (this.closed ? 0 : 1);
        var f = Math.floor(a);
        if (a -= f,
        this.closed ? f += f > 0 ? 0 : (Math.floor(Math.abs(f) / d) + 1) * d : 0 === a && f === d - 1 && (f = d - 2,
        a = 1),
        this.closed || f > 0)
            var g = c[(f - 1) % d];
        else
            Qj.subVectors(c[0], c[1]).add(c[0]),
            g = Qj;
        var h = c[f % d]
          , i = c[(f + 1) % d];
        if (this.closed || d > f + 2 ? c = c[(f + 2) % d] : (Qj.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]),
        c = Qj),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var j = "chordal" === this.curveType ? .5 : .25;
            d = Math.pow(g.distanceToSquared(h), j),
            f = Math.pow(h.distanceToSquared(i), j),
            j = Math.pow(i.distanceToSquared(c), j),
            1e-4 > f && (f = 1),
            1e-4 > d && (d = f),
            1e-4 > j && (j = f),
            Rj.initNonuniformCatmullRom(g.x, h.x, i.x, c.x, d, f, j),
            Sj.initNonuniformCatmullRom(g.y, h.y, i.y, c.y, d, f, j),
            Tj.initNonuniformCatmullRom(g.z, h.z, i.z, c.z, d, f, j)
        } else
            "catmullrom" === this.curveType && (Rj.initCatmullRom(g.x, h.x, i.x, c.x, this.tension),
            Sj.initCatmullRom(g.y, h.y, i.y, c.y, this.tension),
            Tj.initCatmullRom(g.z, h.z, i.z, c.z, this.tension));
        return b.set(Rj.calc(a), Sj.calc(a), Tj.calc(a)),
        b
    }
    ,
    cf.prototype.copy = function(a) {
        $e.prototype.copy.call(this, a),
        this.points = [];
        for (var b = 0, c = a.points.length; c > b; b++)
            this.points.push(a.points[b].clone());
        return this.closed = a.closed,
        this.curveType = a.curveType,
        this.tension = a.tension,
        this
    }
    ,
    cf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; c > b; b++)
            a.points.push(this.points[b].toArray());
        return a.closed = this.closed,
        a.curveType = this.curveType,
        a.tension = this.tension,
        a
    }
    ,
    cf.prototype.fromJSON = function(a) {
        $e.prototype.fromJSON.call(this, a),
        this.points = [];
        for (var b = 0, c = a.points.length; c > b; b++) {
            var d = a.points[b];
            this.points.push((new e).fromArray(d))
        }
        return this.closed = a.closed,
        this.curveType = a.curveType,
        this.tension = a.tension,
        this
    }
    ,
    gf.prototype = Object.create($e.prototype),
    gf.prototype.constructor = gf,
    gf.prototype.isCubicBezierCurve = !0,
    gf.prototype.getPoint = function(a, b) {
        b = b || new c;
        var d = this.v0
          , e = this.v1
          , f = this.v2
          , g = this.v3;
        return b.set(ff(a, d.x, e.x, f.x, g.x), ff(a, d.y, e.y, f.y, g.y)),
        b
    }
    ,
    gf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v0.copy(a.v0),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this.v3.copy(a.v3),
        this
    }
    ,
    gf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(),
        a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a.v3 = this.v3.toArray(),
        a
    }
    ,
    gf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v0.fromArray(a.v0),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this.v3.fromArray(a.v3),
        this
    }
    ,
    hf.prototype = Object.create($e.prototype),
    hf.prototype.constructor = hf,
    hf.prototype.isCubicBezierCurve3 = !0,
    hf.prototype.getPoint = function(a, b) {
        b = b || new e;
        var c = this.v0
          , d = this.v1
          , f = this.v2
          , g = this.v3;
        return b.set(ff(a, c.x, d.x, f.x, g.x), ff(a, c.y, d.y, f.y, g.y), ff(a, c.z, d.z, f.z, g.z)),
        b
    }
    ,
    hf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v0.copy(a.v0),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this.v3.copy(a.v3),
        this
    }
    ,
    hf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(),
        a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a.v3 = this.v3.toArray(),
        a
    }
    ,
    hf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v0.fromArray(a.v0),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this.v3.fromArray(a.v3),
        this
    }
    ,
    jf.prototype = Object.create($e.prototype),
    jf.prototype.constructor = jf,
    jf.prototype.isLineCurve = !0,
    jf.prototype.getPoint = function(a, b) {
        return b = b || new c,
        1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1),
        b.multiplyScalar(a).add(this.v1)),
        b
    }
    ,
    jf.prototype.getPointAt = function(a, b) {
        return this.getPoint(a, b)
    }
    ,
    jf.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    jf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this
    }
    ,
    jf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a
    }
    ,
    jf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this
    }
    ,
    kf.prototype = Object.create($e.prototype),
    kf.prototype.constructor = kf,
    kf.prototype.isLineCurve3 = !0,
    kf.prototype.getPoint = function(a, b) {
        return b = b || new e,
        1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1),
        b.multiplyScalar(a).add(this.v1)),
        b
    }
    ,
    kf.prototype.getPointAt = function(a, b) {
        return this.getPoint(a, b)
    }
    ,
    kf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this
    }
    ,
    kf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a
    }
    ,
    kf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this
    }
    ,
    lf.prototype = Object.create($e.prototype),
    lf.prototype.constructor = lf,
    lf.prototype.isQuadraticBezierCurve = !0,
    lf.prototype.getPoint = function(a, b) {
        b = b || new c;
        var d = this.v0
          , e = this.v1
          , f = this.v2;
        return b.set(ef(a, d.x, e.x, f.x), ef(a, d.y, e.y, f.y)),
        b
    }
    ,
    lf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v0.copy(a.v0),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this
    }
    ,
    lf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(),
        a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a
    }
    ,
    lf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v0.fromArray(a.v0),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this
    }
    ,
    mf.prototype = Object.create($e.prototype),
    mf.prototype.constructor = mf,
    mf.prototype.isQuadraticBezierCurve3 = !0,
    mf.prototype.getPoint = function(a, b) {
        b = b || new e;
        var c = this.v0
          , d = this.v1
          , f = this.v2;
        return b.set(ef(a, c.x, d.x, f.x), ef(a, c.y, d.y, f.y), ef(a, c.z, d.z, f.z)),
        b
    }
    ,
    mf.prototype.copy = function(a) {
        return $e.prototype.copy.call(this, a),
        this.v0.copy(a.v0),
        this.v1.copy(a.v1),
        this.v2.copy(a.v2),
        this
    }
    ,
    mf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(),
        a.v1 = this.v1.toArray(),
        a.v2 = this.v2.toArray(),
        a
    }
    ,
    mf.prototype.fromJSON = function(a) {
        return $e.prototype.fromJSON.call(this, a),
        this.v0.fromArray(a.v0),
        this.v1.fromArray(a.v1),
        this.v2.fromArray(a.v2),
        this
    }
    ,
    nf.prototype = Object.create($e.prototype),
    nf.prototype.constructor = nf,
    nf.prototype.isSplineCurve = !0,
    nf.prototype.getPoint = function(a, b) {
        b = b || new c;
        var d = this.points
          , e = (d.length - 1) * a;
        a = Math.floor(e),
        e -= a;
        var f = d[0 === a ? a : a - 1]
          , g = d[a]
          , h = d[a > d.length - 2 ? d.length - 1 : a + 1];
        return d = d[a > d.length - 3 ? d.length - 1 : a + 2],
        b.set(df(e, f.x, g.x, h.x, d.x), df(e, f.y, g.y, h.y, d.y)),
        b
    }
    ,
    nf.prototype.copy = function(a) {
        $e.prototype.copy.call(this, a),
        this.points = [];
        for (var b = 0, c = a.points.length; c > b; b++)
            this.points.push(a.points[b].clone());
        return this
    }
    ,
    nf.prototype.toJSON = function() {
        var a = $e.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; c > b; b++)
            a.points.push(this.points[b].toArray());
        return a
    }
    ,
    nf.prototype.fromJSON = function(a) {
        $e.prototype.fromJSON.call(this, a),
        this.points = [];
        for (var b = 0, d = a.points.length; d > b; b++) {
            var e = a.points[b];
            this.points.push((new c).fromArray(e))
        }
        return this
    }
    ;
    var Uj = Object.freeze({
        __proto__: null,
        ArcCurve: af,
        CatmullRomCurve3: cf,
        CubicBezierCurve: gf,
        CubicBezierCurve3: hf,
        EllipseCurve: _e,
        LineCurve: jf,
        LineCurve3: kf,
        QuadraticBezierCurve: lf,
        QuadraticBezierCurve3: mf,
        SplineCurve: nf
    });
    of.prototype = Object.assign(Object.create($e.prototype), {
        constructor: of,
        add: function(a) {
            this.curves.push(a)
        },
        closePath: function() {
            var a = this.curves[0].getPoint(0)
              , b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new jf(b,a))
        },
        getPoint: function(a) {
            var b = a * this.getLength()
              , c = this.getCurveLengths();
            for (a = 0; a < c.length; ) {
                if (c[a] >= b)
                    return b = c[a] - b,
                    a = this.curves[a],
                    c = a.getLength(),
                    a.getPointAt(0 === c ? 0 : 1 - b / c);
                a++
            }
            return null
        },
        getLength: function() {
            var a = this.getCurveLengths();
            return a[a.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var a = [], b = 0, c = 0, d = this.curves.length; d > c; c++)
                b += this.curves[c].getLength(),
                a.push(b);
            return this.cacheLengths = a
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 40);
            for (var b = [], c = 0; a >= c; c++)
                b.push(this.getPoint(c / a));
            return this.autoClose && b.push(b[0]),
            b
        },
        getPoints: function(a) {
            a = a || 12;
            for (var b, c = [], d = 0, e = this.curves; d < e.length; d++) {
                var f = e[d];
                f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    b && b.equals(h) || (c.push(h),
                    b = h)
                }
            }
            return this.autoClose && 1 < c.length && !c[c.length - 1].equals(c[0]) && c.push(c[0]),
            c
        },
        copy: function(a) {
            $e.prototype.copy.call(this, a),
            this.curves = [];
            for (var b = 0, c = a.curves.length; c > b; b++)
                this.curves.push(a.curves[b].clone());
            return this.autoClose = a.autoClose,
            this
        },
        toJSON: function() {
            var a = $e.prototype.toJSON.call(this);
            a.autoClose = this.autoClose,
            a.curves = [];
            for (var b = 0, c = this.curves.length; c > b; b++)
                a.curves.push(this.curves[b].toJSON());
            return a
        },
        fromJSON: function(a) {
            $e.prototype.fromJSON.call(this, a),
            this.autoClose = a.autoClose,
            this.curves = [];
            for (var b = 0, c = a.curves.length; c > b; b++) {
                var d = a.curves[b];
                this.curves.push((new Uj[d.type]).fromJSON(d))
            }
            return this
        }
    }),
    pf.prototype = Object.assign(Object.create(of.prototype), {
        constructor: pf,
        setFromPoints: function(a) {
            this.moveTo(a[0].x, a[0].y);
            for (var b = 1, c = a.length; c > b; b++)
                this.lineTo(a[b].x, a[b].y);
            return this
        },
        moveTo: function(a, b) {
            return this.currentPoint.set(a, b),
            this
        },
        lineTo: function(a, b) {
            var d = new jf(this.currentPoint.clone(),new c(a,b));
            return this.curves.push(d),
            this.currentPoint.set(a, b),
            this
        },
        quadraticCurveTo: function(a, b, d, e) {
            return a = new lf(this.currentPoint.clone(),new c(a,b),new c(d,e)),
            this.curves.push(a),
            this.currentPoint.set(d, e),
            this
        },
        bezierCurveTo: function(a, b, d, e, f, g) {
            return a = new gf(this.currentPoint.clone(),new c(a,b),new c(d,e),new c(f,g)),
            this.curves.push(a),
            this.currentPoint.set(f, g),
            this
        },
        splineThru: function(a) {
            var b = [this.currentPoint.clone()].concat(a);
            return b = new nf(b),
            this.curves.push(b),
            this.currentPoint.copy(a[a.length - 1]),
            this
        },
        arc: function(a, b, c, d, e, f) {
            return this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f),
            this
        },
        absarc: function(a, b, c, d, e, f) {
            return this.absellipse(a, b, c, c, d, e, f),
            this
        },
        ellipse: function(a, b, c, d, e, f, g, h) {
            return this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h),
            this
        },
        absellipse: function(a, b, c, d, e, f, g, h) {
            return a = new _e(a,b,c,d,e,f,g,h),
            0 < this.curves.length && (b = a.getPoint(0),
            b.equals(this.currentPoint) || this.lineTo(b.x, b.y)),
            this.curves.push(a),
            a = a.getPoint(1),
            this.currentPoint.copy(a),
            this
        },
        copy: function(a) {
            return of.prototype.copy.call(this, a),
            this.currentPoint.copy(a.currentPoint),
            this
        },
        toJSON: function() {
            var a = of.prototype.toJSON.call(this);
            return a.currentPoint = this.currentPoint.toArray(),
            a
        },
        fromJSON: function(a) {
            return of.prototype.fromJSON.call(this, a),
            this.currentPoint.fromArray(a.currentPoint),
            this
        }
    }),
    qf.prototype = Object.assign(Object.create(pf.prototype), {
        constructor: qf,
        getPointsHoles: function(a) {
            for (var b = [], c = 0, d = this.holes.length; d > c; c++)
                b[c] = this.holes[c].getPoints(a);
            return b
        },
        extractPoints: function(a) {
            return {
                shape: this.getPoints(a),
                holes: this.getPointsHoles(a)
            }
        },
        copy: function(a) {
            pf.prototype.copy.call(this, a),
            this.holes = [];
            for (var b = 0, c = a.holes.length; c > b; b++)
                this.holes.push(a.holes[b].clone());
            return this
        },
        toJSON: function() {
            var a = pf.prototype.toJSON.call(this);
            a.uuid = this.uuid,
            a.holes = [];
            for (var b = 0, c = this.holes.length; c > b; b++)
                a.holes.push(this.holes[b].toJSON());
            return a
        },
        fromJSON: function(a) {
            pf.prototype.fromJSON.call(this, a),
            this.uuid = a.uuid,
            this.holes = [];
            for (var b = 0, c = a.holes.length; c > b; b++) {
                var d = a.holes[b];
                this.holes.push((new pf).fromJSON(d))
            }
            return this
        }
    }),
    rf.prototype = Object.assign(Object.create(n.prototype), {
        constructor: rf,
        isLight: !0,
        copy: function(a) {
            return n.prototype.copy.call(this, a),
            this.color.copy(a.color),
            this.intensity = a.intensity,
            this
        },
        toJSON: function(a) {
            return a = n.prototype.toJSON.call(this, a),
            a.object.color = this.color.getHex(),
            a.object.intensity = this.intensity,
            void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (a.object.distance = this.distance),
            void 0 !== this.angle && (a.object.angle = this.angle),
            void 0 !== this.decay && (a.object.decay = this.decay),
            void 0 !== this.penumbra && (a.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()),
            a
        }
    }),
    sf.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: sf,
        isHemisphereLight: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.groundColor.copy(a.groundColor),
            this
        }
    }),
    Object.assign(tf.prototype, {
        _projScreenMatrix: new k,
        _lightPositionWorld: new e,
        _lookTarget: new e,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(a) {
            var b = this.camera
              , c = this.matrix
              , d = this._projScreenMatrix
              , e = this._lookTarget
              , f = this._lightPositionWorld;
            f.setFromMatrixPosition(a.matrixWorld),
            b.position.copy(f),
            e.setFromMatrixPosition(a.target.matrixWorld),
            b.lookAt(e),
            b.updateMatrixWorld(),
            d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
            this._frustum.setFromMatrix(d),
            c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            c.multiply(b.projectionMatrix),
            c.multiply(b.matrixWorldInverse)
        },
        getViewport: function(a) {
            return this._viewports[a]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(a) {
            return this.camera = a.camera.clone(),
            this.bias = a.bias,
            this.radius = a.radius,
            this.mapSize.copy(a.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var a = {};
            return 0 !== this.bias && (a.bias = this.bias),
            1 !== this.radius && (a.radius = this.radius),
            (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (a.mapSize = this.mapSize.toArray()),
            a.camera = this.camera.toJSON(!1).object,
            delete a.camera.matrix,
            a
        }
    }),
    uf.prototype = Object.assign(Object.create(tf.prototype), {
        constructor: uf,
        isSpotLightShadow: !0,
        updateMatrices: function(a) {
            var b = this.camera
              , c = 2 * Sg.RAD2DEG * a.angle
              , d = this.mapSize.width / this.mapSize.height
              , e = a.distance || b.far;
            (c !== b.fov || d !== b.aspect || e !== b.far) && (b.fov = c,
            b.aspect = d,
            b.far = e,
            b.updateProjectionMatrix()),
            tf.prototype.updateMatrices.call(this, a)
        }
    }),
    vf.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: vf,
        isSpotLight: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.distance = a.distance,
            this.angle = a.angle,
            this.penumbra = a.penumbra,
            this.decay = a.decay,
            this.target = a.target.clone(),
            this.shadow = a.shadow.clone(),
            this
        }
    }),
    wf.prototype = Object.assign(Object.create(tf.prototype), {
        constructor: wf,
        isPointLightShadow: !0,
        updateMatrices: function(a, b) {
            void 0 === b && (b = 0);
            var c = this.camera
              , d = this.matrix
              , e = this._lightPositionWorld
              , f = this._lookTarget
              , g = this._projScreenMatrix;
            e.setFromMatrixPosition(a.matrixWorld),
            c.position.copy(e),
            f.copy(c.position),
            f.add(this._cubeDirections[b]),
            c.up.copy(this._cubeUps[b]),
            c.lookAt(f),
            c.updateMatrixWorld(),
            d.makeTranslation(-e.x, -e.y, -e.z),
            g.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse),
            this._frustum.setFromMatrix(g)
        }
    }),
    xf.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: xf,
        isPointLight: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.distance = a.distance,
            this.decay = a.decay,
            this.shadow = a.shadow.clone(),
            this
        }
    }),
    yf.prototype = Object.assign(Object.create(W.prototype), {
        constructor: yf,
        isOrthographicCamera: !0,
        copy: function(a, b) {
            return W.prototype.copy.call(this, a, b),
            this.left = a.left,
            this.right = a.right,
            this.top = a.top,
            this.bottom = a.bottom,
            this.near = a.near,
            this.far = a.far,
            this.zoom = a.zoom,
            this.view = null === a.view ? null : Object.assign({}, a.view),
            this
        },
        setViewOffset: function(a, b, c, d, e, f) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = a,
            this.view.fullHeight = b,
            this.view.offsetX = c,
            this.view.offsetY = d,
            this.view.width = e,
            this.view.height = f,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var a = (this.right - this.left) / (2 * this.zoom)
              , b = (this.top - this.bottom) / (2 * this.zoom)
              , c = (this.right + this.left) / 2
              , d = (this.top + this.bottom) / 2
              , e = c - a;
            if (c += a,
            a = d + b,
            b = d - b,
            null !== this.view && this.view.enabled) {
                c = this.zoom / (this.view.width / this.view.fullWidth),
                b = this.zoom / (this.view.height / this.view.fullHeight);
                var f = (this.right - this.left) / this.view.width;
                d = (this.top - this.bottom) / this.view.height,
                e += this.view.offsetX / c * f,
                c = e + this.view.width / c * f,
                a -= this.view.offsetY / b * d,
                b = a - this.view.height / b * d
            }
            this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(a) {
            return a = n.prototype.toJSON.call(this, a),
            a.object.zoom = this.zoom,
            a.object.left = this.left,
            a.object.right = this.right,
            a.object.top = this.top,
            a.object.bottom = this.bottom,
            a.object.near = this.near,
            a.object.far = this.far,
            null !== this.view && (a.object.view = Object.assign({}, this.view)),
            a
        }
    }),
    zf.prototype = Object.assign(Object.create(tf.prototype), {
        constructor: zf,
        isDirectionalLightShadow: !0,
        updateMatrices: function(a) {
            tf.prototype.updateMatrices.call(this, a)
        }
    }),
    Af.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: Af,
        isDirectionalLight: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.target = a.target.clone(),
            this.shadow = a.shadow.clone(),
            this
        }
    }),
    Bf.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: Bf,
        isAmbientLight: !0
    }),
    Cf.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: Cf,
        isRectAreaLight: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.width = a.width,
            this.height = a.height,
            this
        },
        toJSON: function(a) {
            return a = rf.prototype.toJSON.call(this, a),
            a.object.width = this.width,
            a.object.height = this.height,
            a
        }
    }),
    Df.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Df,
        load: function(a, b, c, d) {
            var e = this
              , f = new Te(e.manager);
            f.setPath(e.path),
            f.load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        parse: function(a) {
            function b(a) {
                return void 0 === d[a] && console.warn("THREE.MaterialLoader: Undefined texture", a),
                d[a]
            }
            var d = this.textures
              , g = new Lj[a.type];
            if (void 0 !== a.uuid && (g.uuid = a.uuid),
            void 0 !== a.name && (g.name = a.name),
            void 0 !== a.color && g.color.setHex(a.color),
            void 0 !== a.roughness && (g.roughness = a.roughness),
            void 0 !== a.metalness && (g.metalness = a.metalness),
            void 0 !== a.sheen && (g.sheen = (new v).setHex(a.sheen)),
            void 0 !== a.emissive && g.emissive.setHex(a.emissive),
            void 0 !== a.specular && g.specular.setHex(a.specular),
            void 0 !== a.shininess && (g.shininess = a.shininess),
            void 0 !== a.clearcoat && (g.clearcoat = a.clearcoat),
            void 0 !== a.clearcoatRoughness && (g.clearcoatRoughness = a.clearcoatRoughness),
            void 0 !== a.vertexColors && (g.vertexColors = a.vertexColors),
            void 0 !== a.fog && (g.fog = a.fog),
            void 0 !== a.flatShading && (g.flatShading = a.flatShading),
            void 0 !== a.blending && (g.blending = a.blending),
            void 0 !== a.combine && (g.combine = a.combine),
            void 0 !== a.side && (g.side = a.side),
            void 0 !== a.opacity && (g.opacity = a.opacity),
            void 0 !== a.transparent && (g.transparent = a.transparent),
            void 0 !== a.alphaTest && (g.alphaTest = a.alphaTest),
            void 0 !== a.depthTest && (g.depthTest = a.depthTest),
            void 0 !== a.depthWrite && (g.depthWrite = a.depthWrite),
            void 0 !== a.colorWrite && (g.colorWrite = a.colorWrite),
            void 0 !== a.stencilWrite && (g.stencilWrite = a.stencilWrite),
            void 0 !== a.stencilWriteMask && (g.stencilWriteMask = a.stencilWriteMask),
            void 0 !== a.stencilFunc && (g.stencilFunc = a.stencilFunc),
            void 0 !== a.stencilRef && (g.stencilRef = a.stencilRef),
            void 0 !== a.stencilFuncMask && (g.stencilFuncMask = a.stencilFuncMask),
            void 0 !== a.stencilFail && (g.stencilFail = a.stencilFail),
            void 0 !== a.stencilZFail && (g.stencilZFail = a.stencilZFail),
            void 0 !== a.stencilZPass && (g.stencilZPass = a.stencilZPass),
            void 0 !== a.wireframe && (g.wireframe = a.wireframe),
            void 0 !== a.wireframeLinewidth && (g.wireframeLinewidth = a.wireframeLinewidth),
            void 0 !== a.wireframeLinecap && (g.wireframeLinecap = a.wireframeLinecap),
            void 0 !== a.wireframeLinejoin && (g.wireframeLinejoin = a.wireframeLinejoin),
            void 0 !== a.rotation && (g.rotation = a.rotation),
            1 !== a.linewidth && (g.linewidth = a.linewidth),
            void 0 !== a.dashSize && (g.dashSize = a.dashSize),
            void 0 !== a.gapSize && (g.gapSize = a.gapSize),
            void 0 !== a.scale && (g.scale = a.scale),
            void 0 !== a.polygonOffset && (g.polygonOffset = a.polygonOffset),
            void 0 !== a.polygonOffsetFactor && (g.polygonOffsetFactor = a.polygonOffsetFactor),
            void 0 !== a.polygonOffsetUnits && (g.polygonOffsetUnits = a.polygonOffsetUnits),
            void 0 !== a.skinning && (g.skinning = a.skinning),
            void 0 !== a.morphTargets && (g.morphTargets = a.morphTargets),
            void 0 !== a.morphNormals && (g.morphNormals = a.morphNormals),
            void 0 !== a.dithering && (g.dithering = a.dithering),
            void 0 !== a.visible && (g.visible = a.visible),
            void 0 !== a.toneMapped && (g.toneMapped = a.toneMapped),
            void 0 !== a.userData && (g.userData = a.userData),
            void 0 !== a.uniforms)
                for (var i in a.uniforms) {
                    var j = a.uniforms[i];
                    switch (g.uniforms[i] = {},
                    j.type) {
                    case "t":
                        g.uniforms[i].value = b(j.value);
                        break;
                    case "c":
                        g.uniforms[i].value = (new v).setHex(j.value);
                        break;
                    case "v2":
                        g.uniforms[i].value = (new c).fromArray(j.value);
                        break;
                    case "v3":
                        g.uniforms[i].value = (new e).fromArray(j.value);
                        break;
                    case "v4":
                        g.uniforms[i].value = (new h).fromArray(j.value);
                        break;
                    case "m3":
                        g.uniforms[i].value = (new f).fromArray(j.value);
                    case "m4":
                        g.uniforms[i].value = (new k).fromArray(j.value);
                        break;
                    default:
                        g.uniforms[i].value = j.value
                    }
                }
            if (void 0 !== a.defines && (g.defines = a.defines),
            void 0 !== a.vertexShader && (g.vertexShader = a.vertexShader),
            void 0 !== a.fragmentShader && (g.fragmentShader = a.fragmentShader),
            void 0 !== a.extensions)
                for (var l in a.extensions)
                    g.extensions[l] = a.extensions[l];
            return void 0 !== a.shading && (g.flatShading = 1 === a.shading),
            void 0 !== a.size && (g.size = a.size),
            void 0 !== a.sizeAttenuation && (g.sizeAttenuation = a.sizeAttenuation),
            void 0 !== a.map && (g.map = b(a.map)),
            void 0 !== a.matcap && (g.matcap = b(a.matcap)),
            void 0 !== a.alphaMap && (g.alphaMap = b(a.alphaMap),
            g.transparent = !0),
            void 0 !== a.bumpMap && (g.bumpMap = b(a.bumpMap)),
            void 0 !== a.bumpScale && (g.bumpScale = a.bumpScale),
            void 0 !== a.normalMap && (g.normalMap = b(a.normalMap)),
            void 0 !== a.normalMapType && (g.normalMapType = a.normalMapType),
            void 0 !== a.normalScale && (i = a.normalScale,
            !1 === Array.isArray(i) && (i = [i, i]),
            g.normalScale = (new c).fromArray(i)),
            void 0 !== a.displacementMap && (g.displacementMap = b(a.displacementMap)),
            void 0 !== a.displacementScale && (g.displacementScale = a.displacementScale),
            void 0 !== a.displacementBias && (g.displacementBias = a.displacementBias),
            void 0 !== a.roughnessMap && (g.roughnessMap = b(a.roughnessMap)),
            void 0 !== a.metalnessMap && (g.metalnessMap = b(a.metalnessMap)),
            void 0 !== a.emissiveMap && (g.emissiveMap = b(a.emissiveMap)),
            void 0 !== a.emissiveIntensity && (g.emissiveIntensity = a.emissiveIntensity),
            void 0 !== a.specularMap && (g.specularMap = b(a.specularMap)),
            void 0 !== a.envMap && (g.envMap = b(a.envMap)),
            void 0 !== a.envMapIntensity && (g.envMapIntensity = a.envMapIntensity),
            void 0 !== a.reflectivity && (g.reflectivity = a.reflectivity),
            void 0 !== a.refractionRatio && (g.refractionRatio = a.refractionRatio),
            void 0 !== a.lightMap && (g.lightMap = b(a.lightMap)),
            void 0 !== a.lightMapIntensity && (g.lightMapIntensity = a.lightMapIntensity),
            void 0 !== a.aoMap && (g.aoMap = b(a.aoMap)),
            void 0 !== a.aoMapIntensity && (g.aoMapIntensity = a.aoMapIntensity),
            void 0 !== a.gradientMap && (g.gradientMap = b(a.gradientMap)),
            void 0 !== a.clearcoatNormalMap && (g.clearcoatNormalMap = b(a.clearcoatNormalMap)),
            void 0 !== a.clearcoatNormalScale && (g.clearcoatNormalScale = (new c).fromArray(a.clearcoatNormalScale)),
            g
        },
        setTextures: function(a) {
            return this.textures = a,
            this
        }
    });
    var Vj = {
        decodeText: function(a) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(a);
            for (var b = "", c = 0, d = a.length; d > c; c++)
                b += String.fromCharCode(a[c]);
            try {
                return decodeURIComponent(escape(b))
            } catch (e) {
                return b
            }
        },
        extractUrlBase: function(a) {
            var b = a.lastIndexOf("/");
            return -1 === b ? "./" : a.substr(0, b + 1)
        }
    };
    Ef.prototype = Object.assign(Object.create(O.prototype), {
        constructor: Ef,
        isInstancedBufferGeometry: !0,
        copy: function(a) {
            return O.prototype.copy.call(this, a),
            this.maxInstancedCount = a.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var a = O.prototype.toJSON.call(this);
            return a.maxInstancedCount = this.maxInstancedCount,
            a.isInstancedBufferGeometry = !0,
            a
        }
    }),
    Ff.prototype = Object.assign(Object.create(C.prototype), {
        constructor: Ff,
        isInstancedBufferAttribute: !0,
        copy: function(a) {
            return C.prototype.copy.call(this, a),
            this.meshPerAttribute = a.meshPerAttribute,
            this
        },
        toJSON: function() {
            var a = C.prototype.toJSON.call(this);
            return a.meshPerAttribute = this.meshPerAttribute,
            a.isInstancedBufferAttribute = !0,
            a
        }
    }),
    Gf.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Gf,
        load: function(a, b, c, d) {
            var e = this
              , f = new Te(e.manager);
            f.setPath(e.path),
            f.load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        parse: function(a) {
            var b = a.isInstancedBufferGeometry ? new Ef : new O
              , c = a.data.index;
            if (void 0 !== c) {
                var d = new Wj[c.type](c.array);
                b.setIndex(new C(d,1))
            }
            c = a.data.attributes;
            for (var f in c) {
                var g = c[f];
                d = new Wj[g.type](g.array),
                d = new (g.isInstancedBufferAttribute ? Ff : C)(d,g.itemSize,g.normalized),
                void 0 !== g.name && (d.name = g.name),
                b.setAttribute(f, d)
            }
            var h = a.data.morphAttributes;
            if (h)
                for (f in h) {
                    var i = h[f]
                      , j = [];
                    c = 0;
                    for (var k = i.length; k > c; c++)
                        g = i[c],
                        d = new Wj[g.type](g.array),
                        d = new C(d,g.itemSize,g.normalized),
                        void 0 !== g.name && (d.name = g.name),
                        j.push(d);
                    b.morphAttributes[f] = j
                }
            if (a.data.morphTargetsRelative && (b.morphTargetsRelative = !0),
            f = a.data.groups || a.data.drawcalls || a.data.offsets,
            void 0 !== f)
                for (c = 0,
                g = f.length; c !== g; ++c)
                    d = f[c],
                    b.addGroup(d.start, d.count, d.materialIndex);
            return c = a.data.boundingSphere,
            void 0 !== c && (f = new e,
            void 0 !== c.center && f.fromArray(c.center),
            b.boundingSphere = new r(f,c.radius)),
            a.name && (b.name = a.name),
            a.userData && (b.userData = a.userData),
            b
        }
    });
    var Wj = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Hf.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Hf,
        load: function(a, b, c, d) {
            var e = this
              , f = "" === this.path ? Vj.extractUrlBase(a) : this.path;
            this.resourcePath = this.resourcePath || f,
            f = new Te(e.manager),
            f.setPath(this.path),
            f.load(a, function(c) {
                var f = null;
                try {
                    f = JSON.parse(c)
                } catch (g) {
                    return void 0 !== d && d(g),
                    console.error("THREE:ObjectLoader: Can't parse " + a + ".", g.message),
                    void 0
                }
                c = f.metadata,
                void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : e.parse(f, b)
            }, c, d)
        },
        parse: function(a, b) {
            var c = this.parseShape(a.shapes);
            c = this.parseGeometries(a.geometries, c);
            var d = this.parseImages(a.images, function() {
                void 0 !== b && b(e)
            });
            d = this.parseTextures(a.textures, d),
            d = this.parseMaterials(a.materials, d);
            var e = this.parseObject(a.object, c, d);
            return a.animations && (e.animations = this.parseAnimations(a.animations)),
            void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e),
            e
        },
        parseShape: function(a) {
            var b = {};
            if (void 0 !== a)
                for (var c = 0, d = a.length; d > c; c++) {
                    var e = (new qf).fromJSON(a[c]);
                    b[e.uuid] = e
                }
            return b
        },
        parseGeometries: function(a, b) {
            var c = {};
            if (void 0 !== a)
                for (var d = new Gf, e = 0, f = a.length; f > e; e++) {
                    var g = a[e];
                    switch (g.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        var h = new Kj[g.type](g.width,g.height,g.widthSegments,g.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        h = new Kj[g.type](g.width,g.height,g.depth,g.widthSegments,g.heightSegments,g.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        h = new Kj[g.type](g.radius,g.segments,g.thetaStart,g.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        h = new Kj[g.type](g.radiusTop,g.radiusBottom,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,g.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        h = new Kj[g.type](g.radius,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,g.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        h = new Kj[g.type](g.radius,g.widthSegments,g.heightSegments,g.phiStart,g.phiLength,g.thetaStart,g.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        h = new Kj[g.type](g.radius,g.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        h = new Kj[g.type](g.innerRadius,g.outerRadius,g.thetaSegments,g.phiSegments,g.thetaStart,g.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        h = new Kj[g.type](g.radius,g.tube,g.radialSegments,g.tubularSegments,g.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        h = new Kj[g.type](g.radius,g.tube,g.tubularSegments,g.radialSegments,g.p,g.q);
                        break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                        h = new Kj[g.type]((new Uj[g.path.type]).fromJSON(g.path),g.tubularSegments,g.radius,g.radialSegments,g.closed);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        h = new Kj[g.type](g.points,g.segments,g.phiStart,g.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        h = new Kj[g.type](g.vertices,g.indices,g.radius,g.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        h = [];
                        for (var i = 0, j = g.shapes.length; j > i; i++) {
                            var k = b[g.shapes[i]];
                            h.push(k)
                        }
                        h = new Kj[g.type](h,g.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (h = [],
                        i = 0,
                        j = g.shapes.length; j > i; i++)
                            k = b[g.shapes[i]],
                            h.push(k);
                        i = g.options.extrudePath,
                        void 0 !== i && (g.options.extrudePath = (new Uj[i.type]).fromJSON(i)),
                        h = new Kj[g.type](h,g.options);
                        break;
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        h = d.parse(g);
                        break;
                    case "Geometry":
                        "THREE"in window && "LegacyJSONLoader"in THREE ? h = (new THREE.LegacyJSONLoader).parse(g, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + g.type + '"');
                        continue
                    }
                    h.uuid = g.uuid,
                    void 0 !== g.name && (h.name = g.name),
                    !0 === h.isBufferGeometry && void 0 !== g.userData && (h.userData = g.userData),
                    c[g.uuid] = h
                }
            return c
        },
        parseMaterials: function(a, b) {
            var c = {}
              , d = {};
            if (void 0 !== a) {
                var e = new Df;
                e.setTextures(b),
                b = 0;
                for (var f = a.length; f > b; b++) {
                    var g = a[b];
                    if ("MultiMaterial" === g.type) {
                        for (var h = [], i = 0; i < g.materials.length; i++) {
                            var j = g.materials[i];
                            void 0 === c[j.uuid] && (c[j.uuid] = e.parse(j)),
                            h.push(c[j.uuid])
                        }
                        d[g.uuid] = h
                    } else
                        void 0 === c[g.uuid] && (c[g.uuid] = e.parse(g)),
                        d[g.uuid] = c[g.uuid]
                }
            }
            return d
        },
        parseAnimations: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = a[c]
                  , e = Oe.parse(d);
                void 0 !== d.uuid && (e.uuid = d.uuid),
                b.push(e)
            }
            return b
        },
        parseImages: function(a, b) {
            function c(a) {
                return d.manager.itemStart(a),
                f.load(a, function() {
                    d.manager.itemEnd(a)
                }, void 0, function() {
                    d.manager.itemError(a),
                    d.manager.itemEnd(a)
                })
            }
            var d = this
              , e = {};
            if (void 0 !== a && 0 < a.length) {
                b = new Re(b);
                var f = new Xe(b);
                f.setCrossOrigin(this.crossOrigin),
                b = 0;
                for (var g = a.length; g > b; b++) {
                    var h = a[b]
                      , i = h.url;
                    if (Array.isArray(i)) {
                        e[h.uuid] = [];
                        for (var j = 0, k = i.length; k > j; j++) {
                            var l = i[j];
                            l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : d.resourcePath + l,
                            e[h.uuid].push(c(l))
                        }
                    } else
                        l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.resourcePath + h.url,
                        e[h.uuid] = c(l)
                }
            }
            return e
        },
        parseTextures: function(a, b) {
            function c(a, b) {
                return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a),
                b[a])
            }
            var d = {};
            if (void 0 !== a)
                for (var e = 0, f = a.length; f > e; e++) {
                    var h = a[e];
                    void 0 === h.image && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid),
                    void 0 === b[h.image] && console.warn("THREE.ObjectLoader: Undefined image", h.image);
                    var i = Array.isArray(b[h.image]) ? new pb(b[h.image]) : new g(b[h.image]);
                    i.needsUpdate = !0,
                    i.uuid = h.uuid,
                    void 0 !== h.name && (i.name = h.name),
                    void 0 !== h.mapping && (i.mapping = c(h.mapping, Xj)),
                    void 0 !== h.offset && i.offset.fromArray(h.offset),
                    void 0 !== h.repeat && i.repeat.fromArray(h.repeat),
                    void 0 !== h.center && i.center.fromArray(h.center),
                    void 0 !== h.rotation && (i.rotation = h.rotation),
                    void 0 !== h.wrap && (i.wrapS = c(h.wrap[0], Yj),
                    i.wrapT = c(h.wrap[1], Yj)),
                    void 0 !== h.format && (i.format = h.format),
                    void 0 !== h.type && (i.type = h.type),
                    void 0 !== h.encoding && (i.encoding = h.encoding),
                    void 0 !== h.minFilter && (i.minFilter = c(h.minFilter, Zj)),
                    void 0 !== h.magFilter && (i.magFilter = c(h.magFilter, Zj)),
                    void 0 !== h.anisotropy && (i.anisotropy = h.anisotropy),
                    void 0 !== h.flipY && (i.flipY = h.flipY),
                    void 0 !== h.premultiplyAlpha && (i.premultiplyAlpha = h.premultiplyAlpha),
                    void 0 !== h.unpackAlignment && (i.unpackAlignment = h.unpackAlignment),
                    d[h.uuid] = i
                }
            return d
        },
        parseObject: function(a, b, c) {
            function d(a) {
                return void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a),
                b[a]
            }
            function e(a) {
                if (void 0 !== a) {
                    if (Array.isArray(a)) {
                        for (var b = [], d = 0, e = a.length; e > d; d++) {
                            var f = a[d];
                            void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f),
                            b.push(c[f])
                        }
                        return b
                    }
                    return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a),
                    c[a]
                }
            }
            switch (a.type) {
            case "Scene":
                var f = new o;
                void 0 !== a.background && Number.isInteger(a.background) && (f.background = new v(a.background)),
                void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new Tc(a.fog.color,a.fog.near,a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new Sc(a.fog.color,a.fog.density)));
                break;
            case "PerspectiveCamera":
                f = new X(a.fov,a.aspect,a.near,a.far),
                void 0 !== a.focus && (f.focus = a.focus),
                void 0 !== a.zoom && (f.zoom = a.zoom),
                void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge),
                void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset),
                void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;
            case "OrthographicCamera":
                f = new yf(a.left,a.right,a.top,a.bottom,a.near,a.far),
                void 0 !== a.zoom && (f.zoom = a.zoom),
                void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;
            case "AmbientLight":
                f = new Bf(a.color,a.intensity);
                break;
            case "DirectionalLight":
                f = new Af(a.color,a.intensity);
                break;
            case "PointLight":
                f = new xf(a.color,a.intensity,a.distance,a.decay);
                break;
            case "RectAreaLight":
                f = new Cf(a.color,a.intensity,a.width,a.height);
                break;
            case "SpotLight":
                f = new vf(a.color,a.intensity,a.distance,a.angle,a.penumbra,a.decay);
                break;
            case "HemisphereLight":
                f = new sf(a.color,a.groundColor,a.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                f = d(a.geometry);
                var g = e(a.material);
                f = f.bones && 0 < f.bones.length ? new $c(f,g) : new P(f,g);
                break;
            case "InstancedMesh":
                f = d(a.geometry),
                g = e(a.material);
                var h = a.instanceMatrix;
                f = new bd(f,g,a.count),
                f.instanceMatrix = new C(new Float32Array(h.array),16);
                break;
            case "LOD":
                f = new Zc;
                break;
            case "Line":
                f = new dd(d(a.geometry),e(a.material),a.mode);
                break;
            case "LineLoop":
                f = new fd(d(a.geometry),e(a.material));
                break;
            case "LineSegments":
                f = new ed(d(a.geometry),e(a.material));
                break;
            case "PointCloud":
            case "Points":
                f = new hd(d(a.geometry),e(a.material));
                break;
            case "Sprite":
                f = new Xc(e(a.material));
                break;
            case "Group":
                f = new Pc;
                break;
            default:
                f = new n
            }
            if (f.uuid = a.uuid,
            void 0 !== a.name && (f.name = a.name),
            void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix),
            void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate),
            f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position),
            void 0 !== a.rotation && f.rotation.fromArray(a.rotation),
            void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion),
            void 0 !== a.scale && f.scale.fromArray(a.scale)),
            void 0 !== a.castShadow && (f.castShadow = a.castShadow),
            void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow),
            a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias),
            void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius),
            void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize),
            void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera))),
            void 0 !== a.visible && (f.visible = a.visible),
            void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled),
            void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder),
            void 0 !== a.userData && (f.userData = a.userData),
            void 0 !== a.layers && (f.layers.mask = a.layers),
            void 0 !== a.children)
                for (h = a.children,
                g = 0; g < h.length; g++)
                    f.add(this.parseObject(h[g], b, c));
            if ("LOD" === a.type)
                for (void 0 !== a.autoUpdate && (f.autoUpdate = a.autoUpdate),
                a = a.levels,
                h = 0; h < a.length; h++) {
                    g = a[h];
                    var i = f.getObjectByProperty("uuid", g.object);
                    void 0 !== i && f.addLevel(i, g.distance)
                }
            return f
        }
    });
    var Xj = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }
      , Yj = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }
      , Zj = {
        NearestFilter: 1003,
        NearestMipmapNearestFilter: 1004,
        NearestMipmapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipmapNearestFilter: 1007,
        LinearMipmapLinearFilter: 1008
    };
    If.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: If,
        setOptions: function(a) {
            return this.options = a,
            this
        },
        load: function(a, b, c, d) {
            void 0 === a && (a = ""),
            void 0 !== this.path && (a = this.path + a),
            a = this.manager.resolveURL(a);
            var e = this
              , f = Nj.get(a);
            return void 0 !== f ? (e.manager.itemStart(a),
            setTimeout(function() {
                b && b(f),
                e.manager.itemEnd(a)
            }, 0),
            f) : (fetch(a).then(function(a) {
                return a.blob()
            }).then(function(a) {
                return void 0 === e.options ? createImageBitmap(a) : createImageBitmap(a, e.options)
            }).then(function(c) {
                Nj.add(a, c),
                b && b(c),
                e.manager.itemEnd(a)
            }).catch(function(b) {
                d && d(b),
                e.manager.itemError(a),
                e.manager.itemEnd(a)
            }),
            e.manager.itemStart(a),
            void 0)
        }
    }),
    Object.assign(Jf.prototype, {
        moveTo: function(a, b) {
            return this.currentPath = new pf,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(a, b),
            this
        },
        lineTo: function(a, b) {
            return this.currentPath.lineTo(a, b),
            this
        },
        quadraticCurveTo: function(a, b, c, d) {
            return this.currentPath.quadraticCurveTo(a, b, c, d),
            this
        },
        bezierCurveTo: function(a, b, c, d, e, f) {
            return this.currentPath.bezierCurveTo(a, b, c, d, e, f),
            this
        },
        splineThru: function(a) {
            return this.currentPath.splineThru(a),
            this
        },
        toShapes: function(a, b) {
            function c(a) {
                for (var b = [], c = 0, d = a.length; d > c; c++) {
                    var e = a[c]
                      , f = new qf;
                    f.curves = e.curves,
                    b.push(f)
                }
                return b
            }
            function d(a, b) {
                for (var c = b.length, d = !1, e = c - 1, f = 0; c > f; e = f++) {
                    var g = b[e]
                      , h = b[f]
                      , i = h.x - g.x
                      , j = h.y - g.y;
                    if (Math.abs(j) > Number.EPSILON) {
                        if (0 > j && (g = b[f],
                        i = -i,
                        h = b[e],
                        j = -j),
                        !(a.y < g.y || a.y > h.y))
                            if (a.y === g.y) {
                                if (a.x === g.x)
                                    return !0
                            } else {
                                if (e = j * (a.x - g.x) - i * (a.y - g.y),
                                0 === e)
                                    return !0;
                                0 > e || (d = !d)
                            }
                    } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x))
                        return !0
                }
                return d
            }
            var e = Ij.isClockWise
              , f = this.subPaths;
            if (0 === f.length)
                return [];
            if (!0 === b)
                return c(f);
            if (b = [],
            1 === f.length) {
                var g = f[0]
                  , h = new qf;
                return h.curves = g.curves,
                b.push(h),
                b
            }
            var i = !e(f[0].getPoints());
            i = a ? !i : i,
            h = [];
            var j = []
              , k = []
              , l = 0;
            j[l] = void 0,
            k[l] = [];
            for (var m = 0, n = f.length; n > m; m++) {
                g = f[m];
                var o = g.getPoints()
                  , p = e(o);
                (p = a ? !p : p) ? (!i && j[l] && l++,
                j[l] = {
                    s: new qf,
                    p: o
                },
                j[l].s.curves = g.curves,
                i && l++,
                k[l] = []) : k[l].push({
                    h: g,
                    p: o[0]
                })
            }
            if (!j[0])
                return c(f);
            if (1 < j.length) {
                for (m = !1,
                a = [],
                e = 0,
                f = j.length; f > e; e++)
                    h[e] = [];
                for (e = 0,
                f = j.length; f > e; e++)
                    for (g = k[e],
                    p = 0; p < g.length; p++) {
                        for (i = g[p],
                        l = !0,
                        o = 0; o < j.length; o++)
                            d(i.p, j[o].p) && (e !== o && a.push({
                                froms: e,
                                tos: o,
                                hole: p
                            }),
                            l ? (l = !1,
                            h[o].push(i)) : m = !0);
                        l && h[e].push(i)
                    }
                0 < a.length && (m || (k = h))
            }
            for (m = 0,
            e = j.length; e > m; m++)
                for (h = j[m].s,
                b.push(h),
                a = k[m],
                f = 0,
                g = a.length; g > f; f++)
                    h.holes.push(a[f].h);
            return b
        }
    }),
    Object.assign(Kf.prototype, {
        isFont: !0,
        generateShapes: function(a, b) {
            void 0 === b && (b = 100);
            var c = []
              , d = b;
            b = this.data;
            var e = Array.from ? Array.from(a) : String(a).split("");
            d /= b.resolution;
            var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
            a = [];
            for (var g = 0, h = 0, i = 0; i < e.length; i++) {
                var j = e[i];
                if ("\n" === j)
                    g = 0,
                    h -= f;
                else {
                    var k = j;
                    j = d;
                    var l = g
                      , m = h
                      , n = b
                      , o = n.glyphs[k] || n.glyphs["?"];
                    if (o) {
                        if (k = new Jf,
                        o.o) {
                            n = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
                            for (var p = 0, q = n.length; q > p; )
                                switch (n[p++]) {
                                case "m":
                                    var r = n[p++] * j + l
                                      , s = n[p++] * j + m;
                                    k.moveTo(r, s);
                                    break;
                                case "l":
                                    r = n[p++] * j + l,
                                    s = n[p++] * j + m,
                                    k.lineTo(r, s);
                                    break;
                                case "q":
                                    var t = n[p++] * j + l
                                      , u = n[p++] * j + m
                                      , v = n[p++] * j + l
                                      , w = n[p++] * j + m;
                                    k.quadraticCurveTo(v, w, t, u);
                                    break;
                                case "b":
                                    t = n[p++] * j + l,
                                    u = n[p++] * j + m,
                                    v = n[p++] * j + l,
                                    w = n[p++] * j + m,
                                    r = n[p++] * j + l,
                                    s = n[p++] * j + m,
                                    k.bezierCurveTo(v, w, r, s, t, u)
                                }
                        }
                        j = {
                            offsetX: o.ha * j,
                            path: k
                        }
                    } else
                        console.error('THREE.Font: character "' + k + '" does not exists in font family ' + n.familyName + "."),
                        j = void 0;
                    g += j.offsetX,
                    a.push(j.path)
                }
            }
            for (b = 0,
            e = a.length; e > b; b++)
                Array.prototype.push.apply(c, a[b].toShapes());
            return c
        }
    }),
    Lf.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Lf,
        load: function(a, b, c, d) {
            var e = this
              , f = new Te(this.manager);
            f.setPath(this.path),
            f.load(a, function(a) {
                try {
                    var c = JSON.parse(a)
                } catch (d) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    c = JSON.parse(a.substring(65, a.length - 2))
                }
                a = e.parse(c),
                b && b(a)
            }, c, d)
        },
        parse: function(a) {
            return new Kf(a)
        }
    });
    var $j, _j = {
        getContext: function() {
            return void 0 === $j && ($j = new (window.AudioContext || window.webkitAudioContext)),
            $j
        },
        setContext: function(a) {
            $j = a
        }
    };
    Mf.prototype = Object.assign(Object.create(Se.prototype), {
        constructor: Mf,
        load: function(a, b, c, d) {
            var e = new Te(this.manager);
            e.setResponseType("arraybuffer"),
            e.setPath(this.path),
            e.load(a, function(a) {
                a = a.slice(0),
                _j.getContext().decodeAudioData(a, function(a) {
                    b(a)
                })
            }, c, d)
        }
    }),
    Object.assign(Nf.prototype, {
        isSphericalHarmonics3: !0,
        set: function(a) {
            for (var b = 0; 9 > b; b++)
                this.coefficients[b].copy(a[b]);
            return this
        },
        zero: function() {
            for (var a = 0; 9 > a; a++)
                this.coefficients[a].set(0, 0, 0);
            return this
        },
        getAt: function(a, b) {
            var c = a.x
              , d = a.y;
            a = a.z;
            var e = this.coefficients;
            return b.copy(e[0]).multiplyScalar(.282095),
            b.addScale(e[1], .488603 * d),
            b.addScale(e[2], .488603 * a),
            b.addScale(e[3], .488603 * c),
            b.addScale(e[4], 1.092548 * c * d),
            b.addScale(e[5], 1.092548 * d * a),
            b.addScale(e[6], .315392 * (3 * a * a - 1)),
            b.addScale(e[7], 1.092548 * c * a),
            b.addScale(e[8], .546274 * (c * c - d * d)),
            b
        },
        getIrradianceAt: function(a, b) {
            var c = a.x
              , d = a.y;
            a = a.z;
            var e = this.coefficients;
            return b.copy(e[0]).multiplyScalar(.886227),
            b.addScale(e[1], 1.023328 * d),
            b.addScale(e[2], 1.023328 * a),
            b.addScale(e[3], 1.023328 * c),
            b.addScale(e[4], .858086 * c * d),
            b.addScale(e[5], .858086 * d * a),
            b.addScale(e[6], .743125 * a * a - .247708),
            b.addScale(e[7], .858086 * c * a),
            b.addScale(e[8], .429043 * (c * c - d * d)),
            b
        },
        add: function(a) {
            for (var b = 0; 9 > b; b++)
                this.coefficients[b].add(a.coefficients[b]);
            return this
        },
        scale: function(a) {
            for (var b = 0; 9 > b; b++)
                this.coefficients[b].multiplyScalar(a);
            return this
        },
        lerp: function(a, b) {
            for (var c = 0; 9 > c; c++)
                this.coefficients[c].lerp(a.coefficients[c], b);
            return this
        },
        equals: function(a) {
            for (var b = 0; 9 > b; b++)
                if (!this.coefficients[b].equals(a.coefficients[b]))
                    return !1;
            return !0
        },
        copy: function(a) {
            return this.set(a.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = this.coefficients, d = 0; 9 > d; d++)
                c[d].fromArray(a, b + 3 * d);
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []),
            void 0 === b && (b = 0);
            for (var c = this.coefficients, d = 0; 9 > d; d++)
                c[d].toArray(a, b + 3 * d);
            return a
        }
    }),
    Object.assign(Nf, {
        getBasisAt: function(a, b) {
            var c = a.x
              , d = a.y;
            a = a.z,
            b[0] = .282095,
            b[1] = .488603 * d,
            b[2] = .488603 * a,
            b[3] = .488603 * c,
            b[4] = 1.092548 * c * d,
            b[5] = 1.092548 * d * a,
            b[6] = .315392 * (3 * a * a - 1),
            b[7] = 1.092548 * c * a,
            b[8] = .546274 * (c * c - d * d)
        }
    }),
    Of.prototype = Object.assign(Object.create(rf.prototype), {
        constructor: Of,
        isLightProbe: !0,
        copy: function(a) {
            return rf.prototype.copy.call(this, a),
            this.sh.copy(a.sh),
            this.intensity = a.intensity,
            this
        },
        toJSON: function(a) {
            return rf.prototype.toJSON.call(this, a)
        }
    }),
    Pf.prototype = Object.assign(Object.create(Of.prototype), {
        constructor: Pf,
        isHemisphereLightProbe: !0,
        copy: function(a) {
            return Of.prototype.copy.call(this, a),
            this
        },
        toJSON: function(a) {
            return Of.prototype.toJSON.call(this, a)
        }
    }),
    Qf.prototype = Object.assign(Object.create(Of.prototype), {
        constructor: Qf,
        isAmbientLightProbe: !0,
        copy: function(a) {
            return Of.prototype.copy.call(this, a),
            this
        },
        toJSON: function(a) {
            return Of.prototype.toJSON.call(this, a)
        }
    });
    var ak = new k
      , bk = new k;
    Object.assign(Rf.prototype, {
        update: function(a) {
            var b = this._cache;
            if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b.far !== a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
                b.focus = a.focus,
                b.fov = a.fov,
                b.aspect = a.aspect * this.aspect,
                b.near = a.near,
                b.far = a.far,
                b.zoom = a.zoom,
                b.eyeSep = this.eyeSep;
                var c = a.projectionMatrix.clone()
                  , d = b.eyeSep / 2
                  , e = d * b.near / b.focus
                  , f = b.near * Math.tan(Sg.DEG2RAD * b.fov * .5) / b.zoom;
                bk.elements[12] = -d,
                ak.elements[12] = d,
                d = -f * b.aspect + e;
                var g = f * b.aspect + e;
                c.elements[0] = 2 * b.near / (g - d),
                c.elements[8] = (g + d) / (g - d),
                this.cameraL.projectionMatrix.copy(c),
                d = -f * b.aspect - e,
                g = f * b.aspect - e,
                c.elements[0] = 2 * b.near / (g - d),
                c.elements[8] = (g + d) / (g - d),
                this.cameraR.projectionMatrix.copy(c)
            }
            this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(bk),
            this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(ak)
        }
    }),
    Object.assign(Sf.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var a = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var b = ("undefined" == typeof performance ? Date : performance).now();
                a = (b - this.oldTime) / 1e3,
                this.oldTime = b,
                this.elapsedTime += a
            }
            return a
        }
    });
    var ck = new e
      , dk = new d
      , ek = new e
      , fk = new e;
    Tf.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Tf,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(a) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = a,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(a) {
            return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function(a) {
            n.prototype.updateMatrixWorld.call(this, a),
            a = this.context.listener;
            var b = this.up;
            if (this.timeDelta = this._clock.getDelta(),
            this.matrixWorld.decompose(ck, dk, ek),
            fk.set(0, 0, -1).applyQuaternion(dk),
            a.positionX) {
                var c = this.context.currentTime + this.timeDelta;
                a.positionX.linearRampToValueAtTime(ck.x, c),
                a.positionY.linearRampToValueAtTime(ck.y, c),
                a.positionZ.linearRampToValueAtTime(ck.z, c),
                a.forwardX.linearRampToValueAtTime(fk.x, c),
                a.forwardY.linearRampToValueAtTime(fk.y, c),
                a.forwardZ.linearRampToValueAtTime(fk.z, c),
                a.upX.linearRampToValueAtTime(b.x, c),
                a.upY.linearRampToValueAtTime(b.y, c),
                a.upZ.linearRampToValueAtTime(b.z, c)
            } else
                a.setPosition(ck.x, ck.y, ck.z),
                a.setOrientation(fk.x, fk.y, fk.z, b.x, b.y, b.z)
        }
    }),
    Uf.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Uf,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(a) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = a,
            this.connect(),
            this
        },
        setMediaElementSource: function(a) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(a),
            this.connect(),
            this
        },
        setMediaStreamSource: function(a) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(a),
            this.connect(),
            this
        },
        setBuffer: function(a) {
            return this.buffer = a,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function(a) {
            if (void 0 === a && (a = 0),
            !0 === this.isPlaying)
                console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl)
                    return this._startedAt = this.context.currentTime + a,
                    a = this.context.createBufferSource(),
                    a.buffer = this.buffer,
                    a.loop = this.loop,
                    a.loopStart = this.loopStart,
                    a.loopEnd = this.loopEnd,
                    a.onended = this.onEnded.bind(this),
                    a.start(this._startedAt, this._pausedAt + this.offset, this.duration),
                    this.isPlaying = !0,
                    this.source = a,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect();
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function() {
            return !1 !== this.hasPlaybackControl ? (!0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate,
            this.source.stop(),
            this.source.onended = null,
            this.isPlaying = !1),
            this) : (console.warn("THREE.Audio: this Audio has no playback control."),
            void 0)
        },
        stop: function() {
            return !1 !== this.hasPlaybackControl ? (this._pausedAt = 0,
            this.source.stop(),
            this.source.onended = null,
            this.isPlaying = !1,
            this) : (console.warn("THREE.Audio: this Audio has no playback control."),
            void 0)
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var a = 1, b = this.filters.length; b > a; a++)
                    this.filters[a - 1].connect(this.filters[a]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var a = 1, b = this.filters.length; b > a; a++)
                    this.filters[a - 1].disconnect(this.filters[a]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(a) {
            return a || (a = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = a,
            this.connect()) : this.filters = a,
            this
        },
        setDetune: function(a) {
            return this.detune = a,
            void 0 !== this.source.detune ? (!0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this) : void 0
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(a) {
            return this.setFilters(a ? [a] : [])
        },
        setPlaybackRate: function(a) {
            return !1 !== this.hasPlaybackControl ? (this.playbackRate = a,
            !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
            this) : (console.warn("THREE.Audio: this Audio has no playback control."),
            void 0)
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(a) {
            return !1 !== this.hasPlaybackControl ? (this.loop = a,
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this) : (console.warn("THREE.Audio: this Audio has no playback control."),
            void 0)
        },
        setLoopStart: function(a) {
            return this.loopStart = a,
            this
        },
        setLoopEnd: function(a) {
            return this.loopEnd = a,
            this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(a) {
            return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01),
            this
        }
    });
    var gk = new e
      , hk = new d
      , ik = new e
      , jk = new e;
    Vf.prototype = Object.assign(Object.create(Uf.prototype), {
        constructor: Vf,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(a) {
            return this.panner.refDistance = a,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(a) {
            return this.panner.rolloffFactor = a,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(a) {
            return this.panner.distanceModel = a,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(a) {
            return this.panner.maxDistance = a,
            this
        },
        setDirectionalCone: function(a, b, c) {
            return this.panner.coneInnerAngle = a,
            this.panner.coneOuterAngle = b,
            this.panner.coneOuterGain = c,
            this
        },
        updateMatrixWorld: function(a) {
            if (n.prototype.updateMatrixWorld.call(this, a),
            !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                if (this.matrixWorld.decompose(gk, hk, ik),
                jk.set(0, 0, 1).applyQuaternion(hk),
                a = this.panner,
                a.positionX) {
                    var b = this.context.currentTime + this.listener.timeDelta;
                    a.positionX.linearRampToValueAtTime(gk.x, b),
                    a.positionY.linearRampToValueAtTime(gk.y, b),
                    a.positionZ.linearRampToValueAtTime(gk.z, b),
                    a.orientationX.linearRampToValueAtTime(jk.x, b),
                    a.orientationY.linearRampToValueAtTime(jk.y, b),
                    a.orientationZ.linearRampToValueAtTime(jk.z, b)
                } else
                    a.setPosition(gk.x, gk.y, gk.z),
                    a.setOrientation(jk.x, jk.y, jk.z)
        }
    }),
    Object.assign(Wf.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)
                a += b[c];
            return a / b.length
        }
    }),
    Object.assign(Xf.prototype, {
        accumulate: function(a, b) {
            var c = this.buffer
              , d = this.valueSize;
            a = a * d + d;
            var e = this.cumulativeWeight;
            if (0 === e) {
                for (e = 0; e !== d; ++e)
                    c[a + e] = c[e];
                e = b
            } else
                e += b,
                this._mixBufferRegion(c, a, 0, b / e, d);
            this.cumulativeWeight = e
        },
        apply: function(a) {
            var b = this.valueSize
              , c = this.buffer;
            a = a * b + b;
            var d = this.cumulativeWeight
              , e = this.binding;
            this.cumulativeWeight = 0,
            1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b),
            d = b;
            for (var f = b + b; d !== f; ++d)
                if (c[d] !== c[d + b]) {
                    e.setValue(c, a);
                    break
                }
        },
        saveOriginalState: function() {
            var a = this.buffer
              , b = this.valueSize
              , c = 3 * b;
            this.binding.getValue(a, c);
            for (var d = b; d !== c; ++d)
                a[d] = a[c + d % b];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(a, b, c, d, e) {
            if (d >= .5)
                for (d = 0; d !== e; ++d)
                    a[b + d] = a[c + d]
        },
        _slerp: function(a, b, c, e) {
            d.slerpFlat(a, b, a, b, a, c, e)
        },
        _lerp: function(a, b, c, d, e) {
            for (var f = 1 - d, g = 0; g !== e; ++g) {
                var h = b + g;
                a[h] = a[h] * f + a[c + g] * d
            }
        }
    });
    var kk = /[\[\]\.:\/]/g
      , lk = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
      , mk = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , nk = /(WCOD+)?/.source.replace("WCOD", lk)
      , ok = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , pk = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , qk = new RegExp("^" + mk + nk + ok + pk + "$")
      , rk = ["material", "materials", "bones"];
    Object.assign(Yf.prototype, {
        getValue: function(a, b) {
            this.bind();
            var c = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== c && c.getValue(a, b)
        },
        setValue: function(a, b) {
            for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d)
                c[d].setValue(a, b)
        },
        bind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)
                a[b].bind()
        },
        unbind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)
                a[b].unbind()
        }
    }),
    Object.assign(Zf, {
        Composite: Yf,
        create: function(a, b, c) {
            return a && a.isAnimationObjectGroup ? new Zf.Composite(a,b,c) : new Zf(a,b,c)
        },
        sanitizeNodeName: function(a) {
            return a.replace(/\s/g, "_").replace(kk, "")
        },
        parseTrackName: function(a) {
            var b = qk.exec(a);
            if (!b)
                throw Error("PropertyBinding: Cannot parse trackName: " + a);
            b = {
                nodeName: b[2],
                objectName: b[3],
                objectIndex: b[4],
                propertyName: b[5],
                propertyIndex: b[6]
            };
            var c = b.nodeName && b.nodeName.lastIndexOf(".");
            if (void 0 !== c && -1 !== c) {
                var d = b.nodeName.substring(c + 1);
                -1 !== rk.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c),
                b.objectName = d)
            }
            if (null === b.propertyName || 0 === b.propertyName.length)
                throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
            return b
        },
        findNode: function(a, b) {
            if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid)
                return a;
            if (a.skeleton) {
                var c = a.skeleton.getBoneByName(b);
                if (void 0 !== c)
                    return c
            }
            if (a.children) {
                var d = function(a) {
                    for (var c = 0; c < a.length; c++) {
                        var e = a[c];
                        if (e.name === b || e.uuid === b || (e = d(e.children)))
                            return e
                    }
                    return null
                };
                if (a = d(a.children))
                    return a
            }
            return null
        }
    }),
    Object.assign(Zf.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(a, b) {
            a[b] = this.node[this.propertyName]
        }
        , function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
                a[b++] = c[d]
        }
        , function(a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex]
        }
        , function(a, b) {
            this.resolvedProperty.toArray(a, b)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(a, b) {
            this.targetObject[this.propertyName] = a[b]
        }
        , function(a, b) {
            this.targetObject[this.propertyName] = a[b],
            this.targetObject.needsUpdate = !0
        }
        , function(a, b) {
            this.targetObject[this.propertyName] = a[b],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
                c[d] = a[b++]
        }
        , function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
                c[d] = a[b++];
            this.targetObject.needsUpdate = !0
        }
        , function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
                c[d] = a[b++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b]
        }
        , function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b],
            this.targetObject.needsUpdate = !0
        }
        , function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(a, b) {
            this.resolvedProperty.fromArray(a, b)
        }
        , function(a, b) {
            this.resolvedProperty.fromArray(a, b),
            this.targetObject.needsUpdate = !0
        }
        , function(a, b) {
            this.resolvedProperty.fromArray(a, b),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(a, b) {
            this.bind(),
            this.getValue(a, b)
        },
        setValue: function(a, b) {
            this.bind(),
            this.setValue(a, b)
        },
        bind: function() {
            var a = this.node
              , b = this.parsedPath
              , c = b.objectName
              , d = b.propertyName
              , e = b.propertyIndex;
            if (a || (this.node = a = Zf.findNode(this.rootNode, b.nodeName) || this.rootNode),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            a) {
                if (c) {
                    var f = b.objectIndex;
                    switch (c) {
                    case "materials":
                        if (!a.material)
                            return console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this),
                            void 0;
                        if (!a.material.materials)
                            return console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this),
                            void 0;
                        a = a.material.materials;
                        break;
                    case "bones":
                        if (!a.skeleton)
                            return console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this),
                            void 0;
                        for (a = a.skeleton.bones,
                        c = 0; c < a.length; c++)
                            if (a[c].name === f) {
                                f = c;
                                break
                            }
                        break;
                    default:
                        if (void 0 === a[c])
                            return console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this),
                            void 0;
                        a = a[c]
                    }
                    if (void 0 !== f) {
                        if (void 0 === a[f])
                            return console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a),
                            void 0;
                        a = a[f]
                    }
                }
                if (f = a[d],
                void 0 === f)
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
                else {
                    if (b = this.Versioning.None,
                    this.targetObject = a,
                    void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate),
                    c = this.BindingType.Direct,
                    void 0 !== e) {
                        if ("morphTargetInfluences" === d) {
                            if (!a.geometry)
                                return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this),
                                void 0;
                            if (a.geometry.isBufferGeometry) {
                                if (!a.geometry.morphAttributes)
                                    return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this),
                                    void 0;
                                for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
                                    if (a.geometry.morphAttributes.position[c].name === e) {
                                        e = c;
                                        break
                                    }
                            } else {
                                if (!a.geometry.morphTargets)
                                    return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this),
                                    void 0;
                                for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                                    if (a.geometry.morphTargets[c].name === e) {
                                        e = c;
                                        break
                                    }
                            }
                        }
                        c = this.BindingType.ArrayElement,
                        this.resolvedProperty = f,
                        this.propertyIndex = e
                    } else
                        void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray,
                        this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray,
                        this.resolvedProperty = f) : this.propertyName = d;
                    this.getValue = this.GetterByBindingType[c],
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(Zf.prototype, {
        _getValue_unbound: Zf.prototype.getValue,
        _setValue_unbound: Zf.prototype.setValue
    }),
    Object.assign($f.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, i = void 0, j = 0, k = arguments.length; j !== k; ++j) {
                var l = arguments[j]
                  , m = l.uuid
                  , n = d[m];
                if (void 0 === n) {
                    n = b++,
                    d[m] = n,
                    a.push(l),
                    m = 0;
                    for (var o = h; m !== o; ++m)
                        g[m].push(new Zf(l,e[m],f[m]))
                } else if (c > n) {
                    i = a[n];
                    var p = --c;
                    for (o = a[p],
                    d[o.uuid] = n,
                    a[n] = o,
                    d[m] = p,
                    a[p] = l,
                    m = 0,
                    o = h; m !== o; ++m) {
                        var q = g[m]
                          , r = q[n];
                        q[n] = q[p],
                        void 0 === r && (r = new Zf(l,e[m],f[m])),
                        q[p] = r
                    }
                } else
                    a[n] !== i && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = c
        },
        remove: function() {
            for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
                var h = arguments[f]
                  , i = h.uuid
                  , j = c[i];
                if (void 0 !== j && j >= b) {
                    var k = b++
                      , l = a[k];
                    for (c[l.uuid] = j,
                    a[j] = l,
                    c[i] = k,
                    a[k] = h,
                    h = 0,
                    i = e; h !== i; ++h) {
                        l = d[h];
                        var m = l[j];
                        l[j] = l[k],
                        l[k] = m
                    }
                }
            }
            this.nCachedObjects_ = b
        },
        uncache: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                var i = arguments[g].uuid
                  , j = d[i];
                if (void 0 !== j)
                    if (delete d[i],
                    c > j) {
                        i = --c;
                        var k = a[i]
                          , l = --b
                          , m = a[l];
                        for (d[k.uuid] = j,
                        a[j] = k,
                        d[m.uuid] = i,
                        a[i] = m,
                        a.pop(),
                        k = 0,
                        m = f; k !== m; ++k) {
                            var n = e[k]
                              , o = n[l];
                            n[j] = n[i],
                            n[i] = o,
                            n.pop()
                        }
                    } else
                        for (l = --b,
                        m = a[l],
                        d[m.uuid] = j,
                        a[j] = m,
                        a.pop(),
                        k = 0,
                        m = f; k !== m; ++k)
                            n = e[k],
                            n[j] = n[l],
                            n.pop()
            }
            this.nCachedObjects_ = c
        },
        subscribe_: function(a, b) {
            var c = this._bindingsIndicesByPath
              , d = c[a]
              , e = this._bindings;
            if (void 0 !== d)
                return e[d];
            var f = this._paths
              , g = this._parsedPaths
              , h = this._objects
              , i = this.nCachedObjects_
              , j = Array(h.length);
            for (d = e.length,
            c[a] = d,
            f.push(a),
            g.push(b),
            e.push(j),
            c = i,
            d = h.length; c !== d; ++c)
                j[c] = new Zf(h[c],a,b);
            return j
        },
        unsubscribe_: function(a) {
            var b = this._bindingsIndicesByPath
              , c = b[a];
            if (void 0 !== c) {
                var d = this._paths
                  , e = this._parsedPaths
                  , f = this._bindings
                  , g = f.length - 1
                  , h = f[g];
                b[a[g]] = c,
                f[c] = h,
                f.pop(),
                e[c] = e[g],
                e.pop(),
                d[c] = d[g],
                d.pop()
            }
        }
    }),
    Object.assign(_f.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(a) {
            return this._startTime = a,
            this
        },
        setLoop: function(a, b) {
            return this.loop = a,
            this.repetitions = b,
            this
        },
        setEffectiveWeight: function(a) {
            return this.weight = a,
            this._effectiveWeight = this.enabled ? a : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(a) {
            return this._scheduleFading(a, 0, 1)
        },
        fadeOut: function(a) {
            return this._scheduleFading(a, 1, 0)
        },
        crossFadeFrom: function(a, b, c) {
            if (a.fadeOut(b),
            this.fadeIn(b),
            c) {
                c = this._clip.duration;
                var d = a._clip.duration
                  , e = c / d;
                a.warp(1, d / c, b),
                this.warp(e, 1, b)
            }
            return this
        },
        crossFadeTo: function(a, b, c) {
            return a.crossFadeFrom(this, b, c)
        },
        stopFading: function() {
            var a = this._weightInterpolant;
            return null !== a && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(a)),
            this
        },
        setEffectiveTimeScale: function(a) {
            return this.timeScale = a,
            this._effectiveTimeScale = this.paused ? 0 : a,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(a) {
            return this.timeScale = this._clip.duration / a,
            this.stopWarping()
        },
        syncWith: function(a) {
            return this.time = a.time,
            this.timeScale = a.timeScale,
            this.stopWarping()
        },
        halt: function(a) {
            return this.warp(this._effectiveTimeScale, 0, a)
        },
        warp: function(a, b, c) {
            var d = this._mixer
              , e = d.time
              , f = this._timeScaleInterpolant
              , g = this.timeScale;
            return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()),
            d = f.parameterPositions,
            f = f.sampleValues,
            d[0] = e,
            d[1] = e + c,
            f[0] = a / g,
            f[1] = b / g,
            this
        },
        stopWarping: function() {
            var a = this._timeScaleInterpolant;
            return null !== a && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(a)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(a, b, c, d) {
            if (this.enabled) {
                var e = this._startTime;
                if (null !== e) {
                    if (b = (a - e) * c,
                    0 > b || 0 === c)
                        return;
                    this._startTime = null,
                    b *= c
                }
                if (b *= this._updateTimeScale(a),
                c = this._updateTime(b),
                a = this._updateWeight(a),
                a > 0) {
                    b = this._interpolants,
                    e = this._propertyBindings;
                    for (var f = 0, g = b.length; f !== g; ++f)
                        b[f].evaluate(c),
                        e[f].accumulate(d, a)
                }
            } else
                this._updateWeight(a)
        },
        _updateWeight: function(a) {
            var b = 0;
            if (this.enabled) {
                b = this.weight;
                var c = this._weightInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d,
                    a > c.parameterPositions[1] && (this.stopFading(),
                    0 === d && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = b
        },
        _updateTimeScale: function(a) {
            var b = 0;
            if (!this.paused) {
                b = this.timeScale;
                var c = this._timeScaleInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d,
                    a > c.parameterPositions[1] && (this.stopWarping(),
                    0 === b ? this.paused = !0 : this.timeScale = b)
                }
            }
            return this._effectiveTimeScale = b
        },
        _updateTime: function(a) {
            var b = this.time + a
              , c = this._clip.duration
              , d = this.loop
              , e = this._loopCount
              , f = 2202 === d;
            if (0 === a)
                return -1 === e ? b : f && 1 === (1 & e) ? c - b : b;
            if (2200 === d)
                a: {
                    if (-1 === e && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1)),
                    b >= c)
                        b = c;
                    else {
                        if (!(0 > b)) {
                            this.time = b;
                            break a
                        }
                        b = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = b,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > a ? -1 : 1
                    })
                }
            else {
                if (-1 === e && (a >= 0 ? (e = 0,
                this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f)),
                b >= c || 0 > b) {
                    d = Math.floor(b / c),
                    b -= c * d,
                    e += Math.abs(d);
                    var g = this.repetitions - e;
                    0 >= g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = b = a > 0 ? c : 0,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: a > 0 ? 1 : -1
                    })) : (1 === g ? (a = 0 > a,
                    this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f),
                    this._loopCount = e,
                    this.time = b,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: d
                    }))
                } else
                    this.time = b;
                if (f && 1 === (1 & e))
                    return c - b
            }
            return b
        },
        _setEndings: function(a, b, c) {
            var d = this._interpolantSettings;
            c ? (d.endingStart = 2401,
            d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
            d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(a, b, c) {
            var d = this._mixer
              , e = d.time
              , f = this._weightInterpolant;
            return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()),
            d = f.parameterPositions,
            f = f.sampleValues,
            d[0] = e,
            f[0] = b,
            d[1] = e + a,
            f[1] = c,
            this
        }
    }),
    ag.prototype = Object.assign(Object.create(b.prototype), {
        constructor: ag,
        _bindAction: function(a, b) {
            var c = a._localRoot || this._root
              , d = a._clip.tracks
              , e = d.length
              , f = a._propertyBindings;
            a = a._interpolants;
            var g = c.uuid
              , h = this._bindingsByRootAndName
              , i = h[g];
            for (void 0 === i && (i = {},
            h[g] = i),
            h = 0; h !== e; ++h) {
                var j = d[h]
                  , k = j.name
                  , l = i[k];
                if (void 0 === l) {
                    if (l = f[h],
                    void 0 !== l) {
                        null === l._cacheIndex && (++l.referenceCount,
                        this._addInactiveBinding(l, g, k));
                        continue
                    }
                    l = new Xf(Zf.create(c, k, b && b._propertyBindings[h].binding.parsedPath),j.ValueTypeName,j.getValueSize()),
                    ++l.referenceCount,
                    this._addInactiveBinding(l, g, k)
                }
                f[h] = l,
                a[h].resultBuffer = l.buffer
            }
        },
        _activateAction: function(a) {
            if (!this._isActiveAction(a)) {
                if (null === a._cacheIndex) {
                    var b = (a._localRoot || this._root).uuid
                      , c = a._clip.uuid
                      , d = this._actionsByClip[c];
                    this._bindAction(a, d && d.knownActions[0]),
                    this._addInactiveAction(a, c, b)
                }
                for (b = a._propertyBindings,
                c = 0,
                d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === e.useCount++ && (this._lendBinding(e),
                    e.saveOriginalState())
                }
                this._lendAction(a)
            }
        },
        _deactivateAction: function(a) {
            if (this._isActiveAction(a)) {
                for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === --e.useCount && (e.restoreOriginalState(),
                    this._takeBackBinding(e))
                }
                this._takeBackAction(a)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
                actions: {
                    get total() {
                        return a._actions.length
                    },
                    get inUse() {
                        return a._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return a._bindings.length
                    },
                    get inUse() {
                        return a._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return a._controlInterpolants.length
                    },
                    get inUse() {
                        return a._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(a) {
            return a = a._cacheIndex,
            null !== a && a < this._nActiveActions
        },
        _addInactiveAction: function(a, b, c) {
            var d = this._actions
              , e = this._actionsByClip
              , f = e[b];
            void 0 === f ? (f = {
                knownActions: [a],
                actionByRoot: {}
            },
            a._byClipCacheIndex = 0,
            e[b] = f) : (b = f.knownActions,
            a._byClipCacheIndex = b.length,
            b.push(a)),
            a._cacheIndex = d.length,
            d.push(a),
            f.actionByRoot[c] = a
        },
        _removeInactiveAction: function(a) {
            var b = this._actions
              , c = b[b.length - 1]
              , d = a._cacheIndex;
            c._cacheIndex = d,
            b[d] = c,
            b.pop(),
            a._cacheIndex = null,
            b = a._clip.uuid,
            c = this._actionsByClip,
            d = c[b];
            var e = d.knownActions
              , f = e[e.length - 1]
              , g = a._byClipCacheIndex;
            f._byClipCacheIndex = g,
            e[g] = f,
            e.pop(),
            a._byClipCacheIndex = null,
            delete d.actionByRoot[(a._localRoot || this._root).uuid],
            0 === e.length && delete c[b],
            this._removeInactiveBindingsForAction(a)
        },
        _removeInactiveBindingsForAction: function(a) {
            a = a._propertyBindings;
            for (var b = 0, c = a.length; b !== c; ++b) {
                var d = a[b];
                0 === --d.referenceCount && this._removeInactiveBinding(d)
            }
        },
        _lendAction: function(a) {
            var b = this._actions
              , c = a._cacheIndex
              , d = this._nActiveActions++
              , e = b[d];
            a._cacheIndex = d,
            b[d] = a,
            e._cacheIndex = c,
            b[c] = e
        },
        _takeBackAction: function(a) {
            var b = this._actions
              , c = a._cacheIndex
              , d = --this._nActiveActions
              , e = b[d];
            a._cacheIndex = d,
            b[d] = a,
            e._cacheIndex = c,
            b[c] = e
        },
        _addInactiveBinding: function(a, b, c) {
            var d = this._bindingsByRootAndName
              , e = d[b]
              , f = this._bindings;
            void 0 === e && (e = {},
            d[b] = e),
            e[c] = a,
            a._cacheIndex = f.length,
            f.push(a)
        },
        _removeInactiveBinding: function(a) {
            var b = this._bindings
              , c = a.binding
              , d = c.rootNode.uuid;
            c = c.path;
            var e = this._bindingsByRootAndName
              , f = e[d]
              , g = b[b.length - 1];
            a = a._cacheIndex,
            g._cacheIndex = a,
            b[a] = g,
            b.pop(),
            delete f[c],
            0 === Object.keys(f).length && delete e[d]
        },
        _lendBinding: function(a) {
            var b = this._bindings
              , c = a._cacheIndex
              , d = this._nActiveBindings++
              , e = b[d];
            a._cacheIndex = d,
            b[d] = a,
            e._cacheIndex = c,
            b[c] = e
        },
        _takeBackBinding: function(a) {
            var b = this._bindings
              , c = a._cacheIndex
              , d = --this._nActiveBindings
              , e = b[d];
            a._cacheIndex = d,
            b[d] = a,
            e._cacheIndex = c,
            b[c] = e
        },
        _lendControlInterpolant: function() {
            var a = this._controlInterpolants
              , b = this._nActiveControlInterpolants++
              , c = a[b];
            return void 0 === c && (c = new Ee(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
            c.__cacheIndex = b,
            a[b] = c),
            c
        },
        _takeBackControlInterpolant: function(a) {
            var b = this._controlInterpolants
              , c = a.__cacheIndex
              , d = --this._nActiveControlInterpolants
              , e = b[d];
            a.__cacheIndex = d,
            b[d] = a,
            e.__cacheIndex = c,
            b[c] = e
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(a, b) {
            var c = b || this._root
              , d = c.uuid;
            c = "string" == typeof a ? Oe.findByName(c, a) : a,
            a = null !== c ? c.uuid : a;
            var e = this._actionsByClip[a]
              , f = null;
            if (void 0 !== e) {
                if (f = e.actionByRoot[d],
                void 0 !== f)
                    return f;
                f = e.knownActions[0],
                null === c && (c = f._clip)
            }
            return null === c ? null : (b = new _f(this,c,b),
            this._bindAction(b, f),
            this._addInactiveAction(b, a, d),
            b)
        },
        existingAction: function(a, b) {
            var c = b || this._root;
            return b = c.uuid,
            c = "string" == typeof a ? Oe.findByName(c, a) : a,
            a = this._actionsByClip[c ? c.uuid : a],
            void 0 !== a ? a.actionByRoot[b] || null : null
        },
        stopAllAction: function() {
            for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e)
                a[e].reset();
            for (e = 0; e !== d; ++e)
                c[e].useCount = 0;
            return this
        },
        update: function(a) {
            a *= this.timeScale;
            for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g)
                b[g]._update(d, a, e, f);
            for (a = this._bindings,
            b = this._nActiveBindings,
            g = 0; g !== b; ++g)
                a[g].apply(f);
            return this
        },
        setTime: function(a) {
            for (var b = this.time = 0; b < this._actions.length; b++)
                this._actions[b].time = 0;
            return this.update(a)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(a) {
            var b = this._actions;
            a = a.uuid;
            var c = this._actionsByClip
              , d = c[a];
            if (void 0 !== d) {
                d = d.knownActions;
                for (var e = 0, f = d.length; e !== f; ++e) {
                    var g = d[e];
                    this._deactivateAction(g);
                    var h = g._cacheIndex
                      , i = b[b.length - 1];
                    g._cacheIndex = null,
                    g._byClipCacheIndex = null,
                    i._cacheIndex = h,
                    b[h] = i,
                    b.pop(),
                    this._removeInactiveBindingsForAction(g)
                }
                delete c[a]
            }
        },
        uncacheRoot: function(a) {
            a = a.uuid;
            var b = this._actionsByClip;
            for (d in b) {
                var c = b[d].actionByRoot[a];
                void 0 !== c && (this._deactivateAction(c),
                this._removeInactiveAction(c))
            }
            var d = this._bindingsByRootAndName[a];
            if (void 0 !== d)
                for (var e in d)
                    a = d[e],
                    a.restoreOriginalState(),
                    this._removeInactiveBinding(a)
        },
        uncacheAction: function(a, b) {
            a = this.existingAction(a, b),
            null !== a && (this._deactivateAction(a),
            this._removeInactiveAction(a))
        }
    }),
    bg.prototype.clone = function() {
        return new bg(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    cg.prototype = Object.assign(Object.create(Uc.prototype), {
        constructor: cg,
        isInstancedInterleavedBuffer: !0,
        copy: function(a) {
            return Uc.prototype.copy.call(this, a),
            this.meshPerAttribute = a.meshPerAttribute,
            this
        }
    }),
    Object.assign(dg.prototype, {
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b)
        },
        setFromCamera: function(a, b) {
            b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld),
            this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize(),
            this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b),
            this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld),
            this.camera = b) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(a, b, c) {
            return c = c || [],
            fg(a, this, c, b),
            c.sort(eg),
            c
        },
        intersectObjects: function(a, b, c) {
            if (c = c || [],
            !1 === Array.isArray(a))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                c;
            for (var d = 0, e = a.length; e > d; d++)
                fg(a[d], this, c, b);
            return c.sort(eg),
            c
        }
    }),
    Object.assign(gg.prototype, {
        set: function(a, b, c) {
            return this.radius = a,
            this.phi = b,
            this.theta = c,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.radius = a.radius,
            this.phi = a.phi,
            this.theta = a.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z)
        },
        setFromCartesianCoords: function(a, b, c) {
            return this.radius = Math.sqrt(a * a + b * b + c * c),
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c),
            this.phi = Math.acos(Sg.clamp(b / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(hg.prototype, {
        set: function(a, b, c) {
            return this.radius = a,
            this.theta = b,
            this.y = c,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.radius = a.radius,
            this.theta = a.theta,
            this.y = a.y,
            this
        },
        setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z)
        },
        setFromCartesianCoords: function(a, b, c) {
            return this.radius = Math.sqrt(a * a + c * c),
            this.theta = Math.atan2(a, c),
            this.y = b,
            this
        }
    });
    var sk = new c;
    Object.assign(ig.prototype, {
        set: function(a, b) {
            return this.min.copy(a),
            this.max.copy(b),
            this
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; c > b; b++)
                this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function(a, b) {
            return b = sk.copy(b).multiplyScalar(.5),
            this.min.copy(a).sub(b),
            this.max.copy(a).add(b),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.min.copy(a.min),
            this.max.copy(a.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"),
            a = new c),
            this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(a) {
            return void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"),
            a = new c),
            this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a),
            this.max.max(a),
            this
        },
        expandByVector: function(a) {
            return this.min.sub(a),
            this.max.add(a),
            this
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a),
            this.max.addScalar(a),
            this
        },
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
        },
        getParameter: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"),
            b = new c),
            b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            b = new c),
            b.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function(a) {
            return sk.copy(a).clamp(this.min, this.max).sub(a).length()
        },
        intersect: function(a) {
            return this.min.max(a.min),
            this.max.min(a.max),
            this
        },
        union: function(a) {
            return this.min.min(a.min),
            this.max.max(a.max),
            this
        },
        translate: function(a) {
            return this.min.add(a),
            this.max.add(a),
            this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    });
    var tk = new e
      , uk = new e;
    Object.assign(jg.prototype, {
        set: function(a, b) {
            return this.start.copy(a),
            this.end.copy(b),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.start.copy(a.start),
            this.end.copy(a.end),
            this
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"),
            a = new e),
            a.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(a) {
            return void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"),
            a = new e),
            a.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(a, b) {
            return void 0 === b && (console.warn("THREE.Line3: .at() target is now required"),
            b = new e),
            this.delta(b).multiplyScalar(a).add(this.start)
        },
        closestPointToPointParameter: function(a, b) {
            return tk.subVectors(a, this.start),
            uk.subVectors(this.end, this.start),
            a = uk.dot(uk),
            a = uk.dot(tk) / a,
            b && (a = Sg.clamp(a, 0, 1)),
            a
        },
        closestPointToPoint: function(a, b, c) {
            return a = this.closestPointToPointParameter(a, b),
            void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            c = new e),
            this.delta(c).multiplyScalar(a).add(this.start)
        },
        applyMatrix4: function(a) {
            return this.start.applyMatrix4(a),
            this.end.applyMatrix4(a),
            this
        },
        equals: function(a) {
            return a.start.equals(this.start) && a.end.equals(this.end)
        }
    }),
    kg.prototype = Object.create(n.prototype),
    kg.prototype.constructor = kg,
    kg.prototype.isImmediateRenderObject = !0;
    var vk = new e;
    lg.prototype = Object.create(n.prototype),
    lg.prototype.constructor = lg,
    lg.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    lg.prototype.update = function() {
        this.light.updateMatrixWorld();
        var a = this.light.distance ? this.light.distance : 1e3
          , b = a * Math.tan(this.light.angle);
        this.cone.scale.set(b, b, a),
        vk.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(vk),
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
    ;
    var wk = new e
      , xk = new k
      , yk = new k;
    ng.prototype = Object.create(ed.prototype),
    ng.prototype.constructor = ng,
    ng.prototype.updateMatrixWorld = function(a) {
        var b = this.bones
          , c = this.geometry
          , d = c.getAttribute("position");
        yk.getInverse(this.root.matrixWorld);
        for (var e = 0, f = 0; e < b.length; e++) {
            var g = b[e];
            g.parent && g.parent.isBone && (xk.multiplyMatrices(yk, g.matrixWorld),
            wk.setFromMatrixPosition(xk),
            d.setXYZ(f, wk.x, wk.y, wk.z),
            xk.multiplyMatrices(yk, g.parent.matrixWorld),
            wk.setFromMatrixPosition(xk),
            d.setXYZ(f + 1, wk.x, wk.y, wk.z),
            f += 2)
        }
        c.getAttribute("position").needsUpdate = !0,
        n.prototype.updateMatrixWorld.call(this, a)
    }
    ,
    og.prototype = Object.create(P.prototype),
    og.prototype.constructor = og,
    og.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    og.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ;
    var zk = new e
      , Ak = new v
      , Bk = new v;
    pg.prototype = Object.create(n.prototype),
    pg.prototype.constructor = pg,
    pg.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    pg.prototype.update = function() {
        var a = this.children[0];
        if (void 0 !== this.color)
            this.material.color.set(this.color);
        else {
            var b = a.geometry.getAttribute("color");
            Ak.copy(this.light.color),
            Bk.copy(this.light.groundColor);
            for (var c = 0, d = b.count; d > c; c++) {
                var e = d / 2 > c ? Ak : Bk;
                b.setXYZ(c, e.r, e.g, e.b)
            }
            b.needsUpdate = !0
        }
        a.lookAt(zk.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
    ,
    qg.prototype = Object.assign(Object.create(ed.prototype), {
        constructor: qg,
        copy: function(a) {
            return ed.prototype.copy.call(this, a),
            this.geometry.copy(a.geometry),
            this.material.copy(a.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    rg.prototype = Object.create(ed.prototype),
    rg.prototype.constructor = rg;
    var Ck = new e
      , Dk = new e
      , Ek = new e;
    sg.prototype = Object.create(n.prototype),
    sg.prototype.constructor = sg,
    sg.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    sg.prototype.update = function() {
        Ck.setFromMatrixPosition(this.light.matrixWorld),
        Dk.setFromMatrixPosition(this.light.target.matrixWorld),
        Ek.subVectors(Dk, Ck),
        this.lightPlane.lookAt(Dk),
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Dk),
        this.targetLine.scale.z = Ek.length()
    }
    ;
    var Fk = new e
      , Gk = new W;
    tg.prototype = Object.create(ed.prototype),
    tg.prototype.constructor = tg,
    tg.prototype.update = function() {
        var a = this.geometry
          , b = this.pointMap;
        Gk.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        ug("c", b, a, Gk, 0, 0, -1),
        ug("t", b, a, Gk, 0, 0, 1),
        ug("n1", b, a, Gk, -1, -1, -1),
        ug("n2", b, a, Gk, 1, -1, -1),
        ug("n3", b, a, Gk, -1, 1, -1),
        ug("n4", b, a, Gk, 1, 1, -1),
        ug("f1", b, a, Gk, -1, -1, 1),
        ug("f2", b, a, Gk, 1, -1, 1),
        ug("f3", b, a, Gk, -1, 1, 1),
        ug("f4", b, a, Gk, 1, 1, 1),
        ug("u1", b, a, Gk, .7, 1.1, -1),
        ug("u2", b, a, Gk, -.7, 1.1, -1),
        ug("u3", b, a, Gk, 0, 2, -1),
        ug("cf1", b, a, Gk, -1, 0, 1),
        ug("cf2", b, a, Gk, 1, 0, 1),
        ug("cf3", b, a, Gk, 0, -1, 1),
        ug("cf4", b, a, Gk, 0, 1, 1),
        ug("cn1", b, a, Gk, -1, 0, -1),
        ug("cn2", b, a, Gk, 1, 0, -1),
        ug("cn3", b, a, Gk, 0, -1, -1),
        ug("cn4", b, a, Gk, 0, 1, -1),
        a.getAttribute("position").needsUpdate = !0
    }
    ;
    var Hk = new p;
    vg.prototype = Object.create(ed.prototype),
    vg.prototype.constructor = vg,
    vg.prototype.update = function(a) {
        if (void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        void 0 !== this.object && Hk.setFromObject(this.object),
        !Hk.isEmpty()) {
            a = Hk.min;
            var b = Hk.max
              , c = this.geometry.attributes.position
              , d = c.array;
            d[0] = b.x,
            d[1] = b.y,
            d[2] = b.z,
            d[3] = a.x,
            d[4] = b.y,
            d[5] = b.z,
            d[6] = a.x,
            d[7] = a.y,
            d[8] = b.z,
            d[9] = b.x,
            d[10] = a.y,
            d[11] = b.z,
            d[12] = b.x,
            d[13] = b.y,
            d[14] = a.z,
            d[15] = a.x,
            d[16] = b.y,
            d[17] = a.z,
            d[18] = a.x,
            d[19] = a.y,
            d[20] = a.z,
            d[21] = b.x,
            d[22] = a.y,
            d[23] = a.z,
            c.needsUpdate = !0,
            this.geometry.computeBoundingSphere()
        }
    }
    ,
    vg.prototype.setFromObject = function(a) {
        return this.object = a,
        this.update(),
        this
    }
    ,
    vg.prototype.copy = function(a) {
        return ed.prototype.copy.call(this, a),
        this.object = a.object,
        this
    }
    ,
    vg.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    wg.prototype = Object.create(ed.prototype),
    wg.prototype.constructor = wg,
    wg.prototype.updateMatrixWorld = function(a) {
        var b = this.box;
        b.isEmpty() || (b.getCenter(this.position),
        b.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        n.prototype.updateMatrixWorld.call(this, a))
    }
    ,
    xg.prototype = Object.create(dd.prototype),
    xg.prototype.constructor = xg,
    xg.prototype.updateMatrixWorld = function(a) {
        var b = -this.plane.constant;
        1e-8 > Math.abs(b) && (b = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, b),
        this.children[0].material.side = 0 > b ? 1 : 0,
        this.lookAt(this.plane.normal),
        n.prototype.updateMatrixWorld.call(this, a)
    }
    ;
    var Ik, Jk, Kk = new e;
    yg.prototype = Object.create(n.prototype),
    yg.prototype.constructor = yg,
    yg.prototype.setDirection = function(a) {
        .99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (Kk.set(a.z, 0, -a.x).normalize(),
        this.quaternion.setFromAxisAngle(Kk, Math.acos(a.y)))
    }
    ,
    yg.prototype.setLength = function(a, b, c) {
        void 0 === b && (b = .2 * a),
        void 0 === c && (c = .2 * b),
        this.line.scale.set(1, Math.max(1e-4, a - b), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(c, b, c),
        this.cone.position.y = a,
        this.cone.updateMatrix()
    }
    ,
    yg.prototype.setColor = function(a) {
        this.line.material.color.set(a),
        this.cone.material.color.set(a)
    }
    ,
    yg.prototype.copy = function(a) {
        return n.prototype.copy.call(this, a, !1),
        this.line.copy(a.line),
        this.cone.copy(a.cone),
        this
    }
    ,
    yg.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    zg.prototype = Object.create(ed.prototype),
    zg.prototype.constructor = zg;
    var Lk = Math.pow(2, 8)
      , Mk = [.125, .215, .35, .446, .526, .582]
      , Nk = 5 + Mk.length
      , Ok = {
        3e3: 0,
        3001: 1,
        3002: 2,
        3004: 3,
        3005: 4,
        3006: 5,
        3007: 6
    }
      , Pk = new yf
      , Qk = function(a) {
        var b = new Float32Array(a)
          , c = new e(0,1,0);
        return a = new te({
            defines: {
                n: a
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: b
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: c
                },
                inputEncoding: {
                    value: Ok[3e3]
                },
                outputEncoding: {
                    value: Ok[3e3]
                }
            },
            vertexShader: Lg(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n" + Mg() + "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	for (int i = 0; i < n; i++) {\n		if (i >= samples)\n			break;\n		for (int dir = -1; dir < 2; dir += 2) {\n			if (i == 0 && dir == 1)\n				continue;\n			vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n			if (all(equal(axis, vec3(0.0))))\n				axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n			axis = normalize(axis);\n			float theta = dTheta * float(dir * i);\n			float cosTheta = cos(theta);\n			// Rodrigues' axis-angle rotation\n			vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross(axis, vOutputDirection) * sin(theta)\n					+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n			gl_FragColor.rgb +=\n					weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n		}\n	}\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        }),
        a.type = "SphericalGaussianBlur",
        a
    }(20)
      , Rk = null
      , Sk = null
      , Tk = function() {
        for (var a = [], b = [], c = [], d = 8, e = 0; Nk > e; e++) {
            var f = Math.pow(2, d);
            b.push(f);
            var g = 1 / f;
            e > 4 ? g = Mk[e - 8 + 4 - 1] : 0 == e && (g = 0),
            c.push(g),
            g = 1 / (f - 1),
            f = -g / 2,
            g = 1 + g / 2;
            var h = [f, f, g, f, g, g, f, f, g, g, f, g];
            f = new Float32Array(108),
            g = new Float32Array(72);
            for (var i = new Float32Array(36), j = 0; 6 > j; j++) {
                var k = j % 3 * 2 / 3 - 1
                  , l = j > 2 ? 0 : -1;
                f.set([k, l, 0, k + 2 / 3, l, 0, k + 2 / 3, l + 1, 0, k, l, 0, k + 2 / 3, l + 1, 0, k, l + 1, 0], 18 * j),
                g.set(h, 12 * j),
                i.set([j, j, j, j, j, j], 6 * j)
            }
            h = new O,
            h.setAttribute("position", new C(f,3)),
            h.setAttribute("uv", new C(g,2)),
            h.setAttribute("faceIndex", new C(i,1)),
            a.push(h),
            d > 4 && d--
        }
        return {
            _lodPlanes: a,
            _sizeLods: b,
            _sigmas: c
        }
    }()
      , Uk = Tk._lodPlanes
      , Vk = Tk._sizeLods
      , Wk = Tk._sigmas
      , Xk = null
      , Yk = null
      , Zk = (1 + Math.sqrt(5)) / 2
      , $k = 1 / Zk
      , _k = [new e(1,1,1), new e(-1,1,1), new e(1,1,-1), new e(-1,1,-1), new e(0,Zk,$k), new e(0,Zk,-$k), new e($k,0,Zk), new e(-$k,0,Zk), new e(Zk,$k,0), new e(-Zk,$k,0)];
    Ag.prototype = {
        constructor: Ag,
        fromScene: function(a, b, c, d) {
            void 0 === b && (b = 0),
            void 0 === c && (c = .1),
            void 0 === d && (d = 100);
            var e = Bg();
            c = new X(90,1,c,d),
            d = [1, 1, 1, 1, -1, 1];
            var f = [1, 1, -1, -1, -1, 1]
              , g = Yk.outputEncoding
              , h = Yk.toneMapping
              , i = Yk.toneMappingExposure
              , j = Yk.getClearColor()
              , k = Yk.getClearAlpha();
            Yk.toneMapping = 1,
            Yk.toneMappingExposure = 1,
            Yk.outputEncoding = 3e3,
            a.scale.z *= -1;
            var l = a.background;
            if (l && l.isColor) {
                l.convertSRGBToLinear();
                var m = Math.min(Math.max(Math.ceil(Math.log2(Math.max(l.r, l.g, l.b))), -128), 127);
                l = l.multiplyScalar(Math.pow(2, -m)),
                Yk.setClearColor(l, (m + 128) / 255),
                a.background = null
            }
            for (Yk.setRenderTarget(e),
            l = 0; 6 > l; l++)
                m = l % 3,
                0 == m ? (c.up.set(0, d[l], 0),
                c.lookAt(f[l], 0, 0)) : 1 == m ? (c.up.set(0, 0, d[l]),
                c.lookAt(0, f[l], 0)) : (c.up.set(0, d[l], 0),
                c.lookAt(0, 0, f[l])),
                Fg(m * Lk, l > 2 ? Lk : 0, Lk, Lk),
                Yk.render(a, c);
            return Yk.toneMapping = h,
            Yk.toneMappingExposure = i,
            Yk.outputEncoding = g,
            Yk.setClearColor(j, k),
            a.scale.z *= -1,
            b > 0 && Hg(e, 0, 0, b),
            Gg(e),
            Cg(),
            e.scissorTest = !1,
            e
        },
        fromEquirectangular: function(a) {
            return a.magFilter = 1003,
            a.minFilter = 1003,
            a.generateMipmaps = !1,
            this.fromCubemap(a)
        },
        fromCubemap: function(a) {
            var b = Bg(a)
              , c = new o;
            a.isCubeTexture ? null == Sk && (Sk = Kg()) : null == Rk && (Rk = Jg());
            var d = a.isCubeTexture ? Sk : Rk;
            return c.add(new P(Uk[0],d)),
            d = d.uniforms,
            d.envMap.value = a,
            a.isCubeTexture || d.texelSize.value.set(1 / a.image.width, 1 / a.image.height),
            d.inputEncoding.value = Ok[a.encoding],
            d.outputEncoding.value = Ok[a.encoding],
            Yk.setRenderTarget(b),
            Fg(0, 0, 3 * Lk, 2 * Lk),
            Yk.render(c, Pk),
            Gg(b),
            Cg(),
            b.scissorTest = !1,
            b
        },
        compileCubemapShader: function() {
            null == Sk && (Sk = Kg(),
            Dg(Sk))
        },
        compileEquirectangularShader: function() {
            null == Rk && (Rk = Jg(),
            Dg(Rk))
        },
        dispose: function() {
            Qk.dispose(),
            null != Sk && Sk.dispose(),
            null != Rk && Rk.dispose();
            for (var a = 0; a < Uk.length; a++)
                Uk[a].dispose()
        }
    },
    $e.create = function(a, b) {
        return console.log("THREE.Curve.create() has been deprecated"),
        a.prototype = Object.create($e.prototype),
        a.prototype.constructor = a,
        a.prototype.getPoint = b,
        a
    }
    ,
    Object.assign(of.prototype, {
        createPointsGeometry: function(a) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            a = this.getPoints(a),
            this.createGeometry(a)
        },
        createSpacedPointsGeometry: function(a) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            a = this.getSpacedPoints(a),
            this.createGeometry(a)
        },
        createGeometry: function(a) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var b = new S, c = 0, d = a.length; d > c; c++) {
                var f = a[c];
                b.vertices.push(new e(f.x,f.y,f.z || 0))
            }
            return b
        }
    }),
    Object.assign(pf.prototype, {
        fromPoints: function(a) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(a)
        }
    }),
    Ng.prototype = Object.create(cf.prototype),
    Og.prototype = Object.create(cf.prototype),
    Pg.prototype = Object.create(cf.prototype),
    Object.assign(Pg.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    qg.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    ng.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(Se.prototype, {
        extractUrlBase: function(a) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Vj.extractUrlBase(a)
        }
    }),
    Se.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    Object.assign(Hf.prototype, {
        setTexturePath: function(a) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
            this.setResourcePath(a)
        }
    }),
    Object.assign(ig.prototype, {
        center: function(a) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(a)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(a) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(a)
        },
        size: function(a) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(a)
        }
    }),
    Object.assign(p.prototype, {
        center: function(a) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(a)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(a) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(a)
        },
        isIntersectionSphere: function(a) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(a)
        },
        size: function(a) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(a)
        }
    }),
    jg.prototype.center = function(a) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(a)
    }
    ,
    Object.assign(Sg, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(a) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            Sg.floorPowerOfTwo(a)
        },
        nextPowerOfTwo: function(a) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            Sg.ceilPowerOfTwo(a)
        }
    }),
    Object.assign(f.prototype, {
        flattenToArrayOffset: function(a, b) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(a, b)
        },
        multiplyVector3: function(a) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            a.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(a) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(a)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(k.prototype, {
        extractPosition: function(a) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(a)
        },
        flattenToArrayOffset: function(a, b) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(a, b)
        },
        getPosition: function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new e).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(a) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(a)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            a.applyMatrix4(this)
        },
        multiplyVector4: function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            a.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            a.transformDirection(this)
        },
        crossVector: function(a) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            a.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(a) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(a)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(a, b, c, d, e, f) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(a, b, d, c, e, f)
        }
    }),
    t.prototype.isIntersectionLine = function(a) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(a)
    }
    ,
    d.prototype.multiplyVector3 = function(a) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        a.applyQuaternion(this)
    }
    ,
    Object.assign(s.prototype, {
        isIntersectionBox: function(a) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(a)
        },
        isIntersectionPlane: function(a) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(a)
        },
        isIntersectionSphere: function(a) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(a)
        }
    }),
    Object.assign(u.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(a, b) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(a, b)
        },
        midpoint: function(a) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(a)
        },
        normal: function(a) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(a)
        },
        plane: function(a) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(a)
        }
    }),
    Object.assign(u, {
        barycoordFromPoint: function(a, b, c, d, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            u.getBarycoord(a, b, c, d, e)
        },
        normal: function(a, b, c, d) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            u.getNormal(a, b, c, d)
        }
    }),
    Object.assign(qf.prototype, {
        extractAllPoints: function(a) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(a)
        },
        extrude: function(a) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Zd(this,a)
        },
        makeGeometry: function(a) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new ie(this,a)
        }
    }),
    Object.assign(c.prototype, {
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(a, b, c)
        },
        distanceToManhattan: function(a) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(a)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(e.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(a) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(a)
        },
        getScaleFromMatrix: function(a) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(a)
        },
        getColumnFromMatrix: function(a, b) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(b, a)
        },
        applyProjection: function(a) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(a)
        },
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(a, b, c)
        },
        distanceToManhattan: function(a) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(a)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(h.prototype, {
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(a, b, c)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(S.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign(n.prototype, {
        getChildByName: function(a) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(a)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(a, b) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(b, a)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }),
    Object.defineProperties(n.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(a) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = a
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.assign(P.prototype, {
        setDrawMode: function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }),
    Object.defineProperties(P.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    Object.defineProperties(Zc.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(_c.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    $c.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty($e.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(a) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = a
        }
    }),
    X.prototype.setLens = function(a, b) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== b && (this.filmGauge = b),
        this.setFocalLength(a)
    }
    ,
    Object.defineProperties(rf.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = a
            }
        },
        shadowCameraLeft: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = a
            }
        },
        shadowCameraRight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = a
            }
        },
        shadowCameraTop: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = a
            }
        },
        shadowCameraBottom: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = a
            }
        },
        shadowCameraNear: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = a
            }
        },
        shadowCameraFar: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = a
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(a) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = a
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = a
            }
        },
        shadowMapHeight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = a
            }
        }
    }),
    Object.defineProperties(C.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                35048 === this.usage
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(35048)
            }
        }
    }),
    Object.assign(C.prototype, {
        setDynamic: function(a) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === a ? 35048 : 35044),
            this
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign(O.prototype, {
        addIndex: function(a) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(a)
        },
        addAttribute: function(a, b, c) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(b),
            this) : this.setAttribute(a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(a, new C(b,c)))
        },
        addDrawCall: function(a, b, c) {
            void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(a, b)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function(a) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(a)
        }
    }),
    Object.defineProperties(O.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.defineProperties(Uc.prototype, {
        dynamic: {
            get: function() {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                35048 === this.usage
            },
            set: function(a) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.setUsage(a)
            }
        }
    }),
    Object.assign(Uc.prototype, {
        setDynamic: function(a) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === a ? 35048 : 35044),
            this
        },
        setArray: function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign($d.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(bg.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(A.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new v
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(a) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === a
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(a) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = a
            }
        }
    }),
    Object.defineProperties(we.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(V.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(a) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = a
            }
        }
    }),
    Object.assign(Rc.prototype, {
        clearTarget: function(a, b, c, d) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(a),
            this.clear(b, c, d)
        },
        animate: function(a) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(a)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(a) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(a)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
    }),
    Object.defineProperties(Rc.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = a
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = a
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === a ? 3001 : 3e3
            }
        }
    }),
    Object.defineProperties(Ic.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Z.prototype, {
        activeCubeFace: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }),
    Object.defineProperties(i.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = a
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = a
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = a
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = a
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = a
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = a
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = a
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = a
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = a
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = a
            }
        }
    }),
    Object.defineProperties(Uf.prototype, {
        load: {
            value: function(a) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var b = this;
                return (new Mf).load(a, function(a) {
                    b.setBuffer(a)
                }),
                this
            }
        },
        startTime: {
            set: function() {
                console.warn("THREE.Audio: .startTime is now .play( delay ).")
            }
        }
    }),
    Wf.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    Y.prototype.updateCubeMap = function(a, b) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(a, b)
    }
    ,
    Xg.crossOrigin = void 0,
    Xg.loadTexture = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var e = new Ze;
        return e.setCrossOrigin(this.crossOrigin),
        a = e.load(a, c, void 0, d),
        b && (a.mapping = b),
        a
    }
    ,
    Xg.loadTextureCube = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var e = new Ye;
        return e.setCrossOrigin(this.crossOrigin),
        a = e.load(a, c, void 0, d),
        b && (a.mapping = b),
        a
    }
    ,
    Xg.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    Xg.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "112"
        }
    })),
    a.ACESFilmicToneMapping = 5,
    a.AddEquation = 100,
    a.AddOperation = 2,
    a.AdditiveBlending = 2,
    a.AlphaFormat = 1021,
    a.AlwaysDepth = 1,
    a.AlwaysStencilFunc = 519,
    a.AmbientLight = Bf,
    a.AmbientLightProbe = Qf,
    a.AnimationClip = Oe,
    a.AnimationLoader = Ue,
    a.AnimationMixer = ag,
    a.AnimationObjectGroup = $f,
    a.AnimationUtils = Mj,
    a.ArcCurve = af,
    a.ArrayCamera = Oc,
    a.ArrowHelper = yg,
    a.Audio = Uf,
    a.AudioAnalyser = Wf,
    a.AudioContext = _j,
    a.AudioListener = Tf,
    a.AudioLoader = Mf,
    a.AxesHelper = zg,
    a.AxisHelper = function(a) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new zg(a)
    }
    ,
    a.BackSide = 1,
    a.BasicDepthPacking = 3200,
    a.BasicShadowMap = 0,
    a.BinaryTextureLoader = function(a) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new We(a)
    }
    ,
    a.Bone = ad,
    a.BooleanKeyframeTrack = He,
    a.BoundingBoxHelper = function(a, b) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new vg(a,b)
    }
    ,
    a.Box2 = ig,
    a.Box3 = p,
    a.Box3Helper = wg,
    a.BoxBufferGeometry = Hi,
    a.BoxGeometry = Gi,
    a.BoxHelper = vg,
    a.BufferAttribute = C,
    a.BufferGeometry = O,
    a.BufferGeometryLoader = Gf,
    a.ByteType = 1010,
    a.Cache = Nj,
    a.Camera = W,
    a.CameraHelper = tg,
    a.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed")
    }
    ,
    a.CanvasTexture = ld,
    a.CatmullRomCurve3 = cf,
    a.CineonToneMapping = 4,
    a.CircleBufferGeometry = re,
    a.CircleGeometry = qe,
    a.ClampToEdgeWrapping = 1001,
    a.Clock = Sf,
    a.ClosedSplineCurve3 = Ng,
    a.Color = v,
    a.ColorKeyframeTrack = Ie,
    a.CompressedTexture = kd,
    a.CompressedTextureLoader = Ve,
    a.ConeBufferGeometry = pe,
    a.ConeGeometry = oe,
    a.CubeCamera = Y,
    a.CubeGeometry = Gi,
    a.CubeReflectionMapping = 301,
    a.CubeRefractionMapping = 302,
    a.CubeTexture = pb,
    a.CubeTextureLoader = Ye,
    a.CubeUVReflectionMapping = 306,
    a.CubeUVRefractionMapping = 307,
    a.CubicBezierCurve = gf,
    a.CubicBezierCurve3 = hf,
    a.CubicInterpolant = De,
    a.CullFaceBack = 1,
    a.CullFaceFront = 2,
    a.CullFaceFrontBack = 3,
    a.CullFaceNone = 0,
    a.Curve = $e,
    a.CurvePath = of,
    a.CustomBlending = 5,
    a.CylinderBufferGeometry = ne,
    a.CylinderGeometry = me,
    a.Cylindrical = hg,
    a.DataTexture = $,
    a.DataTexture2DArray = qb,
    a.DataTexture3D = rb,
    a.DataTextureLoader = We,
    a.DecrementStencilOp = 7683,
    a.DecrementWrapStencilOp = 34056,
    a.DefaultLoadingManager = Oj,
    a.DepthFormat = 1026,
    a.DepthStencilFormat = 1027,
    a.DepthTexture = md,
    a.DirectionalLight = Af,
    a.DirectionalLightHelper = sg,
    a.DirectionalLightShadow = zf,
    a.DiscreteInterpolant = Fe,
    a.DodecahedronBufferGeometry = zd,
    a.DodecahedronGeometry = yd,
    a.DoubleSide = 2,
    a.DstAlphaFactor = 206,
    a.DstColorFactor = 208,
    a.DynamicBufferAttribute = function(a, b) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new C(a,b).setDynamic(!0)
    }
    ,
    a.DynamicCopyUsage = 35050,
    a.DynamicDrawUsage = 35048,
    a.DynamicReadUsage = 35049,
    a.EdgesGeometry = le,
    a.EdgesHelper = function(a, b) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new ed(new le(a.geometry),new cd({
            color: void 0 !== b ? b : 16777215
        }))
    }
    ,
    a.EllipseCurve = _e,
    a.EqualDepth = 4,
    a.EqualStencilFunc = 514,
    a.EquirectangularReflectionMapping = 303,
    a.EquirectangularRefractionMapping = 304,
    a.Euler = l,
    a.EventDispatcher = b,
    a.ExtrudeBufferGeometry = $d,
    a.ExtrudeGeometry = Zd,
    a.Face3 = z,
    a.Face4 = function(a, b, c, d, e, f, g) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new z(a,b,c,e,f,g)
    }
    ,
    a.FaceColors = 1,
    a.FileLoader = Te,
    a.FlatShading = 1,
    a.Float32Attribute = function(a, b) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new K(a,b)
    }
    ,
    a.Float32BufferAttribute = K,
    a.Float64Attribute = function(a, b) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new L(a,b)
    }
    ,
    a.Float64BufferAttribute = L,
    a.FloatType = 1015,
    a.Fog = Tc,
    a.FogExp2 = Sc,
    a.Font = Kf,
    a.FontLoader = Lf,
    a.FrontFaceDirectionCCW = 1,
    a.FrontFaceDirectionCW = 0,
    a.FrontSide = 0,
    a.Frustum = _,
    a.GammaEncoding = 3007,
    a.Geometry = S,
    a.GeometryUtils = {
        merge: function(a, b, c) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            b.isMesh) {
                b.matrixAutoUpdate && b.updateMatrix();
                var d = b.matrix;
                b = b.geometry
            }
            a.merge(b, d, c)
        },
        center: function(a) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            a.center()
        }
    },
    a.GreaterDepth = 6,
    a.GreaterEqualDepth = 5,
    a.GreaterEqualStencilFunc = 518,
    a.GreaterStencilFunc = 516,
    a.GridHelper = qg,
    a.Group = Pc,
    a.HalfFloatType = 1016,
    a.HemisphereLight = sf,
    a.HemisphereLightHelper = pg,
    a.HemisphereLightProbe = Pf,
    a.IcosahedronBufferGeometry = xd,
    a.IcosahedronGeometry = wd,
    a.ImageBitmapLoader = If,
    a.ImageLoader = Xe,
    a.ImageUtils = Xg,
    a.ImmediateRenderObject = kg,
    a.IncrementStencilOp = 7682,
    a.IncrementWrapStencilOp = 34055,
    a.InstancedBufferAttribute = Ff,
    a.InstancedBufferGeometry = Ef,
    a.InstancedInterleavedBuffer = cg,
    a.InstancedMesh = bd,
    a.Int16Attribute = function(a, b) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new G(a,b)
    }
    ,
    a.Int16BufferAttribute = G,
    a.Int32Attribute = function(a, b) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new I(a,b)
    }
    ,
    a.Int32BufferAttribute = I,
    a.Int8Attribute = function(a, b) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new D(a,b)
    }
    ,
    a.Int8BufferAttribute = D,
    a.IntType = 1013,
    a.InterleavedBuffer = Uc,
    a.InterleavedBufferAttribute = Vc,
    a.Interpolant = Ce,
    a.InterpolateDiscrete = 2300,
    a.InterpolateLinear = 2301,
    a.InterpolateSmooth = 2302,
    a.InvertStencilOp = 5386,
    a.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.")
    }
    ,
    a.KeepStencilOp = 7680,
    a.KeyframeTrack = Ge,
    a.LOD = Zc,
    a.LatheBufferGeometry = he,
    a.LatheGeometry = ge,
    a.Layers = m,
    a.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
    ,
    a.LessDepth = 2,
    a.LessEqualDepth = 3,
    a.LessEqualStencilFunc = 515,
    a.LessStencilFunc = 513,
    a.Light = rf,
    a.LightProbe = Of,
    a.LightShadow = tf,
    a.Line = dd,
    a.Line3 = jg,
    a.LineBasicMaterial = cd,
    a.LineCurve = jf,
    a.LineCurve3 = kf,
    a.LineDashedMaterial = Be,
    a.LineLoop = fd,
    a.LinePieces = 1,
    a.LineSegments = ed,
    a.LineStrip = 0,
    a.LinearEncoding = 3e3,
    a.LinearFilter = 1006,
    a.LinearInterpolant = Ee,
    a.LinearMipMapLinearFilter = 1008,
    a.LinearMipMapNearestFilter = 1007,
    a.LinearMipmapLinearFilter = 1008,
    a.LinearMipmapNearestFilter = 1007,
    a.LinearToneMapping = 1,
    a.Loader = Se,
    a.LoaderUtils = Vj,
    a.LoadingManager = Re,
    a.LogLuvEncoding = 3003,
    a.LoopOnce = 2200,
    a.LoopPingPong = 2202,
    a.LoopRepeat = 2201,
    a.LuminanceAlphaFormat = 1025,
    a.LuminanceFormat = 1024,
    a.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    a.Material = A,
    a.MaterialLoader = Df,
    a.Math = Sg,
    a.Matrix3 = f,
    a.Matrix4 = k,
    a.MaxEquation = 104,
    a.Mesh = P,
    a.MeshBasicMaterial = B,
    a.MeshDepthMaterial = Gc,
    a.MeshDistanceMaterial = Hc,
    a.MeshFaceMaterial = function(a) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        a
    }
    ,
    a.MeshLambertMaterial = ze,
    a.MeshMatcapMaterial = Ae,
    a.MeshNormalMaterial = ye,
    a.MeshPhongMaterial = we,
    a.MeshPhysicalMaterial = ve,
    a.MeshStandardMaterial = ue,
    a.MeshToonMaterial = xe,
    a.MinEquation = 103,
    a.MirroredRepeatWrapping = 1002,
    a.MixOperation = 1,
    a.MultiMaterial = function(a) {
        return void 0 === a && (a = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        a.isMultiMaterial = !0,
        a.materials = a,
        a.clone = function() {
            return a.slice()
        }
        ,
        a
    }
    ,
    a.MultiplyBlending = 4,
    a.MultiplyOperation = 0,
    a.NearestFilter = 1003,
    a.NearestMipMapLinearFilter = 1005,
    a.NearestMipMapNearestFilter = 1004,
    a.NearestMipmapLinearFilter = 1005,
    a.NearestMipmapNearestFilter = 1004,
    a.NeverDepth = 0,
    a.NeverStencilFunc = 512,
    a.NoBlending = 0,
    a.NoColors = 0,
    a.NoToneMapping = 0,
    a.NormalBlending = 1,
    a.NotEqualDepth = 7,
    a.NotEqualStencilFunc = 517,
    a.NumberKeyframeTrack = Je,
    a.Object3D = n,
    a.ObjectLoader = Hf,
    a.ObjectSpaceNormalMap = 1,
    a.OctahedronBufferGeometry = vd,
    a.OctahedronGeometry = ud,
    a.OneFactor = 201,
    a.OneMinusDstAlphaFactor = 207,
    a.OneMinusDstColorFactor = 209,
    a.OneMinusSrcAlphaFactor = 205,
    a.OneMinusSrcColorFactor = 203,
    a.OrthographicCamera = yf,
    a.PCFShadowMap = 1,
    a.PCFSoftShadowMap = 2,
    a.PMREMGenerator = Ag,
    a.ParametricBufferGeometry = pd,
    a.ParametricGeometry = od,
    a.Particle = function(a) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Xc(a)
    }
    ,
    a.ParticleBasicMaterial = function(a) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new gd(a)
    }
    ,
    a.ParticleSystem = function(a, b) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new hd(a,b)
    }
    ,
    a.ParticleSystemMaterial = function(a) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new gd(a)
    }
    ,
    a.Path = pf,
    a.PerspectiveCamera = X,
    a.Plane = t,
    a.PlaneBufferGeometry = db,
    a.PlaneGeometry = cb,
    a.PlaneHelper = xg,
    a.PointCloud = function(a, b) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new hd(a,b)
    }
    ,
    a.PointCloudMaterial = function(a) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new gd(a)
    }
    ,
    a.PointLight = xf,
    a.PointLightHelper = og,
    a.Points = hd,
    a.PointsMaterial = gd,
    a.PolarGridHelper = rg,
    a.PolyhedronBufferGeometry = rd,
    a.PolyhedronGeometry = qd,
    a.PositionalAudio = Vf,
    a.PropertyBinding = Zf,
    a.PropertyMixer = Xf,
    a.QuadraticBezierCurve = lf,
    a.QuadraticBezierCurve3 = mf,
    a.Quaternion = d,
    a.QuaternionKeyframeTrack = Le,
    a.QuaternionLinearInterpolant = Ke,
    a.REVISION = "112",
    a.RGBADepthPacking = 3201,
    a.RGBAFormat = 1023,
    a.RGBAIntegerFormat = 1033,
    a.RGBA_ASTC_10x10_Format = 37819,
    a.RGBA_ASTC_10x5_Format = 37816,
    a.RGBA_ASTC_10x6_Format = 37817,
    a.RGBA_ASTC_10x8_Format = 37818,
    a.RGBA_ASTC_12x10_Format = 37820,
    a.RGBA_ASTC_12x12_Format = 37821,
    a.RGBA_ASTC_4x4_Format = 37808,
    a.RGBA_ASTC_5x4_Format = 37809,
    a.RGBA_ASTC_5x5_Format = 37810,
    a.RGBA_ASTC_6x5_Format = 37811,
    a.RGBA_ASTC_6x6_Format = 37812,
    a.RGBA_ASTC_8x5_Format = 37813,
    a.RGBA_ASTC_8x6_Format = 37814,
    a.RGBA_ASTC_8x8_Format = 37815,
    a.RGBA_PVRTC_2BPPV1_Format = 35843,
    a.RGBA_PVRTC_4BPPV1_Format = 35842,
    a.RGBA_S3TC_DXT1_Format = 33777,
    a.RGBA_S3TC_DXT3_Format = 33778,
    a.RGBA_S3TC_DXT5_Format = 33779,
    a.RGBDEncoding = 3006,
    a.RGBEEncoding = 3002,
    a.RGBEFormat = 1023,
    a.RGBFormat = 1022,
    a.RGBIntegerFormat = 1032,
    a.RGBM16Encoding = 3005,
    a.RGBM7Encoding = 3004,
    a.RGB_ETC1_Format = 36196,
    a.RGB_PVRTC_2BPPV1_Format = 35841,
    a.RGB_PVRTC_4BPPV1_Format = 35840,
    a.RGB_S3TC_DXT1_Format = 33776,
    a.RGFormat = 1030,
    a.RGIntegerFormat = 1031,
    a.RawShaderMaterial = te,
    a.Ray = s,
    a.Raycaster = dg,
    a.RectAreaLight = Cf,
    a.RedFormat = 1028,
    a.RedIntegerFormat = 1029,
    a.ReinhardToneMapping = 2,
    a.RepeatWrapping = 1e3,
    a.ReplaceStencilOp = 7681,
    a.ReverseSubtractEquation = 102,
    a.RingBufferGeometry = fe,
    a.RingGeometry = ee,
    a.Scene = o,
    a.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    },
    a.ShaderChunk = Li,
    a.ShaderLib = Ni,
    a.ShaderMaterial = V,
    a.ShadowMaterial = se,
    a.Shape = qf,
    a.ShapeBufferGeometry = je,
    a.ShapeGeometry = ie,
    a.ShapePath = Jf,
    a.ShapeUtils = Ij,
    a.ShortType = 1011,
    a.Skeleton = _c,
    a.SkeletonHelper = ng,
    a.SkinnedMesh = $c,
    a.SmoothShading = 2,
    a.Sphere = r,
    a.SphereBufferGeometry = de,
    a.SphereGeometry = ce,
    a.Spherical = gg,
    a.SphericalHarmonics3 = Nf,
    a.SphericalReflectionMapping = 305,
    a.Spline = Pg,
    a.SplineCurve = nf,
    a.SplineCurve3 = Og,
    a.SpotLight = vf,
    a.SpotLightHelper = lg,
    a.SpotLightShadow = uf,
    a.Sprite = Xc,
    a.SpriteMaterial = Wc,
    a.SrcAlphaFactor = 204,
    a.SrcAlphaSaturateFactor = 210,
    a.SrcColorFactor = 202,
    a.StaticCopyUsage = 35046,
    a.StaticDrawUsage = 35044,
    a.StaticReadUsage = 35045,
    a.StereoCamera = Rf,
    a.StreamCopyUsage = 35042,
    a.StreamDrawUsage = 35040,
    a.StreamReadUsage = 35041,
    a.StringKeyframeTrack = Me,
    a.SubtractEquation = 101,
    a.SubtractiveBlending = 3,
    a.TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    a.TangentSpaceNormalMap = 0,
    a.TetrahedronBufferGeometry = td,
    a.TetrahedronGeometry = sd,
    a.TextBufferGeometry = be,
    a.TextGeometry = ae,
    a.Texture = g,
    a.TextureLoader = Ze,
    a.TorusBufferGeometry = Fd,
    a.TorusGeometry = Ed,
    a.TorusKnotBufferGeometry = Dd,
    a.TorusKnotGeometry = Cd,
    a.Triangle = u,
    a.TriangleFanDrawMode = 2,
    a.TriangleStripDrawMode = 1,
    a.TrianglesDrawMode = 0,
    a.TubeBufferGeometry = Bd,
    a.TubeGeometry = Ad,
    a.UVMapping = 300,
    a.Uint16Attribute = function(a, b) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new H(a,b)
    }
    ,
    a.Uint16BufferAttribute = H,
    a.Uint32Attribute = function(a, b) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new J(a,b)
    }
    ,
    a.Uint32BufferAttribute = J,
    a.Uint8Attribute = function(a, b) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new E(a,b)
    }
    ,
    a.Uint8BufferAttribute = E,
    a.Uint8ClampedAttribute = function(a, b) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new F(a,b)
    }
    ,
    a.Uint8ClampedBufferAttribute = F,
    a.Uncharted2ToneMapping = 3,
    a.Uniform = bg,
    a.UniformsLib = Mi,
    a.UniformsUtils = Ii,
    a.UnsignedByteType = 1009,
    a.UnsignedInt248Type = 1020,
    a.UnsignedIntType = 1014,
    a.UnsignedShort4444Type = 1017,
    a.UnsignedShort5551Type = 1018,
    a.UnsignedShort565Type = 1019,
    a.UnsignedShortType = 1012,
    a.VSMShadowMap = 3,
    a.Vector2 = c,
    a.Vector3 = e,
    a.Vector4 = h,
    a.VectorKeyframeTrack = Ne,
    a.Vertex = function(a, b, c) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new e(a,b,c)
    }
    ,
    a.VertexColors = 2,
    a.VideoTexture = jd,
    a.WebGLMultisampleRenderTarget = j,
    a.WebGLRenderTarget = i,
    a.WebGLRenderTargetCube = Z,
    a.WebGLRenderer = Rc,
    a.WebGLUtils = Lc,
    a.WireframeGeometry = nd,
    a.WireframeHelper = function(a, b) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new ed(new nd(a.geometry),new cd({
            color: void 0 !== b ? b : 16777215
        }))
    }
    ,
    a.WrapAroundEnding = 2402,
    a.XHRLoader = function(a) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new Te(a)
    }
    ,
    a.ZeroCurvatureEnding = 2400,
    a.ZeroFactor = 200,
    a.ZeroSlopeEnding = 2401,
    a.ZeroStencilOp = 0,
    a.sRGBEncoding = 3001,
    Object.defineProperty(a, "__esModule", {
        value: !0
    })
});
